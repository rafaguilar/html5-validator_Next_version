{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/BACK-UP%20II/Desktop/PGD/PGD%20-%20Labs/html5-validator_Next_version/node_modules/stylelint/lib/utils/containsString.mjs"],"sourcesContent":["import { isString } from './validateTypes.mjs';\n\n/** @typedef {false | { match: string, pattern: string, substring: string }} ReturnValue */\n\n/**\n * Checks if a string contains a value. The comparison value can be a string or\n * an array of strings.\n *\n * Any strings starting and ending with `/` are ignored. Use the\n * matchesStringOrRegExp() util to match regexes.\n *\n * @template {unknown} T\n * @param {string} input\n * @param {T | T[]} comparison\n * @returns {ReturnValue}\n */\nexport default function containsString(input, comparison) {\n\tif (!Array.isArray(comparison)) {\n\t\treturn testAgainstString(input, comparison);\n\t}\n\n\tfor (const comparisonItem of comparison) {\n\t\tconst testResult = testAgainstString(input, comparisonItem);\n\n\t\tif (testResult) {\n\t\t\treturn testResult;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * @param {string} value\n * @param {unknown} comparison\n * @returns {ReturnValue}\n */\nfunction testAgainstString(value, comparison) {\n\tif (!comparison) return false;\n\n\tif (!isString(comparison)) return false;\n\n\tif (comparison.startsWith('/') && comparison.endsWith('/')) {\n\t\treturn false;\n\t}\n\n\tif (value.includes(comparison)) {\n\t\treturn { match: value, pattern: comparison, substring: comparison };\n\t}\n\n\treturn false;\n}\n"],"names":[],"mappings":";;;AAAA;;AAgBe,SAAS,eAAe,KAAK,EAAE,UAAU;IACvD,IAAI,CAAC,MAAM,OAAO,CAAC,aAAa;QAC/B,OAAO,kBAAkB,OAAO;IACjC;IAEA,KAAK,MAAM,kBAAkB,WAAY;QACxC,MAAM,aAAa,kBAAkB,OAAO;QAE5C,IAAI,YAAY;YACf,OAAO;QACR;IACD;IAEA,OAAO;AACR;AAEA;;;;CAIC,GACD,SAAS,kBAAkB,KAAK,EAAE,UAAU;IAC3C,IAAI,CAAC,YAAY,OAAO;IAExB,IAAI,CAAC,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE,aAAa,OAAO;IAElC,IAAI,WAAW,UAAU,CAAC,QAAQ,WAAW,QAAQ,CAAC,MAAM;QAC3D,OAAO;IACR;IAEA,IAAI,MAAM,QAAQ,CAAC,aAAa;QAC/B,OAAO;YAAE,OAAO;YAAO,SAAS;YAAY,WAAW;QAAW;IACnE;IAEA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/BACK-UP%20II/Desktop/PGD/PGD%20-%20Labs/html5-validator_Next_version/node_modules/stylelint/lib/rules/comment-word-disallowed-list/index.mjs"],"sourcesContent":["import { isRegExp, isString } from '../../utils/validateTypes.mjs';\nimport containsString from '../../utils/containsString.mjs';\nimport matchesStringOrRegExp from '../../utils/matchesStringOrRegExp.mjs';\nimport report from '../../utils/report.mjs';\nimport ruleMessages from '../../utils/ruleMessages.mjs';\nimport validateOptions from '../../utils/validateOptions.mjs';\n\nconst ruleName = 'comment-word-disallowed-list';\n\nconst messages = ruleMessages(ruleName, {\n\trejected: (pattern) => `Unexpected word matching pattern \"${pattern}\"`,\n});\n\nconst meta = {\n\turl: 'https://stylelint.io/user-guide/rules/comment-word-disallowed-list',\n};\n\n/** @type {import('stylelint').CoreRules[ruleName]} */\nconst rule = (primary) => {\n\treturn (root, result) => {\n\t\tconst validOptions = validateOptions(result, ruleName, {\n\t\t\tactual: primary,\n\t\t\tpossible: [isString, isRegExp],\n\t\t});\n\n\t\tif (!validOptions) {\n\t\t\treturn;\n\t\t}\n\n\t\troot.walkComments((comment) => {\n\t\t\tconst text = comment.text;\n\t\t\tconst rawComment = comment.toString();\n\t\t\tconst firstFourChars = rawComment.slice(0, 4);\n\n\t\t\t// Return early if sourcemap\n\t\t\tif (firstFourChars === '/*# ') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst matchesWord = matchesStringOrRegExp(text, primary) || containsString(text, primary);\n\n\t\t\tif (!matchesWord) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treport({\n\t\t\t\tmessage: messages.rejected,\n\t\t\t\tmessageArgs: [matchesWord.pattern],\n\t\t\t\tnode: comment,\n\t\t\t\tword: matchesWord.substring,\n\t\t\t\tresult,\n\t\t\t\truleName,\n\t\t\t});\n\t\t});\n\t};\n};\n\nrule.primaryOptionArray = true;\n\nrule.ruleName = ruleName;\nrule.messages = messages;\nrule.meta = meta;\nexport default rule;\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA,MAAM,WAAW;AAEjB,MAAM,WAAW,CAAA,GAAA,4JAAA,CAAA,UAAY,AAAD,EAAE,UAAU;IACvC,UAAU,CAAC,UAAY,CAAC,kCAAkC,EAAE,QAAQ,CAAC,CAAC;AACvE;AAEA,MAAM,OAAO;IACZ,KAAK;AACN;AAEA,oDAAoD,GACpD,MAAM,OAAO,CAAC;IACb,OAAO,CAAC,MAAM;QACb,MAAM,eAAe,CAAA,GAAA,+JAAA,CAAA,UAAe,AAAD,EAAE,QAAQ,UAAU;YACtD,QAAQ;YACR,UAAU;gBAAC,6JAAA,CAAA,WAAQ;gBAAE,6JAAA,CAAA,WAAQ;aAAC;QAC/B;QAEA,IAAI,CAAC,cAAc;YAClB;QACD;QAEA,KAAK,YAAY,CAAC,CAAC;YAClB,MAAM,OAAO,QAAQ,IAAI;YACzB,MAAM,aAAa,QAAQ,QAAQ;YACnC,MAAM,iBAAiB,WAAW,KAAK,CAAC,GAAG;YAE3C,4BAA4B;YAC5B,IAAI,mBAAmB,QAAQ;gBAC9B;YACD;YAEA,MAAM,cAAc,CAAA,GAAA,qKAAA,CAAA,UAAqB,AAAD,EAAE,MAAM,YAAY,CAAA,GAAA,8JAAA,CAAA,UAAc,AAAD,EAAE,MAAM;YAEjF,IAAI,CAAC,aAAa;gBACjB;YACD;YAEA,CAAA,GAAA,sJAAA,CAAA,UAAM,AAAD,EAAE;gBACN,SAAS,SAAS,QAAQ;gBAC1B,aAAa;oBAAC,YAAY,OAAO;iBAAC;gBAClC,MAAM;gBACN,MAAM,YAAY,SAAS;gBAC3B;gBACA;YACD;QACD;IACD;AACD;AAEA,KAAK,kBAAkB,GAAG;AAE1B,KAAK,QAAQ,GAAG;AAChB,KAAK,QAAQ,GAAG;AAChB,KAAK,IAAI,GAAG;uCACG","ignoreList":[0],"debugId":null}}]
}