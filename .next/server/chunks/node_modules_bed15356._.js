module.exports = {

"[project]/node_modules/is-plain-object/dist/is-plain-object.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ __turbopack_context__.s({
    "isPlainObject": (()=>isPlainObject)
});
function isObject(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
}
function isPlainObject(o) {
    var ctor, prot;
    if (isObject(o) === false) return false;
    // If has modified constructor
    ctor = o.constructor;
    if (ctor === undefined) return true;
    // If has modified prototype
    prot = ctor.prototype;
    if (isObject(prot) === false) return false;
    // If constructor does not have an Object-specific method
    if (prot.hasOwnProperty('isPrototypeOf') === false) {
        return false;
    }
    // Most likely a plain Object
    return true;
}
;
}}),
"[project]/node_modules/source-map-js/lib/base64.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */ exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
};
/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */ exports.decode = function(charCode) {
    var bigA = 65; // 'A'
    var bigZ = 90; // 'Z'
    var littleA = 97; // 'a'
    var littleZ = 122; // 'z'
    var zero = 48; // '0'
    var nine = 57; // '9'
    var plus = 43; // '+'
    var slash = 47; // '/'
    var littleOffset = 26;
    var numberOffset = 52;
    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
    }
    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
    }
    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
    }
    // 62: +
    if (charCode == plus) {
        return 62;
    }
    // 63: /
    if (charCode == slash) {
        return 63;
    }
    // Invalid base64 digit.
    return -1;
};
}}),
"[project]/node_modules/source-map-js/lib/base64-vlq.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ var base64 = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64.js [app-route] (ecmascript)");
// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011
var VLQ_BASE_SHIFT = 5;
// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;
// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;
/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */ function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */ function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
}
/**
 * Returns the base 64 VLQ encoded value.
 */ exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
    }while (vlq > 0)
    return encoded;
};
/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */ exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
        if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
    }while (continuation)
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
};
}}),
"[project]/node_modules/source-map-js/lib/util.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ /**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */ function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
        return aArgs[aName];
    } else if (arguments.length === 3) {
        return aDefaultValue;
    } else {
        throw new Error('"' + aName + '" is a required argument.');
    }
}
exports.getArg = getArg;
var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;
function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
        return null;
    }
    return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
    };
}
exports.urlParse = urlParse;
function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
        url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
        url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
        url += aParsedUrl.path;
    }
    return url;
}
exports.urlGenerate = urlGenerate;
var MAX_CACHED_INPUTS = 32;
/**
 * Takes some function `f(input) -> result` and returns a memoized version of
 * `f`.
 *
 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
 * memoization is a dumb-simple, linear least-recently-used cache.
 */ function lruMemoize(f) {
    var cache = [];
    return function(input) {
        for(var i = 0; i < cache.length; i++){
            if (cache[i].input === input) {
                var temp = cache[0];
                cache[0] = cache[i];
                cache[i] = temp;
                return cache[0].result;
            }
        }
        var result = f(input);
        cache.unshift({
            input,
            result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
            cache.pop();
        }
        return result;
    };
}
/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */ var normalize = lruMemoize(function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
        if (!url.path) {
            return aPath;
        }
        path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);
    // Split the path into parts between `/` characters. This is much faster than
    // using `.split(/\/+/g)`.
    var parts = [];
    var start = 0;
    var i = 0;
    while(true){
        start = i;
        i = path.indexOf("/", start);
        if (i === -1) {
            parts.push(path.slice(start));
            break;
        } else {
            parts.push(path.slice(start, i));
            while(i < path.length && path[i] === "/"){
                i++;
            }
        }
    }
    for(var part, up = 0, i = parts.length - 1; i >= 0; i--){
        part = parts[i];
        if (part === '.') {
            parts.splice(i, 1);
        } else if (part === '..') {
            up++;
        } else if (up > 0) {
            if (part === '') {
                // The first part is blank if the path is absolute. Trying to go
                // above the root is a no-op. Therefore we can remove all '..' parts
                // directly after the root.
                parts.splice(i + 1, up);
                up = 0;
            } else {
                parts.splice(i, 2);
                up--;
            }
        }
    }
    path = parts.join('/');
    if (path === '') {
        path = isAbsolute ? '/' : '.';
    }
    if (url) {
        url.path = path;
        return urlGenerate(url);
    }
    return path;
});
exports.normalize = normalize;
/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */ function join(aRoot, aPath) {
    if (aRoot === "") {
        aRoot = ".";
    }
    if (aPath === "") {
        aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
        aRoot = aRootUrl.path || '/';
    }
    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
    }
    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
    if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
    }
    return joined;
}
exports.join = join;
exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};
/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */ function relative(aRoot, aPath) {
    if (aRoot === "") {
        aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, '');
    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while(aPath.indexOf(aRoot + '/') !== 0){
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
            return aPath;
        }
        // If the only part of the root that is left is the scheme (i.e. http://,
        // file:///, etc.), one or more slashes (/), or simply nothing at all, we
        // have exhausted all components, so the path is not relative to the root.
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
        }
        ++level;
    }
    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;
var supportsNullProto = function() {
    var obj = Object.create(null);
    return !('__proto__' in obj);
}();
function identity(s) {
    return s;
}
/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */ function toSetString(aStr) {
    if (isProtoString(aStr)) {
        return '$' + aStr;
    }
    return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;
function fromSetString(aStr) {
    if (isProtoString(aStr)) {
        return aStr.slice(1);
    }
    return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;
function isProtoString(s) {
    if (!s) {
        return false;
    }
    var length = s.length;
    if (length < 9 /* "__proto__".length */ ) {
        return false;
    }
    if (s.charCodeAt(length - 1) !== 95 /* '_' */  || s.charCodeAt(length - 2) !== 95 /* '_' */  || s.charCodeAt(length - 3) !== 111 /* 'o' */  || s.charCodeAt(length - 4) !== 116 /* 't' */  || s.charCodeAt(length - 5) !== 111 /* 'o' */  || s.charCodeAt(length - 6) !== 114 /* 'r' */  || s.charCodeAt(length - 7) !== 112 /* 'p' */  || s.charCodeAt(length - 8) !== 95 /* '_' */  || s.charCodeAt(length - 9) !== 95 /* '_' */ ) {
        return false;
    }
    for(var i = length - 10; i >= 0; i--){
        if (s.charCodeAt(i) !== 36 /* '$' */ ) {
            return false;
        }
    }
    return true;
}
/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */ function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;
function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */ function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
        return 0;
    }
    if (aStr1 === null) {
        return 1; // aStr2 !== null
    }
    if (aStr2 === null) {
        return -1; // aStr1 !== null
    }
    if (aStr1 > aStr2) {
        return 1;
    }
    return -1;
}
/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */ function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */ function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;
/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */ function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || '';
    if (sourceRoot) {
        // This follows what Chrome does.
        if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
            sourceRoot += '/';
        }
        // The spec says:
        //   Line 4: An optional source root, useful for relocating source
        //   files on a server or removing repeated values in the
        //   “sources” entry.  This value is prepended to the individual
        //   entries in the “source” field.
        sourceURL = sourceRoot + sourceURL;
    }
    // Historically, SourceMapConsumer did not take the sourceMapURL as
    // a parameter.  This mode is still somewhat supported, which is why
    // this code block is conditional.  However, it's preferable to pass
    // the source map URL to SourceMapConsumer, so that this function
    // can implement the source URL resolution algorithm as outlined in
    // the spec.  This block is basically the equivalent of:
    //    new URL(sourceURL, sourceMapURL).toString()
    // ... except it avoids using URL, which wasn't available in the
    // older releases of node still supported by this library.
    //
    // The spec says:
    //   If the sources are not absolute URLs after prepending of the
    //   “sourceRoot”, the sources are resolved relative to the
    //   SourceMap (like resolving script src in a html document).
    if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
            // Strip the last path component, but keep the "/".
            var index = parsed.path.lastIndexOf('/');
            if (index >= 0) {
                parsed.path = parsed.path.substring(0, index + 1);
            }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;
}}),
"[project]/node_modules/source-map-js/lib/array-set.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [app-route] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */ function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
}
/**
 * Static method for creating ArraySet instances from an existing array.
 */ ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for(var i = 0, len = aArray.length; i < len; i++){
        set.add(aArray[i], aAllowDuplicates);
    }
    return set;
};
/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */ ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
/**
 * Add the given string to this set.
 *
 * @param String aStr
 */ ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
    }
    if (!isDuplicate) {
        if (hasNativeMap) {
            this._set.set(aStr, idx);
        } else {
            this._set[sStr] = idx;
        }
    }
};
/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */ ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
        return this._set.has(aStr);
    } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
    }
};
/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */ ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
            return idx;
        }
    } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
            return this._set[sStr];
        }
    }
    throw new Error('"' + aStr + '" is not in the set.');
};
/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */ ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
};
/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */ ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
};
exports.ArraySet = ArraySet;
}}),
"[project]/node_modules/source-map-js/lib/mapping-list.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [app-route] (ecmascript)");
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */ function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */ function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {
        generatedLine: -1,
        generatedColumn: 0
    };
}
/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */ MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
};
/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */ MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
    } else {
        this._sorted = false;
        this._array.push(aMapping);
    }
};
/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */ MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
    }
    return this._array;
};
exports.MappingList = MappingList;
}}),
"[project]/node_modules/source-map-js/lib/source-map-generator.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var base64VLQ = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64-vlq.js [app-route] (ecmascript)");
var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [app-route] (ecmascript)");
var ArraySet = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/array-set.js [app-route] (ecmascript)").ArraySet;
var MappingList = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/mapping-list.js [app-route] (ecmascript)").MappingList;
/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */ function SourceMapGenerator(aArgs) {
    if (!aArgs) {
        aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._ignoreInvalidMapping = util.getArg(aArgs, 'ignoreInvalidMapping', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
}
SourceMapGenerator.prototype._version = 3;
/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */ SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
    }));
    aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
            generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
            }
        };
        if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn
            };
            if (mapping.name != null) {
                newMapping.name = mapping.name;
            }
        }
        generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            generator.setSourceContent(sourceFile, content);
        }
    });
    return generator;
};
/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */ SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);
    if (!this._skipValidation) {
        if (this._validateMapping(generated, original, source, name) === false) {
            return;
        }
    }
    if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
            this._sources.add(source);
        }
    }
    if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
            this._names.add(name);
        }
    }
    this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
    });
};
/**
 * Set the source content for a source file.
 */ SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
            this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
        }
    }
};
/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */ SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
        }
        sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
            // Check if it can be mapped by the source map, then update the mapping.
            var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
            });
            if (original.source != null) {
                // Copy mapping
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                    mapping.source = util.join(aSourceMapPath, mapping.source);
                }
                if (sourceRoot != null) {
                    mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                    mapping.name = original.name;
                }
            }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
            newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
            newNames.add(name);
        }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
            }
            if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
            }
            this.setSourceContent(sourceFile, content);
        }
    }, this);
};
/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */ SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        var message = 'original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.';
        if (this._ignoreInvalidMapping) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn(message);
            }
            return false;
        } else {
            throw new Error(message);
        }
    }
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        // Cases 2 and 3.
        return;
    } else {
        var message = 'Invalid mapping: ' + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
        });
        if (this._ignoreInvalidMapping) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn(message);
            }
            return false;
        } else {
            throw new Error(message);
        }
    }
};
/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */ SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for(var i = 0, len = mappings.length; i < len; i++){
        mapping = mappings[i];
        next = '';
        if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while(mapping.generatedLine !== previousGeneratedLine){
                next += ';';
                previousGeneratedLine++;
            }
        } else {
            if (i > 0) {
                if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                    continue;
                }
                next += ',';
            }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            // lines are stored 0-based in SourceMap spec version 3
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
                nameIdx = this._names.indexOf(mapping.name);
                next += base64VLQ.encode(nameIdx - previousName);
                previousName = nameIdx;
            }
        }
        result += next;
    }
    return result;
};
SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
        if (!this._sourcesContents) {
            return null;
        }
        if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
};
/**
 * Externalize the source map.
 */ SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
    };
    if (this._file != null) {
        map.file = this._file;
    }
    if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
};
/**
 * Render the source map being generated to a string.
 */ SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
};
exports.SourceMapGenerator = SourceMapGenerator;
}}),
"[project]/node_modules/import-fresh/node_modules/resolve-from/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const Module = __turbopack_context__.r("[externals]/module [external] (module, cjs)");
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const resolveFrom = (fromDir, moduleId, silent)=>{
    if (typeof fromDir !== 'string') {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDir}\``);
    }
    if (typeof moduleId !== 'string') {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
    }
    try {
        fromDir = fs.realpathSync(fromDir);
    } catch (err) {
        if (err.code === 'ENOENT') {
            fromDir = path.resolve(fromDir);
        } else if (silent) {
            return null;
        } else {
            throw err;
        }
    }
    const fromFile = path.join(fromDir, 'noop.js');
    const resolveFileName = ()=>Module._resolveFilename(moduleId, {
            id: fromFile,
            filename: fromFile,
            paths: Module._nodeModulePaths(fromDir)
        });
    if (silent) {
        try {
            return resolveFileName();
        } catch (err) {
            return null;
        }
    }
    return resolveFileName();
};
module.exports = (fromDir, moduleId)=>resolveFrom(fromDir, moduleId);
module.exports.silent = (fromDir, moduleId)=>resolveFrom(fromDir, moduleId, true);
}}),
"[project]/node_modules/resolve-from/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const Module = __turbopack_context__.r("[externals]/module [external] (module, cjs)");
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const resolveFrom = (fromDirectory, moduleId, silent)=>{
    if (typeof fromDirectory !== 'string') {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
    }
    if (typeof moduleId !== 'string') {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
    }
    try {
        fromDirectory = fs.realpathSync(fromDirectory);
    } catch (error) {
        if (error.code === 'ENOENT') {
            fromDirectory = path.resolve(fromDirectory);
        } else if (silent) {
            return;
        } else {
            throw error;
        }
    }
    const fromFile = path.join(fromDirectory, 'noop.js');
    const resolveFileName = ()=>Module._resolveFilename(moduleId, {
            id: fromFile,
            filename: fromFile,
            paths: Module._nodeModulePaths(fromDirectory)
        });
    if (silent) {
        try {
            return resolveFileName();
        } catch (error) {
            return;
        }
    }
    return resolveFileName();
};
module.exports = (fromDirectory, moduleId)=>resolveFrom(fromDirectory, moduleId);
module.exports.silent = (fromDirectory, moduleId)=>resolveFrom(fromDirectory, moduleId, true);
}}),
"[project]/node_modules/callsites/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const callsites = ()=>{
    const _prepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = (_, stack)=>stack;
    const stack = new Error().stack.slice(1);
    Error.prepareStackTrace = _prepareStackTrace;
    return stack;
};
module.exports = callsites;
// TODO: Remove this for the next major release
module.exports.default = callsites;
}}),
"[project]/node_modules/parent-module/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const callsites = __turbopack_context__.r("[project]/node_modules/callsites/index.js [app-route] (ecmascript)");
module.exports = (filepath)=>{
    const stacks = callsites();
    if (!filepath) {
        return stacks[2].getFileName();
    }
    let seenVal = false;
    // Skip the first stack as it's this function
    stacks.shift();
    for (const stack of stacks){
        const parentFilepath = stack.getFileName();
        if (typeof parentFilepath !== 'string') {
            continue;
        }
        if (parentFilepath === filepath) {
            seenVal = true;
            continue;
        }
        // Skip native modules
        if (parentFilepath === 'module.js') {
            continue;
        }
        if (seenVal && parentFilepath !== filepath) {
            return parentFilepath;
        }
    }
};
}}),
"[project]/node_modules/import-fresh/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const resolveFrom = __turbopack_context__.r("[project]/node_modules/import-fresh/node_modules/resolve-from/index.js [app-route] (ecmascript)");
const parentModule = __turbopack_context__.r("[project]/node_modules/parent-module/index.js [app-route] (ecmascript)");
module.exports = (moduleId)=>{
    if (typeof moduleId !== 'string') {
        throw new TypeError('Expected a string');
    }
    const parentPath = parentModule(__filename);
    const cwd = parentPath ? path.dirname(parentPath) : __dirname;
    const filePath = resolveFrom(cwd, moduleId);
    const oldModule = __turbopack_context__.c[filePath];
    // Delete itself from module parent
    if (oldModule && oldModule.parent) {
        let i = oldModule.parent.children.length;
        while(i--){
            if (oldModule.parent.children[i].id === filePath) {
                oldModule.parent.children.splice(i, 1);
            }
        }
    }
    delete __turbopack_context__.c[filePath]; // Delete module from cache
    const parent = __turbopack_context__.c[parentPath]; // If `filePath` and `parentPath` are the same, cache will already be deleted so we won't get a memory leak in next step
    // In case cache doesn't have parent, fall back to normal require
    return parent === undefined || parent.require === undefined ? (()=>{
        const e = new Error("Cannot find module as expression is too dynamic");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })() : parent.require(filePath);
};
}}),
"[project]/node_modules/error-ex/node_modules/is-arrayish/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = function isArrayish(obj) {
    if (!obj) {
        return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && obj.splice instanceof Function;
};
}}),
"[project]/node_modules/error-ex/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var isArrayish = __turbopack_context__.r("[project]/node_modules/error-ex/node_modules/is-arrayish/index.js [app-route] (ecmascript)");
var errorEx = function errorEx(name, properties) {
    if (!name || name.constructor !== String) {
        properties = name || {};
        name = Error.name;
    }
    var errorExError = function ErrorEXError(message) {
        if (!this) {
            return new ErrorEXError(message);
        }
        message = message instanceof Error ? message.message : message || this.message;
        Error.call(this, message);
        Error.captureStackTrace(this, errorExError);
        this.name = name;
        Object.defineProperty(this, 'message', {
            configurable: true,
            enumerable: false,
            get: function() {
                var newMessage = message.split(/\r?\n/g);
                for(var key in properties){
                    if (!properties.hasOwnProperty(key)) {
                        continue;
                    }
                    var modifier = properties[key];
                    if ('message' in modifier) {
                        newMessage = modifier.message(this[key], newMessage) || newMessage;
                        if (!isArrayish(newMessage)) {
                            newMessage = [
                                newMessage
                            ];
                        }
                    }
                }
                return newMessage.join('\n');
            },
            set: function(v) {
                message = v;
            }
        });
        var overwrittenStack = null;
        var stackDescriptor = Object.getOwnPropertyDescriptor(this, 'stack');
        var stackGetter = stackDescriptor.get;
        var stackValue = stackDescriptor.value;
        delete stackDescriptor.value;
        delete stackDescriptor.writable;
        stackDescriptor.set = function(newstack) {
            overwrittenStack = newstack;
        };
        stackDescriptor.get = function() {
            var stack = (overwrittenStack || (stackGetter ? stackGetter.call(this) : stackValue)).split(/\r?\n+/g);
            // starting in Node 7, the stack builder caches the message.
            // just replace it.
            if (!overwrittenStack) {
                stack[0] = this.name + ': ' + this.message;
            }
            var lineCount = 1;
            for(var key in properties){
                if (!properties.hasOwnProperty(key)) {
                    continue;
                }
                var modifier = properties[key];
                if ('line' in modifier) {
                    var line = modifier.line(this[key]);
                    if (line) {
                        stack.splice(lineCount++, 0, '    ' + line);
                    }
                }
                if ('stack' in modifier) {
                    modifier.stack(this[key], stack);
                }
            }
            return stack.join('\n');
        };
        Object.defineProperty(this, 'stack', stackDescriptor);
    };
    if (Object.setPrototypeOf) {
        Object.setPrototypeOf(errorExError.prototype, Error.prototype);
        Object.setPrototypeOf(errorExError, Error);
    } else {
        util.inherits(errorExError, Error);
    }
    return errorExError;
};
errorEx.append = function(str, def) {
    return {
        message: function(v, message) {
            v = v || def;
            if (v) {
                message[0] += ' ' + str.replace('%s', v.toString());
            }
            return message;
        }
    };
};
errorEx.line = function(str, def) {
    return {
        line: function(v) {
            v = v || def;
            if (v) {
                return str.replace('%s', v.toString());
            }
            return null;
        }
    };
};
module.exports = errorEx;
}}),
"[project]/node_modules/json-parse-even-better-errors/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const hexify = (char)=>{
    const h = char.charCodeAt(0).toString(16).toUpperCase();
    return '0x' + (h.length % 2 ? '0' : '') + h;
};
const parseError = (e, txt, context)=>{
    if (!txt) {
        return {
            message: e.message + ' while parsing empty string',
            position: 0
        };
    }
    const badToken = e.message.match(/^Unexpected token (.) .*position\s+(\d+)/i);
    const errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;
    const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${hexify(badToken[1])})`) : e.message;
    if (errIdx !== null && errIdx !== undefined) {
        const start = errIdx <= context ? 0 : errIdx - context;
        const end = errIdx + context >= txt.length ? txt.length : errIdx + context;
        const slice = (start === 0 ? '' : '...') + txt.slice(start, end) + (end === txt.length ? '' : '...');
        const near = txt === slice ? '' : 'near ';
        return {
            message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,
            position: errIdx
        };
    } else {
        return {
            message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,
            position: 0
        };
    }
};
class JSONParseError extends SyntaxError {
    constructor(er, txt, context, caller){
        context = context || 20;
        const metadata = parseError(er, txt, context);
        super(metadata.message);
        Object.assign(this, metadata);
        this.code = 'EJSONPARSE';
        this.systemError = er;
        Error.captureStackTrace(this, caller || this.constructor);
    }
    get name() {
        return this.constructor.name;
    }
    set name(n) {}
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
}
const kIndent = Symbol.for('indent');
const kNewline = Symbol.for('newline');
// only respect indentation if we got a line break, otherwise squash it
// things other than objects and arrays aren't indented, so ignore those
// Important: in both of these regexps, the $1 capture group is the newline
// or undefined, and the $2 capture group is the indent, or undefined.
const formatRE = /^\s*[{\[]((?:\r?\n)+)([\s\t]*)/;
const emptyRE = /^(?:\{\}|\[\])((?:\r?\n)+)?$/;
const parseJson = (txt, reviver, context)=>{
    const parseText = stripBOM(txt);
    context = context || 20;
    try {
        // get the indentation so that we can save it back nicely
        // if the file starts with {" then we have an indent of '', ie, none
        // otherwise, pick the indentation of the next line after the first \n
        // If the pattern doesn't match, then it means no indentation.
        // JSON.stringify ignores symbols, so this is reasonably safe.
        // if the string is '{}' or '[]', then use the default 2-space indent.
        const [, newline = '\n', indent = '  '] = parseText.match(emptyRE) || parseText.match(formatRE) || [
            ,
            '',
            ''
        ];
        const result = JSON.parse(parseText, reviver);
        if (result && typeof result === 'object') {
            result[kNewline] = newline;
            result[kIndent] = indent;
        }
        return result;
    } catch (e) {
        if (typeof txt !== 'string' && !Buffer.isBuffer(txt)) {
            const isEmptyArray = Array.isArray(txt) && txt.length === 0;
            throw Object.assign(new TypeError(`Cannot parse ${isEmptyArray ? 'an empty array' : String(txt)}`), {
                code: 'EJSONPARSE',
                systemError: e
            });
        }
        throw new JSONParseError(e, parseText, context, parseJson);
    }
};
// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
// because the buffer-to-string conversion in `fs.readFileSync()`
// translates it to FEFF, the UTF-16 BOM.
const stripBOM = (txt)=>String(txt).replace(/^\uFEFF/, '');
module.exports = parseJson;
parseJson.JSONParseError = JSONParseError;
parseJson.noExceptions = (txt, reviver)=>{
    try {
        return JSON.parse(stripBOM(txt), reviver);
    } catch (e) {}
};
}}),
"[project]/node_modules/lines-and-columns/build/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.LinesAndColumns = void 0;
var LF = '\n';
var CR = '\r';
var LinesAndColumns = function() {
    function LinesAndColumns(string) {
        this.string = string;
        var offsets = [
            0
        ];
        for(var offset = 0; offset < string.length;){
            switch(string[offset]){
                case LF:
                    offset += LF.length;
                    offsets.push(offset);
                    break;
                case CR:
                    offset += CR.length;
                    if (string[offset] === LF) {
                        offset += LF.length;
                    }
                    offsets.push(offset);
                    break;
                default:
                    offset++;
                    break;
            }
        }
        this.offsets = offsets;
    }
    LinesAndColumns.prototype.locationForIndex = function(index) {
        if (index < 0 || index > this.string.length) {
            return null;
        }
        var line = 0;
        var offsets = this.offsets;
        while(offsets[line + 1] <= index){
            line++;
        }
        var column = index - offsets[line];
        return {
            line: line,
            column: column
        };
    };
    LinesAndColumns.prototype.indexForLocation = function(location) {
        var line = location.line, column = location.column;
        if (line < 0 || line >= this.offsets.length) {
            return null;
        }
        if (column < 0 || column > this.lengthOfLine(line)) {
            return null;
        }
        return this.offsets[line] + column;
    };
    LinesAndColumns.prototype.lengthOfLine = function(line) {
        var offset = this.offsets[line];
        var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
        return nextOffset - offset;
    };
    return LinesAndColumns;
}();
exports.LinesAndColumns = LinesAndColumns;
exports["default"] = LinesAndColumns;
}}),
"[project]/node_modules/picocolors/picocolors.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
let p = process || {}, argv = p.argv || [], env = p.env || {};
let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
let formatter = (open, close, replace = open)=>(input)=>{
        let string = "" + input, index = string.indexOf(close, open.length);
        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
let replaceClose = (string, close, replace, index)=>{
    let result = "", cursor = 0;
    do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
    }while (~index)
    return result + string.substring(cursor);
};
let createColors = (enabled = isColorSupported)=>{
    let f = enabled ? formatter : ()=>String;
    return {
        isColorSupported: enabled,
        reset: f("\x1b[0m", "\x1b[0m"),
        bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
        dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
        italic: f("\x1b[3m", "\x1b[23m"),
        underline: f("\x1b[4m", "\x1b[24m"),
        inverse: f("\x1b[7m", "\x1b[27m"),
        hidden: f("\x1b[8m", "\x1b[28m"),
        strikethrough: f("\x1b[9m", "\x1b[29m"),
        black: f("\x1b[30m", "\x1b[39m"),
        red: f("\x1b[31m", "\x1b[39m"),
        green: f("\x1b[32m", "\x1b[39m"),
        yellow: f("\x1b[33m", "\x1b[39m"),
        blue: f("\x1b[34m", "\x1b[39m"),
        magenta: f("\x1b[35m", "\x1b[39m"),
        cyan: f("\x1b[36m", "\x1b[39m"),
        white: f("\x1b[37m", "\x1b[39m"),
        gray: f("\x1b[90m", "\x1b[39m"),
        bgBlack: f("\x1b[40m", "\x1b[49m"),
        bgRed: f("\x1b[41m", "\x1b[49m"),
        bgGreen: f("\x1b[42m", "\x1b[49m"),
        bgYellow: f("\x1b[43m", "\x1b[49m"),
        bgBlue: f("\x1b[44m", "\x1b[49m"),
        bgMagenta: f("\x1b[45m", "\x1b[49m"),
        bgCyan: f("\x1b[46m", "\x1b[49m"),
        bgWhite: f("\x1b[47m", "\x1b[49m"),
        blackBright: f("\x1b[90m", "\x1b[39m"),
        redBright: f("\x1b[91m", "\x1b[39m"),
        greenBright: f("\x1b[92m", "\x1b[39m"),
        yellowBright: f("\x1b[93m", "\x1b[39m"),
        blueBright: f("\x1b[94m", "\x1b[39m"),
        magentaBright: f("\x1b[95m", "\x1b[39m"),
        cyanBright: f("\x1b[96m", "\x1b[39m"),
        whiteBright: f("\x1b[97m", "\x1b[39m"),
        bgBlackBright: f("\x1b[100m", "\x1b[49m"),
        bgRedBright: f("\x1b[101m", "\x1b[49m"),
        bgGreenBright: f("\x1b[102m", "\x1b[49m"),
        bgYellowBright: f("\x1b[103m", "\x1b[49m"),
        bgBlueBright: f("\x1b[104m", "\x1b[49m"),
        bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
        bgCyanBright: f("\x1b[106m", "\x1b[49m"),
        bgWhiteBright: f("\x1b[107m", "\x1b[49m")
    };
};
module.exports = createColors();
module.exports.createColors = createColors;
}}),
"[project]/node_modules/js-tokens/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell
// License: MIT. (See LICENSE.)
Object.defineProperty(exports, "__esModule", {
    value: true
});
// This regex comes from regex.coffee, and is inserted here by generate-index.js
// (run `npm run build`).
exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
exports.matchToToken = function(match) {
    var token = {
        type: "invalid",
        value: match[0],
        closed: undefined
    };
    if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);
    else if (match[5]) token.type = "comment";
    else if (match[6]) token.type = "comment", token.closed = !!match[7];
    else if (match[8]) token.type = "regex";
    else if (match[9]) token.type = "number";
    else if (match[10]) token.type = "name";
    else if (match[11]) token.type = "punctuator";
    else if (match[12]) token.type = "whitespace";
    return token;
};
}}),
"[project]/node_modules/@babel/helper-validator-identifier/lib/identifier.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierName = isIdentifierName;
exports.isIdentifierStart = isIdentifierStart;
let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
let nonASCIIidentifierChars = "\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    4,
    51,
    13,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    39,
    27,
    10,
    22,
    251,
    41,
    7,
    1,
    17,
    2,
    60,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    20,
    1,
    64,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    31,
    9,
    2,
    0,
    3,
    0,
    2,
    37,
    2,
    0,
    26,
    0,
    2,
    0,
    45,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    200,
    32,
    32,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    16,
    0,
    2,
    12,
    2,
    33,
    125,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1071,
    18,
    5,
    26,
    3994,
    6,
    582,
    6842,
    29,
    1763,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    433,
    44,
    212,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    42,
    9,
    8936,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    16,
    0,
    30,
    2,
    3,
    0,
    15,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    7,
    5,
    262,
    61,
    147,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    485,
    27,
    229,
    29,
    3,
    0,
    496,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4153,
    7,
    221,
    3,
    5761,
    15,
    7472,
    16,
    621,
    2467,
    541,
    1507,
    4938,
    6,
    4191
];
const astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    7,
    9,
    32,
    4,
    318,
    1,
    80,
    3,
    71,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    3,
    0,
    158,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    68,
    8,
    2,
    0,
    3,
    0,
    2,
    3,
    2,
    4,
    2,
    0,
    15,
    1,
    83,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    7,
    19,
    58,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    343,
    9,
    54,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    10,
    1,
    2,
    0,
    49,
    6,
    4,
    4,
    14,
    10,
    5350,
    0,
    7,
    14,
    11465,
    27,
    2343,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    535,
    9,
    470,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4178,
    9,
    519,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    101,
    0,
    161,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    499,
    13,
    245,
    1,
    2,
    9,
    726,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239
];
function isInAstralSet(code, set) {
    let pos = 0x10000;
    for(let i = 0, length = set.length; i < length; i += 2){
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
    }
    return false;
}
function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 0xffff) {
        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 0xffff) {
        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
function isIdentifierName(name) {
    let isFirst = true;
    for(let i = 0; i < name.length; i++){
        let cp = name.charCodeAt(i);
        if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
            const trail = name.charCodeAt(++i);
            if ((trail & 0xfc00) === 0xdc00) {
                cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
            }
        }
        if (isFirst) {
            isFirst = false;
            if (!isIdentifierStart(cp)) {
                return false;
            }
        } else if (!isIdentifierChar(cp)) {
            return false;
        }
    }
    return !isFirst;
} //# sourceMappingURL=identifier.js.map
}}),
"[project]/node_modules/@babel/helper-validator-identifier/lib/keyword.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isKeyword = isKeyword;
exports.isReservedWord = isReservedWord;
exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
exports.isStrictBindReservedWord = isStrictBindReservedWord;
exports.isStrictReservedWord = isStrictReservedWord;
const reservedWords = {
    keyword: [
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ],
    strict: [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ],
    strictBind: [
        "eval",
        "arguments"
    ]
};
const keywords = new Set(reservedWords.keyword);
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
}
function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}
function isKeyword(word) {
    return keywords.has(word);
} //# sourceMappingURL=keyword.js.map
}}),
"[project]/node_modules/@babel/helper-validator-identifier/lib/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierChar;
    }
});
Object.defineProperty(exports, "isIdentifierName", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierName;
    }
});
Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierStart;
    }
});
Object.defineProperty(exports, "isKeyword", {
    enumerable: true,
    get: function() {
        return _keyword.isKeyword;
    }
});
Object.defineProperty(exports, "isReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isReservedWord;
    }
});
Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
    }
});
Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictBindReservedWord;
    }
});
Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictReservedWord;
    }
});
var _identifier = __turbopack_context__.r("[project]/node_modules/@babel/helper-validator-identifier/lib/identifier.js [app-route] (ecmascript)");
var _keyword = __turbopack_context__.r("[project]/node_modules/@babel/helper-validator-identifier/lib/keyword.js [app-route] (ecmascript)"); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/code-frame/lib/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var picocolors = __turbopack_context__.r("[project]/node_modules/picocolors/picocolors.js [app-route] (ecmascript)");
var jsTokens = __turbopack_context__.r("[project]/node_modules/js-tokens/index.js [app-route] (ecmascript)");
var helperValidatorIdentifier = __turbopack_context__.r("[project]/node_modules/@babel/helper-validator-identifier/lib/index.js [app-route] (ecmascript)");
function isColorSupported() {
    return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
}
const compose = (f, g)=>(v)=>f(g(v));
function buildDefs(colors) {
    return {
        keyword: colors.cyan,
        capitalized: colors.yellow,
        jsxIdentifier: colors.yellow,
        punctuator: colors.yellow,
        number: colors.magenta,
        string: colors.green,
        regex: colors.magenta,
        comment: colors.gray,
        invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
        gutter: colors.gray,
        marker: compose(colors.red, colors.bold),
        message: compose(colors.red, colors.bold),
        reset: colors.reset
    };
}
const defsOn = buildDefs(picocolors.createColors(true));
const defsOff = buildDefs(picocolors.createColors(false));
function getDefs(enabled) {
    return enabled ? defsOn : defsOff;
}
const sometimesKeywords = new Set([
    "as",
    "async",
    "from",
    "get",
    "of",
    "set"
]);
const NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
const BRACKET = /^[()[\]{}]$/;
let tokenize;
{
    const JSX_TAG = /^[a-z][\w-]*$/i;
    const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
            if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
                return "keyword";
            }
            if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
                return "jsxIdentifier";
            }
            if (token.value[0] !== token.value[0].toLowerCase()) {
                return "capitalized";
            }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
            return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
            return "punctuator";
        }
        return token.type;
    };
    tokenize = function*(text) {
        let match;
        while(match = jsTokens.default.exec(text)){
            const token = jsTokens.matchToToken(match);
            yield {
                type: getTokenType(token, match.index, text),
                value: token.value
            };
        }
    };
}function highlight(text) {
    if (text === "") return "";
    const defs = getDefs(true);
    let highlighted = "";
    for (const { type, value } of tokenize(text)){
        if (type in defs) {
            highlighted += value.split(NEWLINE$1).map((str)=>defs[type](str)).join("\n");
        } else {
            highlighted += value;
        }
    }
    return highlighted;
}
let deprecationWarningShown = false;
const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
function getMarkerLines(loc, source, opts) {
    const startLoc = Object.assign({
        column: 0,
        line: -1
    }, loc.start);
    const endLoc = Object.assign({}, startLoc, loc.end);
    const { linesAbove = 2, linesBelow = 3 } = opts || {};
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);
    if (startLine === -1) {
        start = 0;
    }
    if (endLine === -1) {
        end = source.length;
    }
    const lineDiff = endLine - startLine;
    const markerLines = {};
    if (lineDiff) {
        for(let i = 0; i <= lineDiff; i++){
            const lineNumber = i + startLine;
            if (!startColumn) {
                markerLines[lineNumber] = true;
            } else if (i === 0) {
                const sourceLength = source[lineNumber - 1].length;
                markerLines[lineNumber] = [
                    startColumn,
                    sourceLength - startColumn + 1
                ];
            } else if (i === lineDiff) {
                markerLines[lineNumber] = [
                    0,
                    endColumn
                ];
            } else {
                const sourceLength = source[lineNumber - i].length;
                markerLines[lineNumber] = [
                    0,
                    sourceLength
                ];
            }
        }
    } else {
        if (startColumn === endColumn) {
            if (startColumn) {
                markerLines[startLine] = [
                    startColumn,
                    0
                ];
            } else {
                markerLines[startLine] = true;
            }
        } else {
            markerLines[startLine] = [
                startColumn,
                endColumn - startColumn
            ];
        }
    }
    return {
        start,
        end,
        markerLines
    };
}
function codeFrameColumns(rawLines, loc, opts = {}) {
    const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
    const defs = getDefs(shouldHighlight);
    const lines = rawLines.split(NEWLINE);
    const { start, end, markerLines } = getMarkerLines(loc, lines, opts);
    const hasColumns = loc.start && typeof loc.start.column === "number";
    const numberMaxWidth = String(end).length;
    const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
    let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index)=>{
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
            let markerLine = "";
            if (Array.isArray(hasMarker)) {
                const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
                const numberOfMarkers = hasMarker[1] || 1;
                markerLine = [
                    "\n ",
                    defs.gutter(gutter.replace(/\d/g, " ")),
                    " ",
                    markerSpacing,
                    defs.marker("^").repeat(numberOfMarkers)
                ].join("");
                if (lastMarkerLine && opts.message) {
                    markerLine += " " + defs.message(opts.message);
                }
            }
            return [
                defs.marker(">"),
                defs.gutter(gutter),
                line.length > 0 ? ` ${line}` : "",
                markerLine
            ].join("");
        } else {
            return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
    }).join("\n");
    if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`;
    }
    if (shouldHighlight) {
        return defs.reset(frame);
    } else {
        return frame;
    }
}
function index(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
            process.emitWarning(message, "DeprecationWarning");
        } else {
            const deprecationError = new Error(message);
            deprecationError.name = "DeprecationWarning";
            console.warn(new Error(message));
        }
    }
    colNumber = Math.max(colNumber, 0);
    const location = {
        start: {
            column: colNumber,
            line: lineNumber
        }
    };
    return codeFrameColumns(rawLines, location, opts);
}
exports.codeFrameColumns = codeFrameColumns;
exports.default = index;
exports.highlight = highlight; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/parse-json/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const errorEx = __turbopack_context__.r("[project]/node_modules/error-ex/index.js [app-route] (ecmascript)");
const fallback = __turbopack_context__.r("[project]/node_modules/json-parse-even-better-errors/index.js [app-route] (ecmascript)");
const { default: LinesAndColumns } = __turbopack_context__.r("[project]/node_modules/lines-and-columns/build/index.js [app-route] (ecmascript)");
const { codeFrameColumns } = __turbopack_context__.r("[project]/node_modules/@babel/code-frame/lib/index.js [app-route] (ecmascript)");
const JSONError = errorEx('JSONError', {
    fileName: errorEx.append('in %s'),
    codeFrame: errorEx.append('\n\n%s\n')
});
const parseJson = (string, reviver, filename)=>{
    if (typeof reviver === 'string') {
        filename = reviver;
        reviver = null;
    }
    try {
        try {
            return JSON.parse(string, reviver);
        } catch (error) {
            fallback(string, reviver);
            throw error;
        }
    } catch (error) {
        error.message = error.message.replace(/\n/g, '');
        const indexMatch = error.message.match(/in JSON at position (\d+) while parsing/);
        const jsonError = new JSONError(error);
        if (filename) {
            jsonError.fileName = filename;
        }
        if (indexMatch && indexMatch.length > 0) {
            const lines = new LinesAndColumns(string);
            const index = Number(indexMatch[1]);
            const location = lines.locationForIndex(index);
            const codeFrame = codeFrameColumns(string, {
                start: {
                    line: location.line + 1,
                    column: location.column + 1
                }
            }, {
                highlightCode: true
            });
            jsonError.codeFrame = codeFrame;
        }
        throw jsonError;
    }
};
parseJson.JSONError = JSONError;
module.exports = parseJson;
}}),
"[project]/node_modules/cosmiconfig/dist/loaders.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* eslint-disable @typescript-eslint/no-require-imports */ var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadTs = exports.loadTsSync = exports.loadYaml = exports.loadJson = exports.loadJs = exports.loadJsSync = void 0;
const fs_1 = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const promises_1 = __turbopack_context__.r("[externals]/fs/promises [external] (fs/promises, cjs)");
const path_1 = __importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const url_1 = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
let importFresh;
const loadJsSync = function loadJsSync(filepath) {
    if (importFresh === undefined) {
        importFresh = __turbopack_context__.r("[project]/node_modules/import-fresh/index.js [app-route] (ecmascript)");
    }
    return importFresh(filepath);
};
exports.loadJsSync = loadJsSync;
const loadJs = async function loadJs(filepath) {
    try {
        const { href } = (0, url_1.pathToFileURL)(filepath);
        return (await Promise.resolve().then(()=>{
            const e = new Error("Cannot find module as expression is too dynamic");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })).default;
    } catch (error) {
        try {
            return (0, exports.loadJsSync)(filepath, '');
        } catch (requireError) {
            if (requireError.code === 'ERR_REQUIRE_ESM' || requireError instanceof SyntaxError && requireError.toString().includes('Cannot use import statement outside a module')) {
                throw error;
            }
            throw requireError;
        }
    }
};
exports.loadJs = loadJs;
let parseJson;
const loadJson = function loadJson(filepath, content) {
    if (parseJson === undefined) {
        parseJson = __turbopack_context__.r("[project]/node_modules/parse-json/index.js [app-route] (ecmascript)");
    }
    try {
        return parseJson(content);
    } catch (error) {
        error.message = `JSON Error in ${filepath}:\n${error.message}`;
        throw error;
    }
};
exports.loadJson = loadJson;
let yaml;
const loadYaml = function loadYaml(filepath, content) {
    if (yaml === undefined) {
        yaml = __turbopack_context__.r("[project]/node_modules/js-yaml/index.js [app-route] (ecmascript)");
    }
    try {
        return yaml.load(content);
    } catch (error) {
        error.message = `YAML Error in ${filepath}:\n${error.message}`;
        throw error;
    }
};
exports.loadYaml = loadYaml;
let typescript;
const loadTsSync = function loadTsSync(filepath, content) {
    /* istanbul ignore next -- @preserve */ if (typescript === undefined) {
        typescript = __turbopack_context__.r("[externals]/typescript [external] (typescript, cjs)");
    }
    const compiledFilepath = `${filepath.slice(0, -2)}cjs`;
    try {
        const config = resolveTsConfig(path_1.default.dirname(filepath)) ?? {};
        config.compilerOptions = {
            ...config.compilerOptions,
            module: typescript.ModuleKind.NodeNext,
            moduleResolution: typescript.ModuleResolutionKind.NodeNext,
            target: typescript.ScriptTarget.ES2022,
            noEmit: false
        };
        content = typescript.transpileModule(content, config).outputText;
        (0, fs_1.writeFileSync)(compiledFilepath, content);
        return (0, exports.loadJsSync)(compiledFilepath, content).default;
    } catch (error) {
        error.message = `TypeScript Error in ${filepath}:\n${error.message}`;
        throw error;
    } finally{
        if ((0, fs_1.existsSync)(compiledFilepath)) {
            (0, fs_1.rmSync)(compiledFilepath);
        }
    }
};
exports.loadTsSync = loadTsSync;
const loadTs = async function loadTs(filepath, content) {
    if (typescript === undefined) {
        typescript = (await __turbopack_context__.r("[externals]/typescript [external] (typescript, cjs, async loader)")(__turbopack_context__.i)).default;
    }
    const compiledFilepath = `${filepath.slice(0, -2)}mjs`;
    let transpiledContent;
    try {
        try {
            const config = resolveTsConfig(path_1.default.dirname(filepath)) ?? {};
            config.compilerOptions = {
                ...config.compilerOptions,
                module: typescript.ModuleKind.ES2022,
                moduleResolution: typescript.ModuleResolutionKind.Bundler,
                target: typescript.ScriptTarget.ES2022,
                noEmit: false
            };
            transpiledContent = typescript.transpileModule(content, config).outputText;
            await (0, promises_1.writeFile)(compiledFilepath, transpiledContent);
        } catch (error) {
            error.message = `TypeScript Error in ${filepath}:\n${error.message}`;
            throw error;
        }
        // eslint-disable-next-line @typescript-eslint/return-await
        return await (0, exports.loadJs)(compiledFilepath, transpiledContent);
    } finally{
        if ((0, fs_1.existsSync)(compiledFilepath)) {
            await (0, promises_1.rm)(compiledFilepath);
        }
    }
};
exports.loadTs = loadTs;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function resolveTsConfig(directory) {
    const filePath = typescript.findConfigFile(directory, (fileName)=>{
        return typescript.sys.fileExists(fileName);
    });
    if (filePath !== undefined) {
        const { config, error } = typescript.readConfigFile(filePath, (path)=>typescript.sys.readFile(path));
        if (error) {
            throw new Error(`Error in ${filePath}: ${error.messageText.toString()}`);
        }
        return config;
    }
    return;
} //# sourceMappingURL=loaders.js.map
}}),
"[project]/node_modules/cosmiconfig/dist/defaults.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultLoadersSync = exports.defaultLoaders = exports.metaSearchPlaces = exports.globalConfigSearchPlacesSync = exports.globalConfigSearchPlaces = exports.getDefaultSearchPlacesSync = exports.getDefaultSearchPlaces = void 0;
const loaders_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/loaders.js [app-route] (ecmascript)");
function getDefaultSearchPlaces(moduleName) {
    return [
        'package.json',
        `.${moduleName}rc`,
        `.${moduleName}rc.json`,
        `.${moduleName}rc.yaml`,
        `.${moduleName}rc.yml`,
        `.${moduleName}rc.js`,
        `.${moduleName}rc.ts`,
        `.${moduleName}rc.cjs`,
        `.${moduleName}rc.mjs`,
        `.config/${moduleName}rc`,
        `.config/${moduleName}rc.json`,
        `.config/${moduleName}rc.yaml`,
        `.config/${moduleName}rc.yml`,
        `.config/${moduleName}rc.js`,
        `.config/${moduleName}rc.ts`,
        `.config/${moduleName}rc.cjs`,
        `.config/${moduleName}rc.mjs`,
        `${moduleName}.config.js`,
        `${moduleName}.config.ts`,
        `${moduleName}.config.cjs`,
        `${moduleName}.config.mjs`
    ];
}
exports.getDefaultSearchPlaces = getDefaultSearchPlaces;
function getDefaultSearchPlacesSync(moduleName) {
    return [
        'package.json',
        `.${moduleName}rc`,
        `.${moduleName}rc.json`,
        `.${moduleName}rc.yaml`,
        `.${moduleName}rc.yml`,
        `.${moduleName}rc.js`,
        `.${moduleName}rc.ts`,
        `.${moduleName}rc.cjs`,
        `.config/${moduleName}rc`,
        `.config/${moduleName}rc.json`,
        `.config/${moduleName}rc.yaml`,
        `.config/${moduleName}rc.yml`,
        `.config/${moduleName}rc.js`,
        `.config/${moduleName}rc.ts`,
        `.config/${moduleName}rc.cjs`,
        `${moduleName}.config.js`,
        `${moduleName}.config.ts`,
        `${moduleName}.config.cjs`
    ];
}
exports.getDefaultSearchPlacesSync = getDefaultSearchPlacesSync;
exports.globalConfigSearchPlaces = [
    'config',
    'config.json',
    'config.yaml',
    'config.yml',
    'config.js',
    'config.ts',
    'config.cjs',
    'config.mjs'
];
exports.globalConfigSearchPlacesSync = [
    'config',
    'config.json',
    'config.yaml',
    'config.yml',
    'config.js',
    'config.ts',
    'config.cjs'
];
// this needs to be hardcoded, as this is intended for end users, who can't supply options at this point
exports.metaSearchPlaces = [
    'package.json',
    'package.yaml',
    '.config/config.json',
    '.config/config.yaml',
    '.config/config.yml',
    '.config/config.js',
    '.config/config.ts',
    '.config/config.cjs',
    '.config/config.mjs'
];
// do not allow mutation of default loaders. Make sure it is set inside options
exports.defaultLoaders = Object.freeze({
    '.mjs': loaders_1.loadJs,
    '.cjs': loaders_1.loadJs,
    '.js': loaders_1.loadJs,
    '.ts': loaders_1.loadTs,
    '.json': loaders_1.loadJson,
    '.yaml': loaders_1.loadYaml,
    '.yml': loaders_1.loadYaml,
    noExt: loaders_1.loadYaml
});
exports.defaultLoadersSync = Object.freeze({
    '.cjs': loaders_1.loadJsSync,
    '.js': loaders_1.loadJsSync,
    '.ts': loaders_1.loadTsSync,
    '.json': loaders_1.loadJson,
    '.yaml': loaders_1.loadYaml,
    '.yml': loaders_1.loadYaml,
    noExt: loaders_1.loadYaml
}); //# sourceMappingURL=defaults.js.map
}}),
"[project]/node_modules/cosmiconfig/dist/util.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isDirectorySync = exports.isDirectory = exports.removeUndefinedValuesFromObject = exports.getPropertyByPath = exports.emplace = void 0;
const fs_1 = __importStar(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"));
/**
 * @internal
 */ function emplace(map, key, fn) {
    const cached = map.get(key);
    if (cached !== undefined) {
        return cached;
    }
    const result = fn();
    map.set(key, result);
    return result;
}
exports.emplace = emplace;
// Resolves property names or property paths defined with period-delimited
// strings or arrays of strings. Property names that are found on the source
// object are used directly (even if they include a period).
// Nested property names that include periods, within a path, are only
// understood in array paths.
/**
 * @internal
 */ function getPropertyByPath(source, path) {
    if (typeof path === 'string' && Object.prototype.hasOwnProperty.call(source, path)) {
        return source[path];
    }
    const parsedPath = typeof path === 'string' ? path.split('.') : path;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return parsedPath.reduce((previous, key)=>{
        if (previous === undefined) {
            return previous;
        }
        return previous[key];
    }, source);
}
exports.getPropertyByPath = getPropertyByPath;
/** @internal */ function removeUndefinedValuesFromObject(options) {
    return Object.fromEntries(Object.entries(options).filter(([, value])=>value !== undefined));
}
exports.removeUndefinedValuesFromObject = removeUndefinedValuesFromObject;
/** @internal */ /* istanbul ignore next -- @preserve */ async function isDirectory(path) {
    try {
        const stat = await fs_1.promises.stat(path);
        return stat.isDirectory();
    } catch (e) {
        if (e.code === 'ENOENT') {
            return false;
        }
        throw e;
    }
}
exports.isDirectory = isDirectory;
/** @internal */ /* istanbul ignore next -- @preserve */ function isDirectorySync(path) {
    try {
        const stat = fs_1.default.statSync(path);
        return stat.isDirectory();
    } catch (e) {
        if (e.code === 'ENOENT') {
            return false;
        }
        throw e;
    }
}
exports.isDirectorySync = isDirectorySync; //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/cosmiconfig/dist/ExplorerBase.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getExtensionDescription = exports.ExplorerBase = void 0;
const env_paths_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/env-paths/index.js [app-route] (ecmascript)"));
const os_1 = __importDefault(__turbopack_context__.r("[externals]/os [external] (os, cjs)"));
const path_1 = __importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const util_js_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/util.js [app-route] (ecmascript)");
/**
 * @internal
 */ class ExplorerBase {
    #loadingMetaConfig = false;
    config;
    loadCache;
    searchCache;
    constructor(options){
        this.config = options;
        if (options.cache) {
            this.loadCache = new Map();
            this.searchCache = new Map();
        }
        this.#validateConfig();
    }
    set loadingMetaConfig(value) {
        this.#loadingMetaConfig = value;
    }
    #validateConfig() {
        const config = this.config;
        for (const place of config.searchPlaces){
            const extension = path_1.default.extname(place);
            const loader = this.config.loaders[extension || 'noExt'] ?? this.config.loaders['default'];
            if (loader === undefined) {
                throw new Error(`Missing loader for ${getExtensionDescription(place)}.`);
            }
            if (typeof loader !== 'function') {
                throw new Error(`Loader for ${getExtensionDescription(place)} is not a function: Received ${typeof loader}.`);
            }
        }
    }
    clearLoadCache() {
        if (this.loadCache) {
            this.loadCache.clear();
        }
    }
    clearSearchCache() {
        if (this.searchCache) {
            this.searchCache.clear();
        }
    }
    clearCaches() {
        this.clearLoadCache();
        this.clearSearchCache();
    }
    toCosmiconfigResult(filepath, config) {
        if (config === null) {
            return null;
        }
        if (config === undefined) {
            return {
                filepath,
                config: undefined,
                isEmpty: true
            };
        }
        if (this.config.applyPackagePropertyPathToConfiguration || this.#loadingMetaConfig) {
            const packageProp = this.config.packageProp ?? this.config.moduleName;
            config = (0, util_js_1.getPropertyByPath)(config, packageProp);
        }
        if (config === undefined) {
            return {
                filepath,
                config: undefined,
                isEmpty: true
            };
        }
        return {
            config,
            filepath
        };
    }
    validateImports(containingFilePath, imports, importStack) {
        const fileDirectory = path_1.default.dirname(containingFilePath);
        for (const importPath of imports){
            if (typeof importPath !== 'string') {
                throw new Error(`${containingFilePath}: Key $import must contain a string or a list of strings`);
            }
            const fullPath = path_1.default.resolve(fileDirectory, importPath);
            if (fullPath === containingFilePath) {
                throw new Error(`Self-import detected in ${containingFilePath}`);
            }
            const idx = importStack.indexOf(fullPath);
            if (idx !== -1) {
                throw new Error(`Circular import detected:
${[
                    ...importStack,
                    fullPath
                ].map((path, i)=>`${i + 1}. ${path}`).join('\n')} (same as ${idx + 1}.)`);
            }
        }
    }
    getSearchPlacesForDir(dir, globalConfigPlaces) {
        return (dir.isGlobalConfig ? globalConfigPlaces : this.config.searchPlaces).map((place)=>path_1.default.join(dir.path, place));
    }
    getGlobalConfigDir() {
        return (0, env_paths_1.default)(this.config.moduleName, {
            suffix: ''
        }).config;
    }
    *getGlobalDirs(startDir) {
        const stopDir = path_1.default.resolve(this.config.stopDir ?? os_1.default.homedir());
        yield {
            path: startDir,
            isGlobalConfig: false
        };
        let currentDir = startDir;
        while(currentDir !== stopDir){
            const parentDir = path_1.default.dirname(currentDir);
            /* istanbul ignore if -- @preserve */ if (parentDir === currentDir) {
                break;
            }
            yield {
                path: parentDir,
                isGlobalConfig: false
            };
            currentDir = parentDir;
        }
        yield {
            path: this.getGlobalConfigDir(),
            isGlobalConfig: true
        };
    }
}
exports.ExplorerBase = ExplorerBase;
/**
 * @internal
 */ function getExtensionDescription(extension) {
    /* istanbul ignore next -- @preserve */ return extension ? `extension "${extension}"` : 'files without extensions';
}
exports.getExtensionDescription = getExtensionDescription; //# sourceMappingURL=ExplorerBase.js.map
}}),
"[project]/node_modules/cosmiconfig/dist/merge.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeAll = exports.hasOwn = void 0;
/* eslint-disable @typescript-eslint/unbound-method */ exports.hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
const objToString = Function.prototype.call.bind(Object.prototype.toString);
/* eslint-enable @typescript-eslint/unbound-method */ function isPlainObject(obj) {
    return objToString(obj) === '[object Object]';
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function merge(target, source, options) {
    for (const key of Object.keys(source)){
        const newValue = source[key];
        if ((0, exports.hasOwn)(target, key)) {
            if (Array.isArray(target[key]) && Array.isArray(newValue)) {
                if (options.mergeArrays) {
                    target[key].push(...newValue);
                    continue;
                }
            } else if (isPlainObject(target[key]) && isPlainObject(newValue)) {
                target[key] = merge(target[key], newValue, options);
                continue;
            }
        }
        target[key] = newValue;
    }
    return target;
}
/**
 * Merges multiple objects. Doesn't care about cloning non-primitives, as we load all these objects fresh from a file.
 */ function mergeAll(// eslint-disable-next-line @typescript-eslint/no-explicit-any
objects, options) {
    return objects.reduce((target, source)=>merge(target, source, options), {});
}
exports.mergeAll = mergeAll; //# sourceMappingURL=merge.js.map
}}),
"[project]/node_modules/cosmiconfig/dist/Explorer.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Explorer = void 0;
const promises_1 = __importDefault(__turbopack_context__.r("[externals]/fs/promises [external] (fs/promises, cjs)"));
const path_1 = __importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const defaults_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/defaults.js [app-route] (ecmascript)");
const ExplorerBase_js_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/ExplorerBase.js [app-route] (ecmascript)");
const merge_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/merge.js [app-route] (ecmascript)");
const util_js_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/util.js [app-route] (ecmascript)");
/**
 * @internal
 */ class Explorer extends ExplorerBase_js_1.ExplorerBase {
    async load(filepath) {
        filepath = path_1.default.resolve(filepath);
        const load = async ()=>{
            return await this.config.transform(await this.#readConfiguration(filepath));
        };
        if (this.loadCache) {
            return await (0, util_js_1.emplace)(this.loadCache, filepath, load);
        }
        return await load();
    }
    async search(from = '') {
        if (this.config.metaConfigFilePath) {
            this.loadingMetaConfig = true;
            const config = await this.load(this.config.metaConfigFilePath);
            this.loadingMetaConfig = false;
            if (config && !config.isEmpty) {
                return config;
            }
        }
        from = path_1.default.resolve(from);
        const dirs = this.#getDirs(from);
        const firstDirIter = await dirs.next();
        /* istanbul ignore if -- @preserve */ if (firstDirIter.done) {
            // this should never happen
            throw new Error(`Could not find any folders to iterate through (start from ${from})`);
        }
        let currentDir = firstDirIter.value;
        const search = async ()=>{
            /* istanbul ignore if -- @preserve */ if (await (0, util_js_1.isDirectory)(currentDir.path)) {
                for (const filepath of this.getSearchPlacesForDir(currentDir, defaults_1.globalConfigSearchPlaces)){
                    try {
                        const result = await this.#readConfiguration(filepath);
                        if (result !== null && !(result.isEmpty && this.config.ignoreEmptySearchPlaces)) {
                            return await this.config.transform(result);
                        }
                    } catch (error) {
                        if (error.code === 'ENOENT' || error.code === 'EISDIR' || error.code === 'ENOTDIR' || error.code === 'EACCES') {
                            continue;
                        }
                        throw error;
                    }
                }
            }
            const nextDirIter = await dirs.next();
            if (!nextDirIter.done) {
                currentDir = nextDirIter.value;
                if (this.searchCache) {
                    return await (0, util_js_1.emplace)(this.searchCache, currentDir.path, search);
                }
                return await search();
            }
            return await this.config.transform(null);
        };
        if (this.searchCache) {
            return await (0, util_js_1.emplace)(this.searchCache, from, search);
        }
        return await search();
    }
    async #readConfiguration(filepath, importStack = []) {
        const contents = await promises_1.default.readFile(filepath, {
            encoding: 'utf-8'
        });
        return this.toCosmiconfigResult(filepath, await this.#loadConfigFileWithImports(filepath, contents, importStack));
    }
    async #loadConfigFileWithImports(filepath, contents, importStack) {
        const loadedContent = await this.#loadConfiguration(filepath, contents);
        if (!loadedContent || !(0, merge_1.hasOwn)(loadedContent, '$import')) {
            return loadedContent;
        }
        const fileDirectory = path_1.default.dirname(filepath);
        const { $import: imports, ...ownContent } = loadedContent;
        const importPaths = Array.isArray(imports) ? imports : [
            imports
        ];
        const newImportStack = [
            ...importStack,
            filepath
        ];
        this.validateImports(filepath, importPaths, newImportStack);
        const importedConfigs = await Promise.all(importPaths.map(async (importPath)=>{
            const fullPath = path_1.default.resolve(fileDirectory, importPath);
            const result = await this.#readConfiguration(fullPath, newImportStack);
            return result?.config;
        }));
        return (0, merge_1.mergeAll)([
            ...importedConfigs,
            ownContent
        ], {
            mergeArrays: this.config.mergeImportArrays
        });
    }
    async #loadConfiguration(filepath, contents) {
        if (contents.trim() === '') {
            return;
        }
        const extension = path_1.default.extname(filepath);
        const loader = this.config.loaders[extension || 'noExt'] ?? this.config.loaders['default'];
        if (!loader) {
            throw new Error(`No loader specified for ${(0, ExplorerBase_js_1.getExtensionDescription)(extension)}`);
        }
        try {
            const loadedContents = await loader(filepath, contents);
            if (path_1.default.basename(filepath, extension) !== 'package') {
                return loadedContents;
            }
            return (0, util_js_1.getPropertyByPath)(loadedContents, this.config.packageProp ?? this.config.moduleName) ?? null;
        } catch (error) {
            error.filepath = filepath;
            throw error;
        }
    }
    async #fileExists(path) {
        try {
            await promises_1.default.stat(path);
            return true;
        } catch (e) {
            return false;
        }
    }
    async *#getDirs(startDir) {
        switch(this.config.searchStrategy){
            case 'none':
                {
                    // only check in the passed directory (defaults to working directory)
                    yield {
                        path: startDir,
                        isGlobalConfig: false
                    };
                    return;
                }
            case 'project':
                {
                    let currentDir = startDir;
                    while(true){
                        yield {
                            path: currentDir,
                            isGlobalConfig: false
                        };
                        for (const ext of [
                            'json',
                            'yaml'
                        ]){
                            const packageFile = path_1.default.join(currentDir, `package.${ext}`);
                            if (await this.#fileExists(packageFile)) {
                                break;
                            }
                        }
                        const parentDir = path_1.default.dirname(currentDir);
                        /* istanbul ignore if -- @preserve */ if (parentDir === currentDir) {
                            break;
                        }
                        currentDir = parentDir;
                    }
                    return;
                }
            case 'global':
                {
                    yield* this.getGlobalDirs(startDir);
                }
        }
    }
}
exports.Explorer = Explorer; //# sourceMappingURL=Explorer.js.map
}}),
"[project]/node_modules/cosmiconfig/dist/ExplorerSync.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExplorerSync = void 0;
const fs_1 = __importDefault(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"));
const path_1 = __importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const defaults_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/defaults.js [app-route] (ecmascript)");
const ExplorerBase_js_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/ExplorerBase.js [app-route] (ecmascript)");
const merge_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/merge.js [app-route] (ecmascript)");
const util_js_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/util.js [app-route] (ecmascript)");
/**
 * @internal
 */ class ExplorerSync extends ExplorerBase_js_1.ExplorerBase {
    load(filepath) {
        filepath = path_1.default.resolve(filepath);
        const load = ()=>{
            return this.config.transform(this.#readConfiguration(filepath));
        };
        if (this.loadCache) {
            return (0, util_js_1.emplace)(this.loadCache, filepath, load);
        }
        return load();
    }
    search(from = '') {
        if (this.config.metaConfigFilePath) {
            this.loadingMetaConfig = true;
            const config = this.load(this.config.metaConfigFilePath);
            this.loadingMetaConfig = false;
            if (config && !config.isEmpty) {
                return config;
            }
        }
        from = path_1.default.resolve(from);
        const dirs = this.#getDirs(from);
        const firstDirIter = dirs.next();
        /* istanbul ignore if -- @preserve */ if (firstDirIter.done) {
            // this should never happen
            throw new Error(`Could not find any folders to iterate through (start from ${from})`);
        }
        let currentDir = firstDirIter.value;
        const search = ()=>{
            /* istanbul ignore if -- @preserve */ if ((0, util_js_1.isDirectorySync)(currentDir.path)) {
                for (const filepath of this.getSearchPlacesForDir(currentDir, defaults_1.globalConfigSearchPlacesSync)){
                    try {
                        const result = this.#readConfiguration(filepath);
                        if (result !== null && !(result.isEmpty && this.config.ignoreEmptySearchPlaces)) {
                            return this.config.transform(result);
                        }
                    } catch (error) {
                        if (error.code === 'ENOENT' || error.code === 'EISDIR' || error.code === 'ENOTDIR' || error.code === 'EACCES') {
                            continue;
                        }
                        throw error;
                    }
                }
            }
            const nextDirIter = dirs.next();
            if (!nextDirIter.done) {
                currentDir = nextDirIter.value;
                if (this.searchCache) {
                    return (0, util_js_1.emplace)(this.searchCache, currentDir.path, search);
                }
                return search();
            }
            return this.config.transform(null);
        };
        if (this.searchCache) {
            return (0, util_js_1.emplace)(this.searchCache, from, search);
        }
        return search();
    }
    #readConfiguration(filepath, importStack = []) {
        const contents = fs_1.default.readFileSync(filepath, 'utf8');
        return this.toCosmiconfigResult(filepath, this.#loadConfigFileWithImports(filepath, contents, importStack));
    }
    #loadConfigFileWithImports(filepath, contents, importStack) {
        const loadedContent = this.#loadConfiguration(filepath, contents);
        if (!loadedContent || !(0, merge_1.hasOwn)(loadedContent, '$import')) {
            return loadedContent;
        }
        const fileDirectory = path_1.default.dirname(filepath);
        const { $import: imports, ...ownContent } = loadedContent;
        const importPaths = Array.isArray(imports) ? imports : [
            imports
        ];
        const newImportStack = [
            ...importStack,
            filepath
        ];
        this.validateImports(filepath, importPaths, newImportStack);
        const importedConfigs = importPaths.map((importPath)=>{
            const fullPath = path_1.default.resolve(fileDirectory, importPath);
            const result = this.#readConfiguration(fullPath, newImportStack);
            return result?.config;
        });
        return (0, merge_1.mergeAll)([
            ...importedConfigs,
            ownContent
        ], {
            mergeArrays: this.config.mergeImportArrays
        });
    }
    #loadConfiguration(filepath, contents) {
        if (contents.trim() === '') {
            return;
        }
        const extension = path_1.default.extname(filepath);
        const loader = this.config.loaders[extension || 'noExt'] ?? this.config.loaders['default'];
        if (!loader) {
            throw new Error(`No loader specified for ${(0, ExplorerBase_js_1.getExtensionDescription)(extension)}`);
        }
        try {
            const loadedContents = loader(filepath, contents);
            if (path_1.default.basename(filepath, extension) !== 'package') {
                return loadedContents;
            }
            return (0, util_js_1.getPropertyByPath)(loadedContents, this.config.packageProp ?? this.config.moduleName) ?? null;
        } catch (error) {
            error.filepath = filepath;
            throw error;
        }
    }
    #fileExists(path) {
        try {
            fs_1.default.statSync(path);
            return true;
        } catch (e) {
            return false;
        }
    }
    *#getDirs(startDir) {
        switch(this.config.searchStrategy){
            case 'none':
                {
                    // there is no next dir
                    yield {
                        path: startDir,
                        isGlobalConfig: false
                    };
                    return;
                }
            case 'project':
                {
                    let currentDir = startDir;
                    while(true){
                        yield {
                            path: currentDir,
                            isGlobalConfig: false
                        };
                        for (const ext of [
                            'json',
                            'yaml'
                        ]){
                            const packageFile = path_1.default.join(currentDir, `package.${ext}`);
                            if (this.#fileExists(packageFile)) {
                                break;
                            }
                        }
                        const parentDir = path_1.default.dirname(currentDir);
                        /* istanbul ignore if -- @preserve */ if (parentDir === currentDir) {
                            break;
                        }
                        currentDir = parentDir;
                    }
                    return;
                }
            case 'global':
                {
                    yield* this.getGlobalDirs(startDir);
                }
        }
    }
    /**
     * @deprecated Use {@link ExplorerSync.prototype.load}.
     */ /* istanbul ignore next */ loadSync(filepath) {
        return this.load(filepath);
    }
    /**
     * @deprecated Use {@link ExplorerSync.prototype.search}.
     */ /* istanbul ignore next */ searchSync(from = '') {
        return this.search(from);
    }
}
exports.ExplorerSync = ExplorerSync; //# sourceMappingURL=ExplorerSync.js.map
}}),
"[project]/node_modules/cosmiconfig/dist/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultLoadersSync = exports.defaultLoaders = exports.globalConfigSearchPlacesSync = exports.globalConfigSearchPlaces = exports.getDefaultSearchPlacesSync = exports.getDefaultSearchPlaces = exports.cosmiconfigSync = exports.cosmiconfig = void 0;
const defaults_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/defaults.js [app-route] (ecmascript)");
Object.defineProperty(exports, "defaultLoaders", {
    enumerable: true,
    get: function() {
        return defaults_1.defaultLoaders;
    }
});
Object.defineProperty(exports, "defaultLoadersSync", {
    enumerable: true,
    get: function() {
        return defaults_1.defaultLoadersSync;
    }
});
Object.defineProperty(exports, "getDefaultSearchPlaces", {
    enumerable: true,
    get: function() {
        return defaults_1.getDefaultSearchPlaces;
    }
});
Object.defineProperty(exports, "getDefaultSearchPlacesSync", {
    enumerable: true,
    get: function() {
        return defaults_1.getDefaultSearchPlacesSync;
    }
});
Object.defineProperty(exports, "globalConfigSearchPlaces", {
    enumerable: true,
    get: function() {
        return defaults_1.globalConfigSearchPlaces;
    }
});
Object.defineProperty(exports, "globalConfigSearchPlacesSync", {
    enumerable: true,
    get: function() {
        return defaults_1.globalConfigSearchPlacesSync;
    }
});
const Explorer_js_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/Explorer.js [app-route] (ecmascript)");
const ExplorerSync_js_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/ExplorerSync.js [app-route] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/cosmiconfig/dist/util.js [app-route] (ecmascript)");
const identity = function identity(x) {
    return x;
};
function getUserDefinedOptionsFromMetaConfig() {
    const metaExplorer = new ExplorerSync_js_1.ExplorerSync({
        moduleName: 'cosmiconfig',
        stopDir: process.cwd(),
        searchPlaces: defaults_1.metaSearchPlaces,
        ignoreEmptySearchPlaces: false,
        applyPackagePropertyPathToConfiguration: true,
        loaders: defaults_1.defaultLoaders,
        transform: identity,
        cache: true,
        metaConfigFilePath: null,
        mergeImportArrays: true,
        mergeSearchPlaces: true,
        searchStrategy: 'none'
    });
    const metaConfig = metaExplorer.search();
    if (!metaConfig) {
        return null;
    }
    if (metaConfig.config?.loaders) {
        throw new Error('Can not specify loaders in meta config file');
    }
    if (metaConfig.config?.searchStrategy) {
        throw new Error('Can not specify searchStrategy in meta config file');
    }
    const overrideOptions = {
        mergeSearchPlaces: true,
        ...metaConfig.config ?? {}
    };
    return {
        config: (0, util_1.removeUndefinedValuesFromObject)(overrideOptions),
        filepath: metaConfig.filepath
    };
}
function getResolvedSearchPlaces(moduleName, toolDefinedSearchPlaces, userConfiguredOptions) {
    const userConfiguredSearchPlaces = userConfiguredOptions.searchPlaces?.map((path)=>path.replace('{name}', moduleName));
    if (userConfiguredOptions.mergeSearchPlaces) {
        return [
            ...userConfiguredSearchPlaces ?? [],
            ...toolDefinedSearchPlaces
        ];
    }
    return userConfiguredSearchPlaces ?? /* istanbul ignore next */ toolDefinedSearchPlaces;
}
function mergeOptionsBase(moduleName, defaults, options) {
    const userDefinedConfig = getUserDefinedOptionsFromMetaConfig();
    if (!userDefinedConfig) {
        return {
            ...defaults,
            ...(0, util_1.removeUndefinedValuesFromObject)(options),
            loaders: {
                ...defaults.loaders,
                ...options.loaders
            }
        };
    }
    const userConfiguredOptions = userDefinedConfig.config;
    const toolDefinedSearchPlaces = options.searchPlaces ?? defaults.searchPlaces;
    return {
        ...defaults,
        ...(0, util_1.removeUndefinedValuesFromObject)(options),
        metaConfigFilePath: userDefinedConfig.filepath,
        ...userConfiguredOptions,
        searchPlaces: getResolvedSearchPlaces(moduleName, toolDefinedSearchPlaces, userConfiguredOptions),
        loaders: {
            ...defaults.loaders,
            ...options.loaders
        }
    };
}
function validateOptions(options) {
    if (options.searchStrategy != null && options.searchStrategy !== 'global' && options.stopDir) {
        throw new Error('Can not supply `stopDir` option with `searchStrategy` other than "global"');
    }
}
function mergeOptions(moduleName, options) {
    validateOptions(options);
    const defaults = {
        moduleName,
        searchPlaces: (0, defaults_1.getDefaultSearchPlaces)(moduleName),
        ignoreEmptySearchPlaces: true,
        cache: true,
        transform: identity,
        loaders: defaults_1.defaultLoaders,
        metaConfigFilePath: null,
        mergeImportArrays: true,
        mergeSearchPlaces: true,
        searchStrategy: options.stopDir ? 'global' : 'none'
    };
    return mergeOptionsBase(moduleName, defaults, options);
}
function mergeOptionsSync(moduleName, options) {
    validateOptions(options);
    const defaults = {
        moduleName,
        searchPlaces: (0, defaults_1.getDefaultSearchPlacesSync)(moduleName),
        ignoreEmptySearchPlaces: true,
        cache: true,
        transform: identity,
        loaders: defaults_1.defaultLoadersSync,
        metaConfigFilePath: null,
        mergeImportArrays: true,
        mergeSearchPlaces: true,
        searchStrategy: options.stopDir ? 'global' : 'none'
    };
    return mergeOptionsBase(moduleName, defaults, options);
}
function cosmiconfig(moduleName, options = {}) {
    const normalizedOptions = mergeOptions(moduleName, options);
    const explorer = new Explorer_js_1.Explorer(normalizedOptions);
    return {
        search: explorer.search.bind(explorer),
        load: explorer.load.bind(explorer),
        clearLoadCache: explorer.clearLoadCache.bind(explorer),
        clearSearchCache: explorer.clearSearchCache.bind(explorer),
        clearCaches: explorer.clearCaches.bind(explorer)
    };
}
exports.cosmiconfig = cosmiconfig;
function cosmiconfigSync(moduleName, options = {}) {
    const normalizedOptions = mergeOptionsSync(moduleName, options);
    const explorerSync = new ExplorerSync_js_1.ExplorerSync(normalizedOptions);
    return {
        search: explorerSync.search.bind(explorerSync),
        load: explorerSync.load.bind(explorerSync),
        clearLoadCache: explorerSync.clearLoadCache.bind(explorerSync),
        clearSearchCache: explorerSync.clearSearchCache.bind(explorerSync),
        clearCaches: explorerSync.clearCaches.bind(explorerSync)
    };
}
exports.cosmiconfigSync = cosmiconfigSync; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/env-paths/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const homedir = os.homedir();
const tmpdir = os.tmpdir();
const { env } = process;
const macos = (name)=>{
    const library = path.join(homedir, 'Library');
    return {
        data: path.join(library, 'Application Support', name),
        config: path.join(library, 'Preferences', name),
        cache: path.join(library, 'Caches', name),
        log: path.join(library, 'Logs', name),
        temp: path.join(tmpdir, name)
    };
};
const windows = (name)=>{
    const appData = env.APPDATA || path.join(homedir, 'AppData', 'Roaming');
    const localAppData = env.LOCALAPPDATA || path.join(homedir, 'AppData', 'Local');
    return {
        // Data/config/cache/log are invented by me as Windows isn't opinionated about this
        data: path.join(localAppData, name, 'Data'),
        config: path.join(appData, name, 'Config'),
        cache: path.join(localAppData, name, 'Cache'),
        log: path.join(localAppData, name, 'Log'),
        temp: path.join(tmpdir, name)
    };
};
// https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
const linux = (name)=>{
    const username = path.basename(homedir);
    return {
        data: path.join(env.XDG_DATA_HOME || path.join(homedir, '.local', 'share'), name),
        config: path.join(env.XDG_CONFIG_HOME || path.join(homedir, '.config'), name),
        cache: path.join(env.XDG_CACHE_HOME || path.join(homedir, '.cache'), name),
        // https://wiki.debian.org/XDGBaseDirectorySpecification#state
        log: path.join(env.XDG_STATE_HOME || path.join(homedir, '.local', 'state'), name),
        temp: path.join(tmpdir, username, name)
    };
};
const envPaths = (name, options)=>{
    if (typeof name !== 'string') {
        throw new TypeError(`Expected string, got ${typeof name}`);
    }
    options = Object.assign({
        suffix: 'nodejs'
    }, options);
    if (options.suffix) {
        // Add suffix to prevent possible conflict with native apps
        name += `-${options.suffix}`;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        return macos(name);
    }
    "TURBOPACK unreachable";
};
module.exports = envPaths;
// TODO: Remove this for the next major release
module.exports.default = envPaths;
}}),
"[project]/node_modules/stylelint/node_modules/ms/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}}),
"[project]/node_modules/stylelint/node_modules/debug/src/common.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/stylelint/node_modules/ms/index.js [app-route] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(/\s+/g, ',').split(',').filter(Boolean);
        for (const ns of split){
            if (ns[0] === '-') {
                createDebug.skips.push(ns.slice(1));
            } else {
                createDebug.names.push(ns);
            }
        }
    }
    /**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */ function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while(searchIndex < search.length){
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
                // Match character or proceed with wildcard
                if (template[templateIndex] === '*') {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++; // Skip the '*'
                } else {
                    searchIndex++;
                    templateIndex++;
                }
            } else if (starIndex !== -1) {
                // Backtrack to the last '*' and try to match more characters
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
            } else {
                return false; // No match
            }
        }
        // Handle trailing '*' in template
        while(templateIndex < template.length && template[templateIndex] === '*'){
            templateIndex++;
        }
        return templateIndex === template.length;
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        for (const skip of createDebug.skips){
            if (matchesTemplate(name, skip)) {
                return false;
            }
        }
        for (const ns of createDebug.names){
            if (matchesTemplate(name, ns)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}}),
"[project]/node_modules/stylelint/node_modules/debug/src/node.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Module dependencies.
 */ const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __turbopack_context__.r("[project]/node_modules/supports-color/index.js [app-route] (ecmascript)");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === 'null') {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name, useColors } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
        args[0] = getDate() + name + ' ' + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return '';
    }
    return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/stylelint/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};
}}),
"[project]/node_modules/stylelint/node_modules/debug/src/browser.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    // eslint-disable-next-line no-return-assign
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/stylelint/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}}),
"[project]/node_modules/stylelint/node_modules/debug/src/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ if (typeof process === 'undefined' || process.type === 'renderer' || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
    module.exports = __turbopack_context__.r("[project]/node_modules/stylelint/node_modules/debug/src/browser.js [app-route] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/stylelint/node_modules/debug/src/node.js [app-route] (ecmascript)");
}
}}),
"[project]/node_modules/has-flag/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
}}),
"[project]/node_modules/supports-color/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const hasFlag = __turbopack_context__.r("[project]/node_modules/has-flag/index.js [app-route] (ecmascript)");
const { env } = process;
let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
}
if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
        forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
        forceColor = 0;
    } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
        return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
        return 3;
    }
    if (hasFlag('color=256')) {
        return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    if ('CI' in env) {
        if ([
            'TRAVIS',
            'CIRCLECI',
            'APPVEYOR',
            'GITLAB_CI',
            'GITHUB_ACTIONS',
            'BUILDKITE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                return version >= 3 ? 3 : 2;
            case 'Apple_Terminal':
                return 2;
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};
}}),
"[project]/node_modules/hookified/dist/node/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Eventified": (()=>n),
    "Hookified": (()=>l)
});
var n = class {
    _eventListeners;
    _maxListeners;
    _logger;
    constructor(e){
        this._eventListeners = new Map, this._maxListeners = 100, this._logger = e?.logger;
    }
    once(e, t) {
        let s = (...r)=>{
            this.off(e, s), t(...r);
        };
        return this.on(e, s), this;
    }
    listenerCount(e) {
        if (!e) return this.getAllListeners().length;
        let t = this._eventListeners.get(e);
        return t ? t.length : 0;
    }
    eventNames() {
        return Array.from(this._eventListeners.keys());
    }
    rawListeners(e) {
        return e ? this._eventListeners.get(e) ?? [] : this.getAllListeners();
    }
    prependListener(e, t) {
        let s = this._eventListeners.get(e) ?? [];
        return s.unshift(t), this._eventListeners.set(e, s), this;
    }
    prependOnceListener(e, t) {
        let s = (...r)=>{
            this.off(e, s), t(...r);
        };
        return this.prependListener(e, s), this;
    }
    maxListeners() {
        return this._maxListeners;
    }
    addListener(e, t) {
        return this.on(e, t), this;
    }
    on(e, t) {
        this._eventListeners.has(e) || this._eventListeners.set(e, []);
        let s = this._eventListeners.get(e);
        return s && (s.length >= this._maxListeners && console.warn(`MaxListenersExceededWarning: Possible event memory leak detected. ${s.length + 1} ${e} listeners added. Use setMaxListeners() to increase limit.`), s.push(t)), this;
    }
    removeListener(e, t) {
        return this.off(e, t), this;
    }
    off(e, t) {
        let s = this._eventListeners.get(e) ?? [], r = s.indexOf(t);
        return r !== -1 && s.splice(r, 1), s.length === 0 && this._eventListeners.delete(e), this;
    }
    emit(e, ...t) {
        let s = !1, r = this._eventListeners.get(e);
        if (r && r.length > 0) for (let i of r)i(...t), s = !0;
        return s;
    }
    listeners(e) {
        return this._eventListeners.get(e) ?? [];
    }
    removeAllListeners(e) {
        return e ? this._eventListeners.delete(e) : this._eventListeners.clear(), this;
    }
    setMaxListeners(e) {
        this._maxListeners = e;
        for (let t of this._eventListeners.values())t.length > e && t.splice(e);
    }
    getAllListeners() {
        let e = new Array;
        for (let t of this._eventListeners.values())e = e.concat(t);
        return e;
    }
};
var l = class extends n {
    _hooks;
    _throwHookErrors = !1;
    constructor(e){
        super({
            logger: e?.logger
        }), this._hooks = new Map, e?.throwHookErrors !== void 0 && (this._throwHookErrors = e.throwHookErrors);
    }
    get hooks() {
        return this._hooks;
    }
    get throwHookErrors() {
        return this._throwHookErrors;
    }
    set throwHookErrors(e) {
        this._throwHookErrors = e;
    }
    get logger() {
        return this._logger;
    }
    set logger(e) {
        this._logger = e;
    }
    onHook(e, t) {
        let s = this._hooks.get(e);
        s ? s.push(t) : this._hooks.set(e, [
            t
        ]);
    }
    onHooks(e) {
        for (let t of e)this.onHook(t.event, t.handler);
    }
    prependHook(e, t) {
        let s = this._hooks.get(e);
        s ? s.unshift(t) : this._hooks.set(e, [
            t
        ]);
    }
    prependOnceHook(e, t) {
        let s = async (...r)=>(this.removeHook(e, s), t(...r));
        this.prependHook(e, s);
    }
    onceHook(e, t) {
        let s = async (...r)=>(this.removeHook(e, s), t(...r));
        this.onHook(e, s);
    }
    removeHook(e, t) {
        let s = this._hooks.get(e);
        if (s) {
            let r = s.indexOf(t);
            r !== -1 && s.splice(r, 1);
        }
    }
    removeHooks(e) {
        for (let t of e)this.removeHook(t.event, t.handler);
    }
    async hook(e, ...t) {
        let s = this._hooks.get(e);
        if (s) for (let r of s)try {
            await r(...t);
        } catch (i) {
            let o = `${e}: ${i.message}`;
            if (this.emit("error", new Error(o)), this._logger && this._logger.error(o), this._throwHookErrors) throw new Error(o);
        }
    }
    getHooks(e) {
        return this._hooks.get(e);
    }
    clearHooks() {
        this._hooks.clear();
    }
};
;
}}),
"[project]/node_modules/cacheable/dist/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
// src/index.ts
__turbopack_context__.s({
    "Cacheable": (()=>Cacheable),
    "CacheableEvents": (()=>CacheableEvents),
    "CacheableHooks": (()=>CacheableHooks),
    "CacheableMemory": (()=>CacheableMemory),
    "CacheableStats": (()=>CacheableStats),
    "KeyvCacheableMemory": (()=>KeyvCacheableMemory),
    "createKeyv": (()=>createKeyv),
    "shorthandToMilliseconds": (()=>shorthandToMilliseconds),
    "shorthandToTime": (()=>shorthandToTime),
    "wrap": (()=>wrap),
    "wrapSync": (()=>wrapSync)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$keyv__$5b$external$5d$__$28$keyv$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/keyv [external] (keyv, esm_import)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hookified$2f$dist$2f$node$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hookified/dist/node/index.js [app-route] (ecmascript)");
// src/hash.ts
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$externals$5d2f$keyv__$5b$external$5d$__$28$keyv$2c$__esm_import$29$__
]);
([__TURBOPACK__imported__module__$5b$externals$5d2f$keyv__$5b$external$5d$__$28$keyv$2c$__esm_import$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
// src/shorthand-time.ts
var shorthandToMilliseconds = (shorthand)=>{
    let milliseconds;
    if (shorthand === void 0) {
        return void 0;
    }
    if (typeof shorthand === "number") {
        milliseconds = shorthand;
    } else if (typeof shorthand === "string") {
        shorthand = shorthand.trim();
        if (Number.isNaN(Number(shorthand))) {
            const match = /^([\d.]+)\s*(ms|s|m|h|hr|d)$/i.exec(shorthand);
            if (!match) {
                throw new Error(`Unsupported time format: "${shorthand}". Use 'ms', 's', 'm', 'h', 'hr', or 'd'.`);
            }
            const [, value, unit] = match;
            const numericValue = Number.parseFloat(value);
            const unitLower = unit.toLowerCase();
            switch(unitLower){
                case "ms":
                    {
                        milliseconds = numericValue;
                        break;
                    }
                case "s":
                    {
                        milliseconds = numericValue * 1e3;
                        break;
                    }
                case "m":
                    {
                        milliseconds = numericValue * 1e3 * 60;
                        break;
                    }
                case "h":
                    {
                        milliseconds = numericValue * 1e3 * 60 * 60;
                        break;
                    }
                case "hr":
                    {
                        milliseconds = numericValue * 1e3 * 60 * 60;
                        break;
                    }
                case "d":
                    {
                        milliseconds = numericValue * 1e3 * 60 * 60 * 24;
                        break;
                    }
                /* c8 ignore next 3 */ default:
                    {
                        milliseconds = Number(shorthand);
                    }
            }
        } else {
            milliseconds = Number(shorthand);
        }
    } else {
        throw new TypeError("Time must be a string or a number.");
    }
    return milliseconds;
};
var shorthandToTime = (shorthand, fromDate)=>{
    fromDate ||= /* @__PURE__ */ new Date();
    const milliseconds = shorthandToMilliseconds(shorthand);
    if (milliseconds === void 0) {
        return fromDate.getTime();
    }
    return fromDate.getTime() + milliseconds;
};
;
;
;
function hash(object, algorithm = "sha256") {
    const objectString = JSON.stringify(object);
    if (!(0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["getHashes"])().includes(algorithm)) {
        throw new Error(`Unsupported hash algorithm: '${algorithm}'`);
    }
    const hasher = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["createHash"])(algorithm);
    hasher.update(objectString);
    return hasher.digest("hex");
}
// src/coalesce-async.ts
var callbacks = /* @__PURE__ */ new Map();
function hasKey(key) {
    return callbacks.has(key);
}
function addKey(key) {
    callbacks.set(key, []);
}
function removeKey(key) {
    callbacks.delete(key);
}
function addCallbackToKey(key, callback) {
    const stash = getCallbacksByKey(key);
    stash.push(callback);
    callbacks.set(key, stash);
}
function getCallbacksByKey(key) {
    return callbacks.get(key) ?? [];
}
async function enqueue(key) {
    return new Promise((resolve, reject)=>{
        const callback = {
            resolve,
            reject
        };
        addCallbackToKey(key, callback);
    });
}
function dequeue(key) {
    const stash = getCallbacksByKey(key);
    removeKey(key);
    return stash;
}
function coalesce(options) {
    const { key, error, result } = options;
    for (const callback of dequeue(key)){
        if (error) {
            callback.reject(error);
        } else {
            callback.resolve(result);
        }
    }
}
async function coalesceAsync(key, fnc) {
    if (!hasKey(key)) {
        addKey(key);
        try {
            const result = await Promise.resolve(fnc());
            coalesce({
                key,
                result
            });
            return result;
        } catch (error) {
            coalesce({
                key,
                error
            });
            throw error;
        }
    }
    return enqueue(key);
}
// src/wrap.ts
function wrapSync(function_, options) {
    const { ttl, keyPrefix, cache } = options;
    return function(...arguments_) {
        const cacheKey = createWrapKey(function_, arguments_, keyPrefix);
        let value = cache.get(cacheKey);
        if (value === void 0) {
            try {
                value = function_(...arguments_);
                cache.set(cacheKey, value, ttl);
            } catch (error) {
                cache.emit("error", error);
                if (options.cacheErrors) {
                    cache.set(cacheKey, error, ttl);
                }
            }
        }
        return value;
    };
}
function wrap(function_, options) {
    const { ttl, keyPrefix, cache } = options;
    return async function(...arguments_) {
        let value;
        const cacheKey = createWrapKey(function_, arguments_, keyPrefix);
        value = await cache.get(cacheKey);
        if (value === void 0) {
            const cacheId = options.cacheId ?? "default";
            const coalesceKey = `${cacheId}::${cacheKey}`;
            value = await coalesceAsync(coalesceKey, async ()=>{
                try {
                    const result = await function_(...arguments_);
                    await cache.set(cacheKey, result, ttl);
                    return result;
                } catch (error) {
                    cache.emit("error", error);
                    if (options.cacheErrors) {
                        await cache.set(cacheKey, error, ttl);
                    }
                }
            });
        }
        return value;
    };
}
function createWrapKey(function_, arguments_, keyPrefix) {
    if (!keyPrefix) {
        return `${function_.name}::${hash(arguments_)}`;
    }
    return `${keyPrefix}::${function_.name}::${hash(arguments_)}`;
}
// src/memory-lru.ts
var ListNode = class {
    // eslint-disable-next-line @typescript-eslint/parameter-properties
    value;
    prev = void 0;
    next = void 0;
    constructor(value){
        this.value = value;
    }
};
var DoublyLinkedList = class {
    head = void 0;
    tail = void 0;
    nodesMap = /* @__PURE__ */ new Map();
    // Add a new node to the front (most recently used)
    addToFront(value) {
        const newNode = new ListNode(value);
        if (this.head) {
            newNode.next = this.head;
            this.head.prev = newNode;
            this.head = newNode;
        } else {
            this.head = this.tail = newNode;
        }
        this.nodesMap.set(value, newNode);
    }
    // Move an existing node to the front (most recently used)
    moveToFront(value) {
        const node = this.nodesMap.get(value);
        if (!node || this.head === node) {
            return;
        }
        if (node.prev) {
            node.prev.next = node.next;
        }
        if (node.next) {
            node.next.prev = node.prev;
        }
        if (node === this.tail) {
            this.tail = node.prev;
        }
        node.prev = void 0;
        node.next = this.head;
        if (this.head) {
            this.head.prev = node;
        }
        this.head = node;
        this.tail ||= node;
    }
    // Get the oldest node (tail)
    getOldest() {
        return this.tail ? this.tail.value : void 0;
    }
    // Remove the oldest node (tail)
    removeOldest() {
        if (!this.tail) {
            return void 0;
        }
        const oldValue = this.tail.value;
        if (this.tail.prev) {
            this.tail = this.tail.prev;
            this.tail.next = void 0;
        } else {
            this.head = this.tail = void 0;
        }
        this.nodesMap.delete(oldValue);
        return oldValue;
    }
    get size() {
        return this.nodesMap.size;
    }
};
// src/memory.ts
var CacheableMemory = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hookified$2f$dist$2f$node$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Hookified"] {
    _lru = new DoublyLinkedList();
    _hashCache = /* @__PURE__ */ new Map();
    _hash0 = /* @__PURE__ */ new Map();
    _hash1 = /* @__PURE__ */ new Map();
    _hash2 = /* @__PURE__ */ new Map();
    _hash3 = /* @__PURE__ */ new Map();
    _hash4 = /* @__PURE__ */ new Map();
    _hash5 = /* @__PURE__ */ new Map();
    _hash6 = /* @__PURE__ */ new Map();
    _hash7 = /* @__PURE__ */ new Map();
    _hash8 = /* @__PURE__ */ new Map();
    _hash9 = /* @__PURE__ */ new Map();
    _ttl;
    // Turned off by default
    _useClone = true;
    // Turned on by default
    _lruSize = 0;
    // Turned off by default
    _checkInterval = 0;
    // Turned off by default
    _interval = 0;
    // Turned off by default
    /**
   * @constructor
   * @param {CacheableMemoryOptions} [options] - The options for the CacheableMemory
   */ constructor(options){
        super();
        if (options?.ttl) {
            this.setTtl(options.ttl);
        }
        if (options?.useClone !== void 0) {
            this._useClone = options.useClone;
        }
        if (options?.lruSize) {
            this._lruSize = options.lruSize;
        }
        if (options?.checkInterval) {
            this._checkInterval = options.checkInterval;
        }
        this.startIntervalCheck();
    }
    /**
   * Gets the time-to-live
   * @returns {number|string|undefined} - The time-to-live in miliseconds or a human-readable format. If undefined, it will not have a time-to-live.
   */ get ttl() {
        return this._ttl;
    }
    /**
   * Sets the time-to-live
   * @param {number|string|undefined} value - The time-to-live in miliseconds or a human-readable format (example '1s' = 1 second, '1h' = 1 hour). If undefined, it will not have a time-to-live.
   */ set ttl(value) {
        this.setTtl(value);
    }
    /**
   * Gets whether to use clone
   * @returns {boolean} - If true, it will clone the value before returning it. If false, it will return the value directly. Default is true.
   */ get useClone() {
        return this._useClone;
    }
    /**
   * Sets whether to use clone
   * @param {boolean} value - If true, it will clone the value before returning it. If false, it will return the value directly. Default is true.
   */ set useClone(value) {
        this._useClone = value;
    }
    /**
   * Gets the size of the LRU cache
   * @returns {number} - The size of the LRU cache. If set to 0, it will not use LRU cache. Default is 0.
   */ get lruSize() {
        return this._lruSize;
    }
    /**
   * Sets the size of the LRU cache
   * @param {number} value - The size of the LRU cache. If set to 0, it will not use LRU cache. Default is 0.
   */ set lruSize(value) {
        this._lruSize = value;
        this.lruResize();
    }
    /**
   * Gets the check interval
   * @returns {number} - The interval to check for expired items. If set to 0, it will not check for expired items. Default is 0.
   */ get checkInterval() {
        return this._checkInterval;
    }
    /**
   * Sets the check interval
   * @param {number} value - The interval to check for expired items. If set to 0, it will not check for expired items. Default is 0.
   */ set checkInterval(value) {
        this._checkInterval = value;
    }
    /**
   * Gets the size of the cache
   * @returns {number} - The size of the cache
   */ get size() {
        return this._hash0.size + this._hash1.size + this._hash2.size + this._hash3.size + this._hash4.size + this._hash5.size + this._hash6.size + this._hash7.size + this._hash8.size + this._hash9.size;
    }
    /**
   * Gets the keys
   * @returns {IterableIterator<string>} - The keys
   */ get keys() {
        return this.concatStores().keys();
    }
    /**
   * Gets the items
   * @returns {IterableIterator<CacheableStoreItem>} - The items
   */ get items() {
        return this.concatStores().values();
    }
    /**
   * Gets the value of the key
   * @param {string} key - The key to get the value
   * @returns {T | undefined} - The value of the key
   */ get(key) {
        const store = this.getStore(key);
        const item = store.get(key);
        if (!item) {
            return void 0;
        }
        if (item.expires && item.expires && Date.now() > item.expires) {
            store.delete(key);
            return void 0;
        }
        this.lruMoveToFront(key);
        if (!this._useClone) {
            return item.value;
        }
        return this.clone(item.value);
    }
    /**
   * Gets the values of the keys
   * @param {string[]} keys - The keys to get the values
   * @returns {T[]} - The values of the keys
   */ getMany(keys) {
        const result = new Array();
        for (const key of keys){
            result.push(this.get(key));
        }
        return result;
    }
    /**
   * Gets the raw value of the key
   * @param {string} key - The key to get the value
   * @returns {CacheableStoreItem | undefined} - The raw value of the key
   */ getRaw(key) {
        const store = this.getStore(key);
        const item = store.get(key);
        if (!item) {
            return void 0;
        }
        if (item.expires && item.expires && Date.now() > item.expires) {
            store.delete(key);
            return void 0;
        }
        this.lruMoveToFront(key);
        return item;
    }
    /**
   * Gets the raw values of the keys
   * @param {string[]} keys - The keys to get the values
   * @returns {CacheableStoreItem[]} - The raw values of the keys
   */ getManyRaw(keys) {
        const result = new Array();
        for (const key of keys){
            result.push(this.getRaw(key));
        }
        return result;
    }
    /**
   * Sets the value of the key
   * @param {string} key - The key to set the value
   * @param {any} value - The value to set
   * @param {number|string|SetOptions} [ttl] - Time to Live - If you set a number it is miliseconds, if you set a string it is a human-readable.
   * If you want to set expire directly you can do that by setting the expire property in the SetOptions.
   * If you set undefined, it will use the default time-to-live. If both are undefined then it will not have a time-to-live.
   * @returns {void}
   */ set(key, value, ttl) {
        const store = this.getStore(key);
        let expires;
        if (ttl !== void 0 || this._ttl !== void 0) {
            if (typeof ttl === "object") {
                if (ttl.expire) {
                    expires = typeof ttl.expire === "number" ? ttl.expire : ttl.expire.getTime();
                }
                if (ttl.ttl) {
                    const finalTtl = shorthandToTime(ttl.ttl);
                    if (finalTtl !== void 0) {
                        expires = finalTtl;
                    }
                }
            } else {
                const finalTtl = shorthandToTime(ttl ?? this._ttl);
                if (finalTtl !== void 0) {
                    expires = finalTtl;
                }
            }
        }
        if (this._lruSize > 0) {
            if (store.has(key)) {
                this.lruMoveToFront(key);
            } else {
                this.lruAddToFront(key);
                if (this._lru.size > this._lruSize) {
                    const oldestKey = this._lru.getOldest();
                    if (oldestKey) {
                        this._lru.removeOldest();
                        this.delete(oldestKey);
                    }
                }
            }
        }
        const item = {
            key,
            value,
            expires
        };
        store.set(key, item);
    }
    /**
   * Sets the values of the keys
   * @param {CacheableItem[]} items - The items to set
   * @returns {void}
   */ setMany(items) {
        for (const item of items){
            this.set(item.key, item.value, item.ttl);
        }
    }
    /**
   * Checks if the key exists
   * @param {string} key - The key to check
   * @returns {boolean} - If true, the key exists. If false, the key does not exist.
   */ has(key) {
        const item = this.get(key);
        return Boolean(item);
    }
    /**
   * @function hasMany
   * @param {string[]} keys - The keys to check
   * @returns {boolean[]} - If true, the key exists. If false, the key does not exist.
   */ hasMany(keys) {
        const result = new Array();
        for (const key of keys){
            const item = this.get(key);
            result.push(Boolean(item));
        }
        return result;
    }
    /**
   * Take will get the key and delete the entry from cache
   * @param {string} key - The key to take
   * @returns {T | undefined} - The value of the key
   */ take(key) {
        const item = this.get(key);
        if (!item) {
            return void 0;
        }
        this.delete(key);
        return item;
    }
    /**
   * TakeMany will get the keys and delete the entries from cache
   * @param {string[]} keys - The keys to take
   * @returns {T[]} - The values of the keys
   */ takeMany(keys) {
        const result = new Array();
        for (const key of keys){
            result.push(this.take(key));
        }
        return result;
    }
    /**
   * Delete the key
   * @param {string} key - The key to delete
   * @returns {void}
   */ delete(key) {
        const store = this.getStore(key);
        store.delete(key);
        this._hashCache.delete(key);
    }
    /**
   * Delete the keys
   * @param {string[]} keys - The keys to delete
   * @returns {void}
   */ deleteMany(keys) {
        for (const key of keys){
            this.delete(key);
        }
    }
    /**
   * Clear the cache
   * @returns {void}
   */ clear() {
        this._hash0.clear();
        this._hash1.clear();
        this._hash2.clear();
        this._hash3.clear();
        this._hash4.clear();
        this._hash5.clear();
        this._hash6.clear();
        this._hash7.clear();
        this._hash8.clear();
        this._hash9.clear();
        this._hashCache.clear();
        this._lru = new DoublyLinkedList();
    }
    /**
   * Get the store based on the key (internal use)
   * @param {string} key - The key to get the store
   * @returns {CacheableHashStore} - The store
   */ getStore(key) {
        const hash2 = this.hashKey(key);
        return this.getStoreFromHash(hash2);
    }
    /**
   * Get the store based on the hash (internal use)
   * @param {number} hash
   * @returns {Map<string, CacheableStoreItem>}
   */ getStoreFromHash(hash2) {
        switch(hash2){
            case 1:
                {
                    return this._hash1;
                }
            case 2:
                {
                    return this._hash2;
                }
            case 3:
                {
                    return this._hash3;
                }
            case 4:
                {
                    return this._hash4;
                }
            case 5:
                {
                    return this._hash5;
                }
            case 6:
                {
                    return this._hash6;
                }
            case 7:
                {
                    return this._hash7;
                }
            case 8:
                {
                    return this._hash8;
                }
            case 9:
                {
                    return this._hash9;
                }
            default:
                {
                    return this._hash0;
                }
        }
    }
    /**
   * Hash the key (internal use)
   * @param key
   * @returns {number} from 0 to 9
   */ hashKey(key) {
        const cacheHashNumber = this._hashCache.get(key);
        if (typeof cacheHashNumber === "number") {
            return cacheHashNumber;
        }
        let hash2 = 0;
        const primeMultiplier = 31;
        for(let i = 0; i < key.length; i++){
            hash2 = hash2 * primeMultiplier + key.charCodeAt(i);
        }
        const result = Math.abs(hash2) % 10;
        this._hashCache.set(key, result);
        return result;
    }
    /**
   * Clone the value. This is for internal use
   * @param {any} value - The value to clone
   * @returns {any} - The cloned value
   */ clone(value) {
        if (this.isPrimitive(value)) {
            return value;
        }
        return structuredClone(value);
    }
    /**
   * Add to the front of the LRU cache. This is for internal use
   * @param {string} key - The key to add to the front
   * @returns {void}
   */ lruAddToFront(key) {
        if (this._lruSize === 0) {
            return;
        }
        this._lru.addToFront(key);
    }
    /**
   * Move to the front of the LRU cache. This is for internal use
   * @param {string} key - The key to move to the front
   * @returns {void}
   */ lruMoveToFront(key) {
        if (this._lruSize === 0) {
            return;
        }
        this._lru.moveToFront(key);
    }
    /**
   * Resize the LRU cache. This is for internal use
   * @returns {void}
   */ lruResize() {
        if (this._lruSize === 0) {
            return;
        }
        while(this._lru.size > this._lruSize){
            const oldestKey = this._lru.getOldest();
            if (oldestKey) {
                this._lru.removeOldest();
                this.delete(oldestKey);
            }
        }
    }
    /**
   * Check for expiration. This is for internal use
   * @returns {void}
   */ checkExpiration() {
        const stores = this.concatStores();
        for (const item of stores.values()){
            if (item.expires && Date.now() > item.expires) {
                this.delete(item.key);
            }
        }
    }
    /**
   * Start the interval check. This is for internal use
   * @returns {void}
   */ startIntervalCheck() {
        if (this._checkInterval > 0) {
            if (this._interval) {
                clearInterval(this._interval);
            }
            this._interval = setInterval(()=>{
                this.checkExpiration();
            }, this._checkInterval).unref();
        }
    }
    /**
   * Stop the interval check. This is for internal use
   * @returns {void}
   */ stopIntervalCheck() {
        if (this._interval) {
            clearInterval(this._interval);
        }
        this._interval = 0;
        this._checkInterval = 0;
    }
    /**
   * Hash the object. This is for internal use
   * @param {any} object - The object to hash
   * @param {string} [algorithm='sha256'] - The algorithm to hash
   * @returns {string} - The hashed string
   */ hash(object, algorithm = "sha256") {
        return hash(object, algorithm);
    }
    /**
   * Wrap the function for caching
   * @param {Function} function_ - The function to wrap
   * @param {Object} [options] - The options to wrap
   * @returns {Function} - The wrapped function
   */ wrap(function_, options) {
        const wrapOptions = {
            ttl: options?.ttl ?? this._ttl,
            keyPrefix: options?.keyPrefix,
            cache: this
        };
        return wrapSync(function_, wrapOptions);
    }
    isPrimitive(value) {
        const result = false;
        if (value === null || value === void 0) {
            return true;
        }
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            return true;
        }
        return result;
    }
    concatStores() {
        return new Map([
            ...this._hash0,
            ...this._hash1,
            ...this._hash2,
            ...this._hash3,
            ...this._hash4,
            ...this._hash5,
            ...this._hash6,
            ...this._hash7,
            ...this._hash8,
            ...this._hash9
        ]);
    }
    setTtl(ttl) {
        if (typeof ttl === "string" || ttl === void 0) {
            this._ttl = ttl;
        } else if (ttl > 0) {
            this._ttl = ttl;
        } else {
            this._ttl = void 0;
        }
    }
};
// src/keyv-memory.ts
var KeyvCacheableMemory = class {
    opts = {
        ttl: 0,
        useClone: true,
        lruSize: 0,
        checkInterval: 0
    };
    _defaultCache = new CacheableMemory();
    _nCache = /* @__PURE__ */ new Map();
    _namespace;
    constructor(options){
        if (options) {
            this.opts = options;
            this._defaultCache = new CacheableMemory(options);
            if (options.namespace) {
                this._namespace = options.namespace;
                this._nCache.set(this._namespace, new CacheableMemory(options));
            }
        }
    }
    get namespace() {
        return this._namespace;
    }
    set namespace(value) {
        this._namespace = value;
    }
    get store() {
        return this.getStore(this._namespace);
    }
    async get(key) {
        const result = this.getStore(this._namespace).get(key);
        if (result) {
            return result;
        }
        return void 0;
    }
    async getMany(keys) {
        const result = this.getStore(this._namespace).getMany(keys);
        return result;
    }
    async set(key, value, ttl) {
        this.getStore(this._namespace).set(key, value, ttl);
    }
    async setMany(values) {
        this.getStore(this._namespace).setMany(values);
    }
    async delete(key) {
        this.getStore(this._namespace).delete(key);
        return true;
    }
    async deleteMany(key) {
        this.getStore(this._namespace).deleteMany(key);
        return true;
    }
    async clear() {
        this.getStore(this._namespace).clear();
    }
    async has(key) {
        return this.getStore(this._namespace).has(key);
    }
    on(event, listener) {
        this.getStore(this._namespace).on(event, listener);
        return this;
    }
    getStore(namespace) {
        if (!namespace) {
            return this._defaultCache;
        }
        if (!this._nCache.has(namespace)) {
            this._nCache.set(namespace, new CacheableMemory(this.opts));
        }
        return this._nCache.get(namespace);
    }
};
function createKeyv(options) {
    const store = new KeyvCacheableMemory(options);
    const namespace = options?.namespace;
    let ttl;
    if (options?.ttl && Number.isInteger(options.ttl)) {
        ttl = options?.ttl;
    }
    const keyv = new __TURBOPACK__imported__module__$5b$externals$5d2f$keyv__$5b$external$5d$__$28$keyv$2c$__esm_import$29$__["Keyv"]({
        store,
        namespace,
        ttl
    });
    keyv.serialize = void 0;
    keyv.deserialize = void 0;
    return keyv;
}
// src/stats.ts
var CacheableStats = class {
    _hits = 0;
    _misses = 0;
    _gets = 0;
    _sets = 0;
    _deletes = 0;
    _clears = 0;
    _vsize = 0;
    _ksize = 0;
    _count = 0;
    _enabled = false;
    constructor(options){
        if (options?.enabled) {
            this._enabled = options.enabled;
        }
    }
    /**
   * @returns {boolean} - Whether the stats are enabled
   */ get enabled() {
        return this._enabled;
    }
    /**
   * @param {boolean} enabled - Whether to enable the stats
   */ set enabled(enabled) {
        this._enabled = enabled;
    }
    /**
   * @returns {number} - The number of hits
   * @readonly
   */ get hits() {
        return this._hits;
    }
    /**
   * @returns {number} - The number of misses
   * @readonly
   */ get misses() {
        return this._misses;
    }
    /**
   * @returns {number} - The number of gets
   * @readonly
   */ get gets() {
        return this._gets;
    }
    /**
   * @returns {number} - The number of sets
   * @readonly
   */ get sets() {
        return this._sets;
    }
    /**
   * @returns {number} - The number of deletes
   * @readonly
   */ get deletes() {
        return this._deletes;
    }
    /**
   * @returns {number} - The number of clears
   * @readonly
   */ get clears() {
        return this._clears;
    }
    /**
   * @returns {number} - The vsize (value size) of the cache instance
   * @readonly
   */ get vsize() {
        return this._vsize;
    }
    /**
   * @returns {number} - The ksize (key size) of the cache instance
   * @readonly
   */ get ksize() {
        return this._ksize;
    }
    /**
   * @returns {number} - The count of the cache instance
   * @readonly
   */ get count() {
        return this._count;
    }
    incrementHits() {
        if (!this._enabled) {
            return;
        }
        this._hits++;
    }
    incrementMisses() {
        if (!this._enabled) {
            return;
        }
        this._misses++;
    }
    incrementGets() {
        if (!this._enabled) {
            return;
        }
        this._gets++;
    }
    incrementSets() {
        if (!this._enabled) {
            return;
        }
        this._sets++;
    }
    incrementDeletes() {
        if (!this._enabled) {
            return;
        }
        this._deletes++;
    }
    incrementClears() {
        if (!this._enabled) {
            return;
        }
        this._clears++;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    incrementVSize(value) {
        if (!this._enabled) {
            return;
        }
        this._vsize += this.roughSizeOfObject(value);
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    decreaseVSize(value) {
        if (!this._enabled) {
            return;
        }
        this._vsize -= this.roughSizeOfObject(value);
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    incrementKSize(key) {
        if (!this._enabled) {
            return;
        }
        this._ksize += this.roughSizeOfString(key);
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    decreaseKSize(key) {
        if (!this._enabled) {
            return;
        }
        this._ksize -= this.roughSizeOfString(key);
    }
    incrementCount() {
        if (!this._enabled) {
            return;
        }
        this._count++;
    }
    decreaseCount() {
        if (!this._enabled) {
            return;
        }
        this._count--;
    }
    setCount(count) {
        if (!this._enabled) {
            return;
        }
        this._count = count;
    }
    roughSizeOfString(value) {
        return value.length * 2;
    }
    roughSizeOfObject(object) {
        const objectList = [];
        const stack = [
            object
        ];
        let bytes = 0;
        while(stack.length > 0){
            const value = stack.pop();
            if (typeof value === "boolean") {
                bytes += 4;
            } else if (typeof value === "string") {
                bytes += value.length * 2;
            } else if (typeof value === "number") {
                bytes += 8;
            } else if (typeof value === "object" && value !== null && !objectList.includes(value)) {
                objectList.push(value);
                for(const key in value){
                    bytes += key.length * 2;
                    stack.push(value[key]);
                }
            }
        }
        return bytes;
    }
    reset() {
        this._hits = 0;
        this._misses = 0;
        this._gets = 0;
        this._sets = 0;
        this._deletes = 0;
        this._clears = 0;
        this._vsize = 0;
        this._ksize = 0;
        this._count = 0;
    }
    resetStoreValues() {
        this._vsize = 0;
        this._ksize = 0;
        this._count = 0;
    }
};
// src/ttl.ts
function getTtlFromExpires(expires) {
    if (expires === void 0 || expires === null) {
        return void 0;
    }
    const now = Date.now();
    if (expires < now) {
        return void 0;
    }
    return expires - now;
}
function getCascadingTtl(cacheableTtl, primaryTtl, secondaryTtl) {
    return secondaryTtl ?? primaryTtl ?? shorthandToMilliseconds(cacheableTtl);
}
function calculateTtlFromExpiration(ttl, expires) {
    const ttlFromExpires = getTtlFromExpires(expires);
    const expiresFromTtl = ttl ? Date.now() + ttl : void 0;
    if (ttlFromExpires === void 0) {
        return ttl;
    }
    if (expiresFromTtl === void 0) {
        return ttlFromExpires;
    }
    if (expires > expiresFromTtl) {
        return ttl;
    }
    return ttlFromExpires;
}
;
var CacheableHooks = /* @__PURE__ */ ((CacheableHooks2)=>{
    CacheableHooks2["BEFORE_SET"] = "BEFORE_SET";
    CacheableHooks2["AFTER_SET"] = "AFTER_SET";
    CacheableHooks2["BEFORE_SET_MANY"] = "BEFORE_SET_MANY";
    CacheableHooks2["AFTER_SET_MANY"] = "AFTER_SET_MANY";
    CacheableHooks2["BEFORE_GET"] = "BEFORE_GET";
    CacheableHooks2["AFTER_GET"] = "AFTER_GET";
    CacheableHooks2["BEFORE_GET_MANY"] = "BEFORE_GET_MANY";
    CacheableHooks2["AFTER_GET_MANY"] = "AFTER_GET_MANY";
    CacheableHooks2["BEFORE_SECONDARY_SETS_PRIMARY"] = "BEFORE_SECONDARY_SETS_PRIMARY";
    return CacheableHooks2;
})(CacheableHooks || {});
var CacheableEvents = /* @__PURE__ */ ((CacheableEvents2)=>{
    CacheableEvents2["ERROR"] = "error";
    return CacheableEvents2;
})(CacheableEvents || {});
var Cacheable = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hookified$2f$dist$2f$node$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Hookified"] {
    _primary = createKeyv();
    _secondary;
    _nonBlocking = false;
    _ttl;
    _stats = new CacheableStats({
        enabled: false
    });
    _namespace;
    _cacheId = Math.random().toString(36).slice(2);
    /**
   * Creates a new cacheable instance
   * @param {CacheableOptions} [options] The options for the cacheable instance
   */ constructor(options){
        super();
        if (options?.primary) {
            this.setPrimary(options.primary);
        }
        if (options?.secondary) {
            this.setSecondary(options.secondary);
        }
        if (options?.nonBlocking) {
            this._nonBlocking = options.nonBlocking;
        }
        if (options?.stats) {
            this._stats.enabled = options.stats;
        }
        if (options?.ttl) {
            this.setTtl(options.ttl);
        }
        if (options?.cacheId) {
            this._cacheId = options.cacheId;
        }
        if (options?.namespace) {
            this._namespace = options.namespace;
            this._primary.namespace = this.getNameSpace();
            if (this._secondary) {
                this._secondary.namespace = this.getNameSpace();
            }
        }
    }
    /**
   * The namespace for the cacheable instance
   * @returns {string | (() => string) | undefined} The namespace for the cacheable instance
   */ get namespace() {
        return this._namespace;
    }
    /**
   * Sets the namespace for the cacheable instance
   * @param {string | (() => string) | undefined} namespace The namespace for the cacheable instance
   * @returns {void}
   */ set namespace(namespace) {
        this._namespace = namespace;
        this._primary.namespace = this.getNameSpace();
        if (this._secondary) {
            this._secondary.namespace = this.getNameSpace();
        }
    }
    /**
   * The statistics for the cacheable instance
   * @returns {CacheableStats} The statistics for the cacheable instance
   */ get stats() {
        return this._stats;
    }
    /**
   * The primary store for the cacheable instance
   * @returns {Keyv} The primary store for the cacheable instance
   */ get primary() {
        return this._primary;
    }
    /**
   * Sets the primary store for the cacheable instance
   * @param {Keyv} primary The primary store for the cacheable instance
   */ set primary(primary) {
        this._primary = primary;
    }
    /**
   * The secondary store for the cacheable instance
   * @returns {Keyv | undefined} The secondary store for the cacheable instance
   */ get secondary() {
        return this._secondary;
    }
    /**
   * Sets the secondary store for the cacheable instance. If it is set to undefined then the secondary store is disabled.
   * @param {Keyv | undefined} secondary The secondary store for the cacheable instance
   * @returns {void}
   */ set secondary(secondary) {
        this._secondary = secondary;
    }
    /**
   * Gets whether the secondary store is non-blocking mode. It is set to false by default.
   * If it is set to true then the secondary store will not block the primary store.
   *
   * [Learn more about non-blocking mode](https://cacheable.org/docs/cacheable/#non-blocking-operations).
   *
   * @returns {boolean} Whether the cacheable instance is non-blocking
   */ get nonBlocking() {
        return this._nonBlocking;
    }
    /**
   * Sets whether the secondary store is non-blocking mode. It is set to false by default.
   * If it is set to true then the secondary store will not block the primary store.
   *
   * [Learn more about non-blocking mode](https://cacheable.org/docs/cacheable/#non-blocking-operations).
   *
   * @param {boolean} nonBlocking Whether the cacheable instance is non-blocking
   * @returns {void}
   */ set nonBlocking(nonBlocking) {
        this._nonBlocking = nonBlocking;
    }
    /**
   * The time-to-live for the cacheable instance and will be used as the default value.
   * can be a number in milliseconds or a human-readable format such as `1s` for 1 second or `1h` for 1 hour
   * or undefined if there is no time-to-live.
   *
   * [Learn more about time-to-live](https://cacheable.org/docs/cacheable/#shorthand-for-time-to-live-ttl).
   *
   * @returns {number | string | undefined} The time-to-live for the cacheable instance in milliseconds, human-readable format or undefined
   * @example
   * ```typescript
   * const cacheable = new Cacheable({ ttl: '1h' });
   * console.log(cacheable.ttl); // 1h
   * ```
   */ get ttl() {
        return this._ttl;
    }
    /**
   * Sets the time-to-live for the cacheable instance and will be used as the default value.
   * If you set a number it is miliseconds, if you set a string it is a human-readable
   * format such as `1s` for 1 second or `1h` for 1 hour. Setting undefined means that
   * there is no time-to-live.
   *
   * [Learn more about time-to-live](https://cacheable.org/docs/cacheable/#shorthand-for-time-to-live-ttl).
   *
   * @param {number | string | undefined} ttl The time-to-live for the cacheable instance
   * @example
   * ```typescript
   * const cacheable = new Cacheable();
   * cacheable.ttl = '1h'; // Set the time-to-live to 1 hour
   * ```
   * or setting the time-to-live in milliseconds
   * ```typescript
   * const cacheable = new Cacheable();
   * cacheable.ttl = 3600000; // Set the time-to-live to 1 hour
   * ```
   */ set ttl(ttl) {
        this.setTtl(ttl);
    }
    /**
   * The cacheId for the cacheable instance. This is primarily used for the wrap function to not have conflicts.
   * If it is not set then it will be a random string that is generated
   * @returns {string} The cacheId for the cacheable instance
   */ get cacheId() {
        return this._cacheId;
    }
    /**
   * Sets the cacheId for the cacheable instance. This is primarily used for the wrap function to not have conflicts.
   * If it is not set then it will be a random string that is generated
   * @param {string} cacheId The cacheId for the cacheable instance
   */ set cacheId(cacheId) {
        this._cacheId = cacheId;
    }
    /**
   * Sets the primary store for the cacheable instance
   * @param {Keyv | KeyvStoreAdapter} primary The primary store for the cacheable instance
   * @returns {void}
   */ setPrimary(primary) {
        this._primary = primary instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$keyv__$5b$external$5d$__$28$keyv$2c$__esm_import$29$__["Keyv"] ? primary : new __TURBOPACK__imported__module__$5b$externals$5d2f$keyv__$5b$external$5d$__$28$keyv$2c$__esm_import$29$__["Keyv"](primary);
        this._primary.on("error", (error)=>{
            this.emit("error" /* ERROR */ , error);
        });
    }
    /**
   * Sets the secondary store for the cacheable instance. If it is set to undefined then the secondary store is disabled.
   * @param {Keyv | KeyvStoreAdapter} secondary The secondary store for the cacheable instance
   * @returns {void}
   */ setSecondary(secondary) {
        this._secondary = secondary instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$keyv__$5b$external$5d$__$28$keyv$2c$__esm_import$29$__["Keyv"] ? secondary : new __TURBOPACK__imported__module__$5b$externals$5d2f$keyv__$5b$external$5d$__$28$keyv$2c$__esm_import$29$__["Keyv"](secondary);
        this._secondary.on("error", (error)=>{
            this.emit("error" /* ERROR */ , error);
        });
    }
    getNameSpace() {
        if (typeof this._namespace === "function") {
            return this._namespace();
        }
        return this._namespace;
    }
    async get(key, options = {}) {
        let result;
        const { raw = false } = options;
        try {
            await this.hook("BEFORE_GET" /* BEFORE_GET */ , key);
            result = await this._primary.get(key, {
                raw: true
            });
            let ttl;
            if (!result && this._secondary) {
                const secondaryResult = await this.getSecondaryRawResults(key);
                if (secondaryResult?.value) {
                    result = secondaryResult;
                    const cascadeTtl = getCascadingTtl(this._ttl, this._primary.ttl);
                    const expires = secondaryResult.expires ?? void 0;
                    ttl = calculateTtlFromExpiration(cascadeTtl, expires);
                    const setItem = {
                        key,
                        value: result.value,
                        ttl
                    };
                    await this.hook("BEFORE_SECONDARY_SETS_PRIMARY" /* BEFORE_SECONDARY_SETS_PRIMARY */ , setItem);
                    await this._primary.set(setItem.key, setItem.value, setItem.ttl);
                }
            }
            await this.hook("AFTER_GET" /* AFTER_GET */ , {
                key,
                result,
                ttl
            });
        } catch (error) {
            this.emit("error" /* ERROR */ , error);
        }
        if (this.stats.enabled) {
            if (result) {
                this._stats.incrementHits();
            } else {
                this._stats.incrementMisses();
            }
            this.stats.incrementGets();
        }
        return raw ? result : result?.value;
    }
    async getMany(keys, options = {}) {
        let result = [];
        const { raw = false } = options;
        try {
            await this.hook("BEFORE_GET_MANY" /* BEFORE_GET_MANY */ , keys);
            result = await this._primary.get(keys, {
                raw: true
            });
            if (this._secondary) {
                const missingKeys = [];
                for (const [i, key] of keys.entries()){
                    if (!result[i]) {
                        missingKeys.push(key);
                    }
                }
                const secondaryResults = await this.getManySecondaryRawResults(missingKeys);
                for await (const [i, key] of keys.entries()){
                    if (!result[i] && secondaryResults[i]) {
                        result[i] = secondaryResults[i];
                        const cascadeTtl = getCascadingTtl(this._ttl, this._primary.ttl);
                        const expires = secondaryResults[i].expires;
                        const ttl = calculateTtlFromExpiration(cascadeTtl, expires);
                        const setItem = {
                            key,
                            value: result[i].value,
                            ttl
                        };
                        await this.hook("BEFORE_SECONDARY_SETS_PRIMARY" /* BEFORE_SECONDARY_SETS_PRIMARY */ , setItem);
                        await this._primary.set(setItem.key, setItem.value, setItem.ttl);
                    }
                }
            }
            await this.hook("AFTER_GET_MANY" /* AFTER_GET_MANY */ , {
                keys,
                result
            });
        } catch (error) {
            this.emit("error" /* ERROR */ , error);
        }
        if (this.stats.enabled) {
            for (const item of result){
                if (item) {
                    this._stats.incrementHits();
                } else {
                    this._stats.incrementMisses();
                }
            }
            this.stats.incrementGets();
        }
        return raw ? result : result.map((item)=>item?.value);
    }
    /**
   * Sets the value of the key. If the secondary store is set then it will also set the value in the secondary store.
   * @param {string} key the key to set the value of
   * @param {T} value The value to set
   * @param {number | string} [ttl] set a number it is miliseconds, set a string it is a human-readable
   * format such as `1s` for 1 second or `1h` for 1 hour. Setting undefined means that it will use the default time-to-live.
   * @returns {boolean} Whether the value was set
   */ async set(key, value, ttl) {
        let result = false;
        const finalTtl = shorthandToMilliseconds(ttl ?? this._ttl);
        try {
            const item = {
                key,
                value,
                ttl: finalTtl
            };
            await this.hook("BEFORE_SET" /* BEFORE_SET */ , item);
            const promises = [];
            promises.push(this._primary.set(item.key, item.value, item.ttl));
            if (this._secondary) {
                promises.push(this._secondary.set(item.key, item.value, item.ttl));
            }
            if (this._nonBlocking) {
                result = await Promise.race(promises);
            } else {
                const results = await Promise.all(promises);
                result = results[0];
            }
            await this.hook("AFTER_SET" /* AFTER_SET */ , item);
        } catch (error) {
            this.emit("error" /* ERROR */ , error);
        }
        if (this.stats.enabled) {
            this.stats.incrementKSize(key);
            this.stats.incrementCount();
            this.stats.incrementVSize(value);
            this.stats.incrementSets();
        }
        return result;
    }
    /**
   * Sets the values of the keys. If the secondary store is set then it will also set the values in the secondary store.
   * @param {CacheableItem[]} items The items to set
   * @returns {boolean} Whether the values were set
   */ async setMany(items) {
        let result = false;
        try {
            await this.hook("BEFORE_SET_MANY" /* BEFORE_SET_MANY */ , items);
            result = await this.setManyKeyv(this._primary, items);
            if (this._secondary) {
                if (this._nonBlocking) {
                    this.setManyKeyv(this._secondary, items);
                } else {
                    await this.setManyKeyv(this._secondary, items);
                }
            }
            await this.hook("AFTER_SET_MANY" /* AFTER_SET_MANY */ , items);
        } catch (error) {
            this.emit("error" /* ERROR */ , error);
        }
        if (this.stats.enabled) {
            for (const item of items){
                this.stats.incrementKSize(item.key);
                this.stats.incrementCount();
                this.stats.incrementVSize(item.value);
            }
        }
        return result;
    }
    /**
   * Takes the value of the key and deletes the key. If the key does not exist then it will return undefined.
   * @param {string} key The key to take the value of
   * @returns {Promise<T | undefined>} The value of the key or undefined if the key does not exist
   */ async take(key) {
        const result = await this.get(key);
        await this.delete(key);
        return result;
    }
    /**
   * Takes the values of the keys and deletes the keys. If the key does not exist then it will return undefined.
   * @param {string[]} keys The keys to take the values of
   * @returns {Promise<Array<T | undefined>>} The values of the keys or undefined if the key does not exist
   */ async takeMany(keys) {
        const result = await this.getMany(keys);
        await this.deleteMany(keys);
        return result;
    }
    /**
   * Checks if the key exists in the primary store. If it does not exist then it will check the secondary store.
   * @param {string} key The key to check
   * @returns {Promise<boolean>} Whether the key exists
   */ async has(key) {
        const promises = [];
        promises.push(this._primary.has(key));
        if (this._secondary) {
            promises.push(this._secondary.has(key));
        }
        const resultAll = await Promise.all(promises);
        for (const result of resultAll){
            if (result) {
                return true;
            }
        }
        return false;
    }
    /**
   * Checks if the keys exist in the primary store. If it does not exist then it will check the secondary store.
   * @param {string[]} keys The keys to check
   * @returns {Promise<boolean[]>} Whether the keys exist
   */ async hasMany(keys) {
        const result = await this.hasManyKeyv(this._primary, keys);
        const missingKeys = [];
        for (const [i, key] of keys.entries()){
            if (!result[i] && this._secondary) {
                missingKeys.push(key);
            }
        }
        if (missingKeys.length > 0 && this._secondary) {
            const secondary = await this.hasManyKeyv(this._secondary, keys);
            for (const [i, key] of keys.entries()){
                if (!result[i] && secondary[i]) {
                    result[i] = secondary[i];
                }
            }
        }
        return result;
    }
    /**
   * Deletes the key from the primary store. If the secondary store is set then it will also delete the key from the secondary store.
   * @param {string} key The key to delete
   * @returns {Promise<boolean>} Whether the key was deleted
   */ async delete(key) {
        let result = false;
        const promises = [];
        if (this.stats.enabled) {
            const statResult = await this._primary.get(key);
            if (statResult) {
                this.stats.decreaseKSize(key);
                this.stats.decreaseVSize(statResult);
                this.stats.decreaseCount();
                this.stats.incrementDeletes();
            }
        }
        promises.push(this._primary.delete(key));
        if (this._secondary) {
            promises.push(this._secondary.delete(key));
        }
        if (this.nonBlocking) {
            result = await Promise.race(promises);
        } else {
            const resultAll = await Promise.all(promises);
            result = resultAll[0];
        }
        return result;
    }
    /**
   * Deletes the keys from the primary store. If the secondary store is set then it will also delete the keys from the secondary store.
   * @param {string[]} keys The keys to delete
   * @returns {Promise<boolean>} Whether the keys were deleted
   */ async deleteMany(keys) {
        if (this.stats.enabled) {
            const statResult = await this._primary.get(keys);
            for (const key of keys){
                this.stats.decreaseKSize(key);
                this.stats.decreaseVSize(statResult);
                this.stats.decreaseCount();
                this.stats.incrementDeletes();
            }
        }
        const result = await this.deleteManyKeyv(this._primary, keys);
        if (this._secondary) {
            if (this._nonBlocking) {
                this.deleteManyKeyv(this._secondary, keys);
            } else {
                await this.deleteManyKeyv(this._secondary, keys);
            }
        }
        return result;
    }
    /**
   * Clears the primary store. If the secondary store is set then it will also clear the secondary store.
   * @returns {Promise<void>}
   */ async clear() {
        const promises = [];
        promises.push(this._primary.clear());
        if (this._secondary) {
            promises.push(this._secondary.clear());
        }
        await (this._nonBlocking ? Promise.race(promises) : Promise.all(promises));
        if (this.stats.enabled) {
            this._stats.resetStoreValues();
            this._stats.incrementClears();
        }
    }
    /**
   * Disconnects the primary store. If the secondary store is set then it will also disconnect the secondary store.
   * @returns {Promise<void>}
   */ async disconnect() {
        const promises = [];
        promises.push(this._primary.disconnect());
        if (this._secondary) {
            promises.push(this._secondary.disconnect());
        }
        await (this._nonBlocking ? Promise.race(promises) : Promise.all(promises));
    }
    /**
   * Wraps a function with caching
   *
   * [Learn more about wrapping functions](https://cacheable.org/docs/cacheable/#wrap--memoization-for-sync-and-async-functions).
   * @param {Function} function_ The function to wrap
   * @param {WrapOptions} [options] The options for the wrap function
   * @returns {Function} The wrapped function
   */ wrap(function_, options) {
        const wrapOptions = {
            ttl: options?.ttl ?? this._ttl,
            keyPrefix: options?.keyPrefix,
            cache: this,
            cacheId: this._cacheId
        };
        return wrap(function_, wrapOptions);
    }
    /**
   * Will hash an object using the specified algorithm. The default algorithm is 'sha256'.
   * @param {any} object the object to hash
   * @param {string} algorithm the hash algorithm to use. The default is 'sha256'
   * @returns {string} the hash of the object
   */ hash(object, algorithm = "sha256") {
        return hash(object, algorithm);
    }
    async getSecondaryRawResults(key) {
        let result;
        if (this._secondary) {
            result = await this._secondary.get(key, {
                raw: true
            });
        }
        return result;
    }
    async getManySecondaryRawResults(keys) {
        let result = new Array();
        if (this._secondary) {
            result = await this._secondary.get(keys, {
                raw: true
            });
        }
        return result;
    }
    async deleteManyKeyv(keyv, keys) {
        const promises = [];
        for (const key of keys){
            promises.push(keyv.delete(key));
        }
        await Promise.all(promises);
        return true;
    }
    async setManyKeyv(keyv, items) {
        const promises = [];
        for (const item of items){
            const finalTtl = shorthandToMilliseconds(item.ttl ?? this._ttl);
            promises.push(keyv.set(item.key, item.value, finalTtl));
        }
        await Promise.all(promises);
        return true;
    }
    async hasManyKeyv(keyv, keys) {
        const promises = [];
        for (const key of keys){
            promises.push(keyv.has(key));
        }
        return Promise.all(promises);
    }
    setTtl(ttl) {
        if (typeof ttl === "string" || ttl === void 0) {
            this._ttl = ttl;
        } else if (ttl > 0) {
            this._ttl = ttl;
        } else {
            this._ttl = void 0;
        }
    }
};
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/node_modules/cacheable/dist/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$externals$5d2f$keyv__$5b$external$5d$__$28$keyv$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/keyv [external] (keyv, esm_import)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hookified$2f$dist$2f$node$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hookified/dist/node/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cacheable/dist/index.js [app-route] (ecmascript) <locals>");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$externals$5d2f$keyv__$5b$external$5d$__$28$keyv$2c$__esm_import$29$__,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__
]);
([__TURBOPACK__imported__module__$5b$externals$5d2f$keyv__$5b$external$5d$__$28$keyv$2c$__esm_import$29$__, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/node_modules/flatted/esm/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/// <reference types="../types/index.d.ts" />
// (c) 2020-present Andrea Giammarchi
__turbopack_context__.s({
    "fromJSON": (()=>fromJSON),
    "parse": (()=>parse),
    "stringify": (()=>stringify),
    "toJSON": (()=>toJSON)
});
const { parse: $parse, stringify: $stringify } = JSON;
const { keys } = Object;
const Primitive = String; // it could be Number
const primitive = 'string'; // it could be 'number'
const ignore = {};
const object = 'object';
const noop = (_, value)=>value;
const primitives = (value)=>value instanceof Primitive ? Primitive(value) : value;
const Primitives = (_, value)=>typeof value === primitive ? new Primitive(value) : value;
const revive = (input, parsed, output, $)=>{
    const lazy = [];
    for(let ke = keys(output), { length } = ke, y = 0; y < length; y++){
        const k = ke[y];
        const value = output[k];
        if (value instanceof Primitive) {
            const tmp = input[value];
            if (typeof tmp === object && !parsed.has(tmp)) {
                parsed.add(tmp);
                output[k] = ignore;
                lazy.push({
                    k,
                    a: [
                        input,
                        parsed,
                        tmp,
                        $
                    ]
                });
            } else output[k] = $.call(output, k, tmp);
        } else if (output[k] !== ignore) output[k] = $.call(output, k, value);
    }
    for(let { length } = lazy, i = 0; i < length; i++){
        const { k, a } = lazy[i];
        output[k] = $.call(output, k, revive.apply(null, a));
    }
    return output;
};
const set = (known, input, value)=>{
    const index = Primitive(input.push(value) - 1);
    known.set(value, index);
    return index;
};
const parse = (text, reviver)=>{
    const input = $parse(text, Primitives).map(primitives);
    const value = input[0];
    const $ = reviver || noop;
    const tmp = typeof value === object && value ? revive(input, new Set, value, $) : value;
    return $.call({
        '': tmp
    }, '', tmp);
};
const stringify = (value, replacer, space)=>{
    const $ = replacer && typeof replacer === object ? (k, v)=>k === '' || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop;
    const known = new Map;
    const input = [];
    const output = [];
    let i = +set(known, input, $.call({
        '': value
    }, '', value));
    let firstRun = !i;
    while(i < input.length){
        firstRun = true;
        output[i] = $stringify(input[i++], replace, space);
    }
    return '[' + output.join(',') + ']';
    "TURBOPACK unreachable";
    function replace(key, value) {
        if (firstRun) {
            firstRun = !firstRun;
            return value;
        }
        const after = $.call(this, key, value);
        switch(typeof after){
            case object:
                if (after === null) return after;
            case primitive:
                return known.get(after) || set(known, input, after);
        }
        return after;
    }
};
const toJSON = (value)=>$parse(stringify(value));
const fromJSON = (value)=>parse($stringify(value));
}}),
"[project]/node_modules/flat-cache/dist/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
// src/index.ts
__turbopack_context__.s({
    "FlatCache": (()=>FlatCache),
    "FlatCacheEvents": (()=>FlatCacheEvents),
    "clearAll": (()=>clearAll),
    "clearCacheById": (()=>clearCacheById),
    "create": (()=>create),
    "createFromFile": (()=>createFromFile),
    "default": (()=>FlatCacheDefault)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/cacheable/dist/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cacheable/dist/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$flatted$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/flatted/esm/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hookified$2f$dist$2f$node$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hookified/dist/node/index.js [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
;
;
;
var FlatCacheEvents = /* @__PURE__ */ ((FlatCacheEvents2)=>{
    FlatCacheEvents2["SAVE"] = "save";
    FlatCacheEvents2["LOAD"] = "load";
    FlatCacheEvents2["DELETE"] = "delete";
    FlatCacheEvents2["CLEAR"] = "clear";
    FlatCacheEvents2["DESTROY"] = "destroy";
    FlatCacheEvents2["ERROR"] = "error";
    FlatCacheEvents2["EXPIRED"] = "expired";
    return FlatCacheEvents2;
})(FlatCacheEvents || {});
var FlatCache = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hookified$2f$dist$2f$node$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Hookified"] {
    _cache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CacheableMemory"]();
    _cacheDir = ".cache";
    _cacheId = "cache1";
    _persistInterval = 0;
    _persistTimer;
    _changesSinceLastSave = false;
    _parse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$flatted$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parse"];
    _stringify = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$flatted$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"];
    constructor(options){
        super();
        if (options) {
            this._cache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CacheableMemory"]({
                ttl: options.ttl,
                useClone: options.useClone,
                lruSize: options.lruSize,
                checkInterval: options.expirationInterval
            });
        }
        if (options?.cacheDir) {
            this._cacheDir = options.cacheDir;
        }
        if (options?.cacheId) {
            this._cacheId = options.cacheId;
        }
        if (options?.persistInterval) {
            this._persistInterval = options.persistInterval;
            this.startAutoPersist();
        }
        if (options?.deserialize) {
            this._parse = options.deserialize;
        }
        if (options?.serialize) {
            this._stringify = options.serialize;
        }
    }
    /**
   * The cache object
   * @property cache
   * @type {CacheableMemory}
   */ get cache() {
        return this._cache;
    }
    /**
   * The cache directory
   * @property cacheDir
   * @type {String}
   * @default '.cache'
   */ get cacheDir() {
        return this._cacheDir;
    }
    /**
   * Set the cache directory
   * @property cacheDir
   * @type {String}
   * @default '.cache'
   */ set cacheDir(value) {
        this._cacheDir = value;
    }
    /**
   * The cache id
   * @property cacheId
   * @type {String}
   * @default 'cache1'
   */ get cacheId() {
        return this._cacheId;
    }
    /**
   * Set the cache id
   * @property cacheId
   * @type {String}
   * @default 'cache1'
   */ set cacheId(value) {
        this._cacheId = value;
    }
    /**
   * The flag to indicate if there are changes since the last save
   * @property changesSinceLastSave
   * @type {Boolean}
   * @default false
   */ get changesSinceLastSave() {
        return this._changesSinceLastSave;
    }
    /**
   * The interval to persist the cache to disk. 0 means no timed persistence
   * @property persistInterval
   * @type {Number}
   * @default 0
   */ get persistInterval() {
        return this._persistInterval;
    }
    /**
   * Set the interval to persist the cache to disk. 0 means no timed persistence
   * @property persistInterval
   * @type {Number}
   * @default 0
   */ set persistInterval(value) {
        this._persistInterval = value;
    }
    /**
   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty
   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted
   * then the cache module directory `.cacheDir` will be used instead
   *
   * @method load
   * @param cacheId {String} the id of the cache, would also be used as the name of the file cache
   * @param cacheDir {String} directory for the cache entry
   */ // eslint-disable-next-line unicorn/prevent-abbreviations
    load(cacheId, cacheDir) {
        try {
            const filePath = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(`${cacheDir ?? this._cacheDir}/${cacheId ?? this._cacheId}`);
            this.loadFile(filePath);
            this.emit("load" /* LOAD */ );
        } catch (error) {
            this.emit("error" /* ERROR */ , error);
        }
    }
    /**
   * Load the cache from the provided file
   * @method loadFile
   * @param  {String} pathToFile the path to the file containing the info for the cache
   */ loadFile(pathToFile) {
        if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].existsSync(pathToFile)) {
            const data = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].readFileSync(pathToFile, "utf8");
            const items = this._parse(data);
            for (const key of Object.keys(items)){
                this._cache.set(items[key].key, items[key].value, {
                    expire: items[key].expires
                });
            }
            this._changesSinceLastSave = true;
        }
    }
    /**
   * Returns the entire persisted object
   * @method all
   * @returns {*}
   */ all() {
        const result = {};
        const items = Array.from(this._cache.items);
        for (const item of items){
            result[item.key] = item.value;
        }
        return result;
    }
    /**
   * Returns an array with all the items in the cache { key, value, ttl }
   * @method items
   * @returns {Array}
   */ get items() {
        return Array.from(this._cache.items);
    }
    /**
   * Returns the path to the file where the cache is persisted
   * @method cacheFilePath
   * @returns {String}
   */ get cacheFilePath() {
        return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(`${this._cacheDir}/${this._cacheId}`);
    }
    /**
   * Returns the path to the cache directory
   * @method cacheDirPath
   * @returns {String}
   */ get cacheDirPath() {
        return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(this._cacheDir);
    }
    /**
   * Returns an array with all the keys in the cache
   * @method keys
   * @returns {Array}
   */ keys() {
        return Array.from(this._cache.keys);
    }
    /**
   * (Legacy) set key method. This method will be deprecated in the future
   * @method setKey
   * @param key {string} the key to set
   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify
   */ setKey(key, value, ttl) {
        this.set(key, value, ttl);
    }
    /**
   * Sets a key to a given value
   * @method set
   * @param key {string} the key to set
   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify
   * @param [ttl] {number} the time to live in milliseconds
   */ set(key, value, ttl) {
        this._cache.set(key, value, ttl);
        this._changesSinceLastSave = true;
    }
    /**
   * (Legacy) Remove a given key from the cache. This method will be deprecated in the future
   * @method removeKey
   * @param key {String} the key to remove from the object
   */ removeKey(key) {
        this.delete(key);
    }
    /**
   * Remove a given key from the cache
   * @method delete
   * @param key {String} the key to remove from the object
   */ delete(key) {
        this._cache.delete(key);
        this._changesSinceLastSave = true;
        this.emit("delete" /* DELETE */ , key);
    }
    /**
  * (Legacy) Return the value of the provided key. This method will be deprecated in the future
  * @method getKey<T>
  * @param key {String} the name of the key to retrieve
  * @returns {*} at T the value from the key
  */ getKey(key) {
        return this.get(key);
    }
    /**
   * Return the value of the provided key
   * @method get<T>
   * @param key {String} the name of the key to retrieve
   * @returns {*} at T the value from the key
   */ get(key) {
        return this._cache.get(key);
    }
    /**
   * Clear the cache and save the state to disk
   * @method clear
   */ clear() {
        try {
            this._cache.clear();
            this._changesSinceLastSave = true;
            this.save();
            this.emit("clear" /* CLEAR */ );
        } catch (error) {
            this.emit("error" /* ERROR */ , error);
        }
    }
    /**
   * Save the state of the cache identified by the docId to disk
   * as a JSON structure
   * @method save
   */ save(force = false) {
        try {
            if (this._changesSinceLastSave || force) {
                const filePath = this.cacheFilePath;
                const items = Array.from(this._cache.items);
                const data = this._stringify(items);
                if (!__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].existsSync(this._cacheDir)) {
                    __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].mkdirSync(this._cacheDir, {
                        recursive: true
                    });
                }
                __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].writeFileSync(filePath, data);
                this._changesSinceLastSave = false;
                this.emit("save" /* SAVE */ );
            }
        } catch (error) {
            this.emit("error" /* ERROR */ , error);
        }
    }
    /**
   * Remove the file where the cache is persisted
   * @method removeCacheFile
   * @return {Boolean} true or false if the file was successfully deleted
   */ removeCacheFile() {
        try {
            if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].existsSync(this.cacheFilePath)) {
                __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].rmSync(this.cacheFilePath);
                return true;
            }
        } catch (error) {
            this.emit("error" /* ERROR */ , error);
        }
        return false;
    }
    /**
   * Destroy the cache. This will remove the directory, file, and memory cache
   * @method destroy
   * @param [includeCacheDir=false] {Boolean} if true, the cache directory will be removed
   * @return {undefined}
   */ destroy(includeCacheDirectory = false) {
        try {
            this._cache.clear();
            this.stopAutoPersist();
            if (includeCacheDirectory) {
                __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].rmSync(this.cacheDirPath, {
                    recursive: true,
                    force: true
                });
            } else {
                __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].rmSync(this.cacheFilePath, {
                    recursive: true,
                    force: true
                });
            }
            this._changesSinceLastSave = false;
            this.emit("destroy" /* DESTROY */ );
        } catch (error) {
            this.emit("error" /* ERROR */ , error);
        }
    }
    /**
   * Start the auto persist interval
   * @method startAutoPersist
   */ startAutoPersist() {
        if (this._persistInterval > 0) {
            if (this._persistTimer) {
                clearInterval(this._persistTimer);
                this._persistTimer = void 0;
            }
            this._persistTimer = setInterval(()=>{
                this.save();
            }, this._persistInterval);
        }
    }
    /**
   * Stop the auto persist interval
   * @method stopAutoPersist
   */ stopAutoPersist() {
        if (this._persistTimer) {
            clearInterval(this._persistTimer);
            this._persistTimer = void 0;
        }
    }
};
var FlatCacheDefault = class {
    static create = create;
    static createFromFile = createFromFile;
    static clearCacheById = clearCacheById;
    static clearAll = clearAll;
};
function create(options) {
    const cache = new FlatCache(options);
    cache.load();
    return cache;
}
function createFromFile(filePath, options) {
    const cache = new FlatCache(options);
    cache.loadFile(filePath);
    return cache;
}
function clearCacheById(cacheId, cacheDirectory) {
    const cache = new FlatCache({
        cacheId,
        cacheDir: cacheDirectory
    });
    cache.destroy();
}
function clearAll(cacheDirectory) {
    __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].rmSync(cacheDirectory ?? ".cache", {
        recursive: true,
        force: true
    });
}
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/node_modules/file-entry-cache/dist/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname, a: __turbopack_async_module__ } = __turbopack_context__;
__turbopack_async_module__(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {
// src/index.ts
__turbopack_context__.s({
    "FileEntryCache": (()=>FileEntryCache),
    "create": (()=>create),
    "createFromFile": (()=>createFromFile),
    "default": (()=>FileEntryDefault)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$flat$2d$cache$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/flat-cache/dist/index.js [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$flat$2d$cache$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
([__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$flat$2d$cache$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__);
;
;
;
;
function createFromFile(filePath, useCheckSum, currentWorkingDirectory) {
    const fname = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].basename(filePath);
    const directory = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].dirname(filePath);
    return create(fname, directory, useCheckSum, currentWorkingDirectory);
}
function create(cacheId, cacheDirectory, useCheckSum, currentWorkingDirectory) {
    const options = {
        currentWorkingDirectory,
        useCheckSum,
        cache: {
            cacheId,
            cacheDir: cacheDirectory
        }
    };
    const fileEntryCache = new FileEntryCache(options);
    if (cacheDirectory) {
        const cachePath = `${cacheDirectory}/${cacheId}`;
        if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].existsSync(cachePath)) {
            fileEntryCache.cache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$flat$2d$cache$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createFromFile"])(cachePath, options.cache);
        }
    }
    return fileEntryCache;
}
var FileEntryDefault = class {
    static create = create;
    static createFromFile = createFromFile;
};
var FileEntryCache = class {
    _cache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$flat$2d$cache$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FlatCache"]({
        useClone: false
    });
    _useCheckSum = false;
    _useModifiedTime = true;
    _currentWorkingDirectory;
    _hashAlgorithm = "md5";
    /**
   * Create a new FileEntryCache instance
   * @param options - The options for the FileEntryCache
   */ constructor(options){
        if (options?.cache) {
            this._cache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$flat$2d$cache$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FlatCache"](options.cache);
        }
        if (options?.useModifiedTime) {
            this._useModifiedTime = options.useModifiedTime;
        }
        if (options?.useCheckSum) {
            this._useCheckSum = options.useCheckSum;
        }
        if (options?.currentWorkingDirectory) {
            this._currentWorkingDirectory = options.currentWorkingDirectory;
        }
        if (options?.hashAlgorithm) {
            this._hashAlgorithm = options.hashAlgorithm;
        }
    }
    /**
   * Get the cache
   * @returns {FlatCache} The cache
   */ get cache() {
        return this._cache;
    }
    /**
   * Set the cache
   * @param {FlatCache} cache - The cache to set
   */ set cache(cache) {
        this._cache = cache;
    }
    /**
   * Use the hash to check if the file has changed
   * @returns {boolean} if the hash is used to check if the file has changed
   */ get useCheckSum() {
        return this._useCheckSum;
    }
    /**
   * Set the useCheckSum value
   * @param {boolean} value - The value to set
   */ set useCheckSum(value) {
        this._useCheckSum = value;
    }
    /**
   * Use the modified time to check if the file has changed
   * @returns {boolean} if the modified time is used to check if the file has changed
   */ get useModifiedTime() {
        return this._useModifiedTime;
    }
    /**
   * Set the useModifiedTime value
   * @param {boolean} value - The value to set
   */ set useModifiedTime(value) {
        this._useModifiedTime = value;
    }
    /**
   * Get the hash algorithm
   * @returns {string} The hash algorithm
   */ get hashAlgorithm() {
        return this._hashAlgorithm;
    }
    /**
   * Set the hash algorithm
   * @param {string} value - The value to set
   */ set hashAlgorithm(value) {
        this._hashAlgorithm = value;
    }
    /**
   * Get the current working directory
   * @returns {string | undefined} The current working directory
   */ get currentWorkingDirectory() {
        return this._currentWorkingDirectory;
    }
    /**
   * Set the current working directory
   * @param {string | undefined} value - The value to set
   */ set currentWorkingDirectory(value) {
        this._currentWorkingDirectory = value;
    }
    /**
   * Given a buffer, calculate md5 hash of its content.
   * @method getHash
   * @param  {Buffer} buffer   buffer to calculate hash on
   * @return {String}          content hash digest
   */ // eslint-disable-next-line @typescript-eslint/ban-types
    getHash(buffer) {
        return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].createHash(this._hashAlgorithm).update(buffer).digest("hex");
    }
    /**
   * Create the key for the file path used for caching.
   * @method createFileKey
   * @param {String} filePath
   * @return {String}
   */ createFileKey(filePath, options) {
        let result = filePath;
        const currentWorkingDirectory = options?.currentWorkingDirectory ?? this._currentWorkingDirectory;
        if (currentWorkingDirectory && filePath.startsWith(currentWorkingDirectory)) {
            const splitPath = filePath.split(currentWorkingDirectory).pop();
            if (splitPath) {
                result = splitPath;
                if (result.startsWith("/")) {
                    result = result.slice(1);
                }
            }
        }
        return result;
    }
    /**
   * Check if the file path is a relative path
   * @method isRelativePath
   * @param filePath - The file path to check
   * @returns {boolean} if the file path is a relative path, false otherwise
   */ isRelativePath(filePath) {
        return !__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].isAbsolute(filePath);
    }
    /**
  * Delete the cache file from the disk
  * @method deleteCacheFile
  * @return {boolean}       true if the file was deleted, false otherwise
  */ deleteCacheFile() {
        return this._cache.removeCacheFile();
    }
    /**
  * Remove the cache from the file and clear the memory cache
  * @method destroy
  */ destroy() {
        this._cache.destroy();
    }
    /**
   * Remove and Entry From the Cache
   * @method removeEntry
   * @param filePath - The file path to remove from the cache
   */ removeEntry(filePath, options) {
        if (this.isRelativePath(filePath)) {
            filePath = this.getAbsolutePath(filePath, {
                currentWorkingDirectory: options?.currentWorkingDirectory
            });
            this._cache.removeKey(this.createFileKey(filePath));
        }
        const key = this.createFileKey(filePath, {
            currentWorkingDirectory: options?.currentWorkingDirectory
        });
        this._cache.removeKey(key);
    }
    /**
   * Reconcile the cache
   * @method reconcile
   */ reconcile() {
        const items = this._cache.items;
        for (const item of items){
            const fileDescriptor = this.getFileDescriptor(item.key);
            if (fileDescriptor.notFound) {
                this._cache.removeKey(item.key);
            }
        }
        this._cache.save();
    }
    /**
   * Check if the file has changed
   * @method hasFileChanged
   * @param filePath - The file path to check
   * @returns {boolean} if the file has changed, false otherwise
   */ hasFileChanged(filePath) {
        let result = false;
        const fileDescriptor = this.getFileDescriptor(filePath);
        if ((!fileDescriptor.err || !fileDescriptor.notFound) && fileDescriptor.changed) {
            result = true;
        }
        return result;
    }
    /**
   * Get the file descriptor for the file path
   * @method getFileDescriptor
   * @param filePath - The file path to get the file descriptor for
   * @param options - The options for getting the file descriptor
   * @returns The file descriptor
   */ getFileDescriptor(filePath, options) {
        let fstat;
        const result = {
            key: this.createFileKey(filePath),
            changed: false,
            meta: {}
        };
        result.meta = this._cache.getKey(result.key) ?? {};
        filePath = this.getAbsolutePath(filePath, {
            currentWorkingDirectory: options?.currentWorkingDirectory
        });
        const useCheckSumValue = options?.useCheckSum ?? this._useCheckSum;
        const useModifiedTimeValue = options?.useModifiedTime ?? this._useModifiedTime;
        try {
            fstat = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].statSync(filePath);
            result.meta = {
                size: fstat.size
            };
            result.meta.mtime = fstat.mtime.getTime();
            if (useCheckSumValue) {
                const buffer = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].readFileSync(filePath);
                result.meta.hash = this.getHash(buffer);
            }
        } catch (error) {
            this.removeEntry(filePath);
            let notFound = false;
            if (error.message.includes("ENOENT")) {
                notFound = true;
            }
            return {
                key: result.key,
                err: error,
                notFound,
                meta: {}
            };
        }
        const metaCache = this._cache.getKey(result.key);
        if (!metaCache) {
            result.changed = true;
            this._cache.setKey(result.key, result.meta);
            return result;
        }
        if (result.meta.data === void 0) {
            result.meta.data = metaCache.data;
        }
        if (useModifiedTimeValue && metaCache?.mtime !== result.meta?.mtime) {
            result.changed = true;
        }
        if (metaCache?.size !== result.meta?.size) {
            result.changed = true;
        }
        if (useCheckSumValue && metaCache?.hash !== result.meta?.hash) {
            result.changed = true;
        }
        this._cache.setKey(result.key, result.meta);
        return result;
    }
    /**
   * Get the file descriptors for the files
   * @method normalizeEntries
   * @param files?: string[] - The files to get the file descriptors for
   * @returns The file descriptors
   */ normalizeEntries(files) {
        const result = new Array();
        if (files) {
            for (const file of files){
                const fileDescriptor = this.getFileDescriptor(file);
                result.push(fileDescriptor);
            }
            return result;
        }
        const keys = this.cache.keys();
        for (const key of keys){
            const fileDescriptor = this.getFileDescriptor(key);
            if (!fileDescriptor.notFound && !fileDescriptor.err) {
                result.push(fileDescriptor);
            }
        }
        return result;
    }
    /**
   * Analyze the files
   * @method analyzeFiles
   * @param files - The files to analyze
   * @returns {AnalyzedFiles} The analysis of the files
   */ analyzeFiles(files) {
        const result = {
            changedFiles: [],
            notFoundFiles: [],
            notChangedFiles: []
        };
        const fileDescriptors = this.normalizeEntries(files);
        for (const fileDescriptor of fileDescriptors){
            if (fileDescriptor.notFound) {
                result.notFoundFiles.push(fileDescriptor.key);
            } else if (fileDescriptor.changed) {
                result.changedFiles.push(fileDescriptor.key);
            } else {
                result.notChangedFiles.push(fileDescriptor.key);
            }
        }
        return result;
    }
    /**
   * Get the updated files
   * @method getUpdatedFiles
   * @param files - The files to get the updated files for
   * @returns {string[]} The updated files
   */ getUpdatedFiles(files) {
        const result = new Array();
        const fileDescriptors = this.normalizeEntries(files);
        for (const fileDescriptor of fileDescriptors){
            if (fileDescriptor.changed) {
                result.push(fileDescriptor.key);
            }
        }
        return result;
    }
    /**
   * Get the not found files
   * @method getFileDescriptorsByPath
   * @param filePath - the files that you want to get from a path
   * @returns {FileDescriptor[]} The not found files
   */ getFileDescriptorsByPath(filePath) {
        const result = new Array();
        const keys = this._cache.keys();
        for (const key of keys){
            const absolutePath = this.getAbsolutePath(filePath);
            if (absolutePath.startsWith(filePath)) {
                const fileDescriptor = this.getFileDescriptor(key);
                result.push(fileDescriptor);
            }
        }
        return result;
    }
    /**
   * Get the Absolute Path. If it is already absolute it will return the path as is.
   * @method getAbsolutePath
   * @param filePath - The file path to get the absolute path for
   * @param options - The options for getting the absolute path. The current working directory is used if not provided.
   * @returns {string}
   */ getAbsolutePath(filePath, options) {
        if (this.isRelativePath(filePath)) {
            const currentWorkingDirectory = options?.currentWorkingDirectory ?? this._currentWorkingDirectory ?? process.cwd();
            filePath = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(currentWorkingDirectory, filePath);
        }
        return filePath;
    }
    /**
   * Rename the absolute path keys. This is used when a directory is changed or renamed.
   * @method renameAbsolutePathKeys
   * @param oldPath - The old path to rename
   * @param newPath - The new path to rename to
   */ renameAbsolutePathKeys(oldPath, newPath) {
        const keys = this._cache.keys();
        for (const key of keys){
            if (key.startsWith(oldPath)) {
                const newKey = key.replace(oldPath, newPath);
                const meta = this._cache.getKey(key);
                this._cache.removeKey(key);
                this._cache.setKey(newKey, meta);
            }
        }
    }
};
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/node_modules/imurmurhash/imurmurhash.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @preserve
 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
 *
 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
 * @see http://github.com/homebrewing/brauhaus-diff
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 */ (function() {
    var cache;
    // Call this function without `new` to use the cached object (good for
    // single-threaded environments), or with `new` to create a new object.
    //
    // @param {string} key A UTF-16 or ASCII string
    // @param {number} seed An optional positive integer
    // @return {object} A MurmurHash3 object for incremental hashing
    function MurmurHash3(key, seed) {
        var m = this instanceof MurmurHash3 ? this : cache;
        m.reset(seed);
        if (typeof key === 'string' && key.length > 0) {
            m.hash(key);
        }
        if (m !== this) {
            return m;
        }
    }
    ;
    // Incrementally add a string to this hash
    //
    // @param {string} key A UTF-16 or ASCII string
    // @return {object} this
    MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;
        len = key.length;
        this.len += len;
        k1 = this.k1;
        i = 0;
        switch(this.rem){
            case 0:
                k1 ^= len > i ? key.charCodeAt(i++) & 0xffff : 0;
            case 1:
                k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 8 : 0;
            case 2:
                k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 16 : 0;
            case 3:
                k1 ^= len > i ? (key.charCodeAt(i) & 0xff) << 24 : 0;
                k1 ^= len > i ? (key.charCodeAt(i++) & 0xff00) >> 8 : 0;
        }
        this.rem = len + this.rem & 3; // & 3 is same as % 4
        len -= this.rem;
        if (len > 0) {
            h1 = this.h1;
            while(1){
                k1 = k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000 & 0xffffffff;
                k1 = k1 << 15 | k1 >>> 17;
                k1 = k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000 & 0xffffffff;
                h1 ^= k1;
                h1 = h1 << 13 | h1 >>> 19;
                h1 = h1 * 5 + 0xe6546b64 & 0xffffffff;
                if (i >= len) {
                    break;
                }
                k1 = key.charCodeAt(i++) & 0xffff ^ (key.charCodeAt(i++) & 0xffff) << 8 ^ (key.charCodeAt(i++) & 0xffff) << 16;
                top = key.charCodeAt(i++);
                k1 ^= (top & 0xff) << 24 ^ (top & 0xff00) >> 8;
            }
            k1 = 0;
            switch(this.rem){
                case 3:
                    k1 ^= (key.charCodeAt(i + 2) & 0xffff) << 16;
                case 2:
                    k1 ^= (key.charCodeAt(i + 1) & 0xffff) << 8;
                case 1:
                    k1 ^= key.charCodeAt(i) & 0xffff;
            }
            this.h1 = h1;
        }
        this.k1 = k1;
        return this;
    };
    // Get the result of this hash
    //
    // @return {number} The 32-bit hash
    MurmurHash3.prototype.result = function() {
        var k1, h1;
        k1 = this.k1;
        h1 = this.h1;
        if (k1 > 0) {
            k1 = k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000 & 0xffffffff;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000 & 0xffffffff;
            h1 ^= k1;
        }
        h1 ^= this.len;
        h1 ^= h1 >>> 16;
        h1 = h1 * 0xca6b + (h1 & 0xffff) * 0x85eb0000 & 0xffffffff;
        h1 ^= h1 >>> 13;
        h1 = h1 * 0xae35 + (h1 & 0xffff) * 0xc2b20000 & 0xffffffff;
        h1 ^= h1 >>> 16;
        return h1 >>> 0;
    };
    // Reset the hash object for reuse
    //
    // @param {number} seed An optional positive integer
    MurmurHash3.prototype.reset = function(seed) {
        this.h1 = typeof seed === 'number' ? seed : 0;
        this.rem = this.k1 = this.len = 0;
        return this;
    };
    // A cached object to use. This can be safely used if you're in a single-
    // threaded environment, otherwise you need to create new hashes to use.
    cache = new MurmurHash3();
    if ("TURBOPACK compile-time truthy", 1) {
        module.exports = MurmurHash3;
    } else {
        "TURBOPACK unreachable";
    }
})();
}}),
"[project]/node_modules/globjoin/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var Path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
var slice = Array.prototype.slice;
function join() {
    var args;
    args = slice.call(arguments, 0);
    return args.reduce(function(result, globs) {
        return _apply(result, function(path) {
            return _apply(globs, function(glob) {
                return _join(path, glob);
            });
        });
    }, '');
}
function _apply(values, fn) {
    if (Array.isArray(values)) {
        return values.reduce(function(result, value) {
            return result.concat(fn(value));
        }, []);
    }
    return fn(values);
}
function _join(path, glob) {
    var negative, positive;
    if (glob[0] === '!') {
        positive = glob.substr(1);
        if (path[0] === '!') {
            negative = '';
        } else {
            negative = '!';
        }
        return negative + Path.join(path, positive);
    }
    return Path.join(path, glob);
}
module.exports = join;
}}),
"[project]/node_modules/braces/lib/utils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
exports.isInteger = (num)=>{
    if (typeof num === 'number') {
        return Number.isInteger(num);
    }
    if (typeof num === 'string' && num.trim() !== '') {
        return Number.isInteger(Number(num));
    }
    return false;
};
/**
 * Find a node of the given type
 */ exports.find = (node, type)=>node.nodes.find((node)=>node.type === type);
/**
 * Find a node of the given type
 */ exports.exceedsLimit = (min, max, step = 1, limit)=>{
    if (limit === false) return false;
    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
    return (Number(max) - Number(min)) / Number(step) >= limit;
};
/**
 * Escape the given node with '\\' before node.value
 */ exports.escapeNode = (block, n = 0, type)=>{
    const node = block.nodes[n];
    if (!node) return;
    if (type && node.type === type || node.type === 'open' || node.type === 'close') {
        if (node.escaped !== true) {
            node.value = '\\' + node.value;
            node.escaped = true;
        }
    }
};
/**
 * Returns true if the given brace node should be enclosed in literal braces
 */ exports.encloseBrace = (node)=>{
    if (node.type !== 'brace') return false;
    if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
    }
    return false;
};
/**
 * Returns true if a brace node is invalid.
 */ exports.isInvalidBrace = (block)=>{
    if (block.type !== 'brace') return false;
    if (block.invalid === true || block.dollar) return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
    }
    if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
    }
    return false;
};
/**
 * Returns true if a node is an open or close node
 */ exports.isOpenOrClose = (node)=>{
    if (node.type === 'open' || node.type === 'close') {
        return true;
    }
    return node.open === true || node.close === true;
};
/**
 * Reduce an array of text nodes.
 */ exports.reduce = (nodes)=>nodes.reduce((acc, node)=>{
        if (node.type === 'text') acc.push(node.value);
        if (node.type === 'range') node.type = 'text';
        return acc;
    }, []);
/**
 * Flatten an array
 */ exports.flatten = (...args)=>{
    const result = [];
    const flat = (arr)=>{
        for(let i = 0; i < arr.length; i++){
            const ele = arr[i];
            if (Array.isArray(ele)) {
                flat(ele);
                continue;
            }
            if (ele !== undefined) {
                result.push(ele);
            }
        }
        return result;
    };
    flat(args);
    return result;
};
}}),
"[project]/node_modules/braces/lib/stringify.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const utils = __turbopack_context__.r("[project]/node_modules/braces/lib/utils.js [app-route] (ecmascript)");
module.exports = (ast, options = {})=>{
    const stringify = (node, parent = {})=>{
        const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = '';
        if (node.value) {
            if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
                return '\\' + node.value;
            }
            return node.value;
        }
        if (node.value) {
            return node.value;
        }
        if (node.nodes) {
            for (const child of node.nodes){
                output += stringify(child);
            }
        }
        return output;
    };
    return stringify(ast);
};
}}),
"[project]/node_modules/braces/lib/compile.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const fill = __turbopack_context__.r("[project]/node_modules/fill-range/index.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/braces/lib/utils.js [app-route] (ecmascript)");
const compile = (ast, options = {})=>{
    const walk = (node, parent = {})=>{
        const invalidBlock = utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix = options.escapeInvalid === true ? '\\' : '';
        let output = '';
        if (node.isOpen === true) {
            return prefix + node.value;
        }
        if (node.isClose === true) {
            console.log('node.isClose', prefix, node.value);
            return prefix + node.value;
        }
        if (node.type === 'open') {
            return invalid ? prefix + node.value : '(';
        }
        if (node.type === 'close') {
            return invalid ? prefix + node.value : ')';
        }
        if (node.type === 'comma') {
            return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';
        }
        if (node.value) {
            return node.value;
        }
        if (node.nodes && node.ranges > 0) {
            const args = utils.reduce(node.nodes);
            const range = fill(...args, {
                ...options,
                wrap: false,
                toRegex: true,
                strictZeros: true
            });
            if (range.length !== 0) {
                return args.length > 1 && range.length > 1 ? `(${range})` : range;
            }
        }
        if (node.nodes) {
            for (const child of node.nodes){
                output += walk(child, node);
            }
        }
        return output;
    };
    return walk(ast);
};
module.exports = compile;
}}),
"[project]/node_modules/braces/lib/expand.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const fill = __turbopack_context__.r("[project]/node_modules/fill-range/index.js [app-route] (ecmascript)");
const stringify = __turbopack_context__.r("[project]/node_modules/braces/lib/stringify.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/braces/lib/utils.js [app-route] (ecmascript)");
const append = (queue = '', stash = '', enclose = false)=>{
    const result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length) return queue;
    if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele)=>`{${ele}}`) : stash;
    }
    for (const item of queue){
        if (Array.isArray(item)) {
            for (const value of item){
                result.push(append(value, stash, enclose));
            }
        } else {
            for (let ele of stash){
                if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
                result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
            }
        }
    }
    return utils.flatten(result);
};
const expand = (ast, options = {})=>{
    const rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;
    const walk = (node, parent = {})=>{
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while(p.type !== 'brace' && p.type !== 'root' && p.parent){
            p = p.parent;
            q = p.queue;
        }
        if (node.invalid || node.dollar) {
            q.push(append(q.pop(), stringify(node, options)));
            return;
        }
        if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
            q.push(append(q.pop(), [
                '{}'
            ]));
            return;
        }
        if (node.nodes && node.ranges > 0) {
            const args = utils.reduce(node.nodes);
            if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
                throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
            }
            let range = fill(...args, options);
            if (range.length === 0) {
                range = stringify(node, options);
            }
            q.push(append(q.pop(), range));
            node.nodes = [];
            return;
        }
        const enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while(block.type !== 'brace' && block.type !== 'root' && block.parent){
            block = block.parent;
            queue = block.queue;
        }
        for(let i = 0; i < node.nodes.length; i++){
            const child = node.nodes[i];
            if (child.type === 'comma' && node.type === 'brace') {
                if (i === 1) queue.push('');
                queue.push('');
                continue;
            }
            if (child.type === 'close') {
                q.push(append(q.pop(), queue, enclose));
                continue;
            }
            if (child.value && child.type !== 'open') {
                queue.push(append(queue.pop(), child.value));
                continue;
            }
            if (child.nodes) {
                walk(child, node);
            }
        }
        return queue;
    };
    return utils.flatten(walk(ast));
};
module.exports = expand;
}}),
"[project]/node_modules/braces/lib/constants.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = {
    MAX_LENGTH: 10000,
    // Digits
    CHAR_0: '0',
    /* 0 */ CHAR_9: '9',
    /* 9 */ // Alphabet chars.
    CHAR_UPPERCASE_A: 'A',
    /* A */ CHAR_LOWERCASE_A: 'a',
    /* a */ CHAR_UPPERCASE_Z: 'Z',
    /* Z */ CHAR_LOWERCASE_Z: 'z',
    /* z */ CHAR_LEFT_PARENTHESES: '(',
    /* ( */ CHAR_RIGHT_PARENTHESES: ')',
    /* ) */ CHAR_ASTERISK: '*',
    /* * */ // Non-alphabetic chars.
    CHAR_AMPERSAND: '&',
    /* & */ CHAR_AT: '@',
    /* @ */ CHAR_BACKSLASH: '\\',
    /* \ */ CHAR_BACKTICK: '`',
    /* ` */ CHAR_CARRIAGE_RETURN: '\r',
    /* \r */ CHAR_CIRCUMFLEX_ACCENT: '^',
    /* ^ */ CHAR_COLON: ':',
    /* : */ CHAR_COMMA: ',',
    /* , */ CHAR_DOLLAR: '$',
    /* . */ CHAR_DOT: '.',
    /* . */ CHAR_DOUBLE_QUOTE: '"',
    /* " */ CHAR_EQUAL: '=',
    /* = */ CHAR_EXCLAMATION_MARK: '!',
    /* ! */ CHAR_FORM_FEED: '\f',
    /* \f */ CHAR_FORWARD_SLASH: '/',
    /* / */ CHAR_HASH: '#',
    /* # */ CHAR_HYPHEN_MINUS: '-',
    /* - */ CHAR_LEFT_ANGLE_BRACKET: '<',
    /* < */ CHAR_LEFT_CURLY_BRACE: '{',
    /* { */ CHAR_LEFT_SQUARE_BRACKET: '[',
    /* [ */ CHAR_LINE_FEED: '\n',
    /* \n */ CHAR_NO_BREAK_SPACE: '\u00A0',
    /* \u00A0 */ CHAR_PERCENT: '%',
    /* % */ CHAR_PLUS: '+',
    /* + */ CHAR_QUESTION_MARK: '?',
    /* ? */ CHAR_RIGHT_ANGLE_BRACKET: '>',
    /* > */ CHAR_RIGHT_CURLY_BRACE: '}',
    /* } */ CHAR_RIGHT_SQUARE_BRACKET: ']',
    /* ] */ CHAR_SEMICOLON: ';',
    /* ; */ CHAR_SINGLE_QUOTE: '\'',
    /* ' */ CHAR_SPACE: ' ',
    /*   */ CHAR_TAB: '\t',
    /* \t */ CHAR_UNDERSCORE: '_',
    /* _ */ CHAR_VERTICAL_LINE: '|',
    /* | */ CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */ 
};
}}),
"[project]/node_modules/braces/lib/parse.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const stringify = __turbopack_context__.r("[project]/node_modules/braces/lib/stringify.js [app-route] (ecmascript)");
/**
 * Constants
 */ const { MAX_LENGTH, CHAR_BACKSLASH, /* \ */ CHAR_BACKTICK, /* ` */ CHAR_COMMA, /* , */ CHAR_DOT, /* . */ CHAR_LEFT_PARENTHESES, /* ( */ CHAR_RIGHT_PARENTHESES, /* ) */ CHAR_LEFT_CURLY_BRACE, /* { */ CHAR_RIGHT_CURLY_BRACE, /* } */ CHAR_LEFT_SQUARE_BRACKET, /* [ */ CHAR_RIGHT_SQUARE_BRACKET, /* ] */ CHAR_DOUBLE_QUOTE, /* " */ CHAR_SINGLE_QUOTE, /* ' */ CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE } = __turbopack_context__.r("[project]/node_modules/braces/lib/constants.js [app-route] (ecmascript)");
/**
 * parse
 */ const parse = (input, options = {})=>{
    if (typeof input !== 'string') {
        throw new TypeError('Expected a string');
    }
    const opts = options || {};
    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
    }
    const ast = {
        type: 'root',
        input,
        nodes: []
    };
    const stack = [
        ast
    ];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    const length = input.length;
    let index = 0;
    let depth = 0;
    let value;
    /**
   * Helpers
   */ const advance = ()=>input[index++];
    const push = (node)=>{
        if (node.type === 'text' && prev.type === 'dot') {
            prev.type = 'text';
        }
        if (prev && prev.type === 'text' && node.type === 'text') {
            prev.value += node.value;
            return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
    };
    push({
        type: 'bos'
    });
    while(index < length){
        block = stack[stack.length - 1];
        value = advance();
        /**
     * Invalid chars
     */ if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
            continue;
        }
        /**
     * Escaped chars
     */ if (value === CHAR_BACKSLASH) {
            push({
                type: 'text',
                value: (options.keepEscaping ? value : '') + advance()
            });
            continue;
        }
        /**
     * Right square bracket (literal): ']'
     */ if (value === CHAR_RIGHT_SQUARE_BRACKET) {
            push({
                type: 'text',
                value: '\\' + value
            });
            continue;
        }
        /**
     * Left square bracket: '['
     */ if (value === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            let next;
            while(index < length && (next = advance())){
                value += next;
                if (next === CHAR_LEFT_SQUARE_BRACKET) {
                    brackets++;
                    continue;
                }
                if (next === CHAR_BACKSLASH) {
                    value += advance();
                    continue;
                }
                if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                    brackets--;
                    if (brackets === 0) {
                        break;
                    }
                }
            }
            push({
                type: 'text',
                value
            });
            continue;
        }
        /**
     * Parentheses
     */ if (value === CHAR_LEFT_PARENTHESES) {
            block = push({
                type: 'paren',
                nodes: []
            });
            stack.push(block);
            push({
                type: 'text',
                value
            });
            continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
            if (block.type !== 'paren') {
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            block = stack.pop();
            push({
                type: 'text',
                value
            });
            block = stack[stack.length - 1];
            continue;
        }
        /**
     * Quotes: '|"|`
     */ if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
            const open = value;
            let next;
            if (options.keepQuotes !== true) {
                value = '';
            }
            while(index < length && (next = advance())){
                if (next === CHAR_BACKSLASH) {
                    value += next + advance();
                    continue;
                }
                if (next === open) {
                    if (options.keepQuotes === true) value += next;
                    break;
                }
                value += next;
            }
            push({
                type: 'text',
                value
            });
            continue;
        }
        /**
     * Left curly brace: '{'
     */ if (value === CHAR_LEFT_CURLY_BRACE) {
            depth++;
            const dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
            const brace = {
                type: 'brace',
                open: true,
                close: false,
                dollar,
                depth,
                commas: 0,
                ranges: 0,
                nodes: []
            };
            block = push(brace);
            stack.push(block);
            push({
                type: 'open',
                value
            });
            continue;
        }
        /**
     * Right curly brace: '}'
     */ if (value === CHAR_RIGHT_CURLY_BRACE) {
            if (block.type !== 'brace') {
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            const type = 'close';
            block = stack.pop();
            block.close = true;
            push({
                type,
                value
            });
            depth--;
            block = stack[stack.length - 1];
            continue;
        }
        /**
     * Comma: ','
     */ if (value === CHAR_COMMA && depth > 0) {
            if (block.ranges > 0) {
                block.ranges = 0;
                const open = block.nodes.shift();
                block.nodes = [
                    open,
                    {
                        type: 'text',
                        value: stringify(block)
                    }
                ];
            }
            push({
                type: 'comma',
                value
            });
            block.commas++;
            continue;
        }
        /**
     * Dot: '.'
     */ if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
            const siblings = block.nodes;
            if (depth === 0 || siblings.length === 0) {
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            if (prev.type === 'dot') {
                block.range = [];
                prev.value += value;
                prev.type = 'range';
                if (block.nodes.length !== 3 && block.nodes.length !== 5) {
                    block.invalid = true;
                    block.ranges = 0;
                    prev.type = 'text';
                    continue;
                }
                block.ranges++;
                block.args = [];
                continue;
            }
            if (prev.type === 'range') {
                siblings.pop();
                const before = siblings[siblings.length - 1];
                before.value += prev.value + value;
                prev = before;
                block.ranges--;
                continue;
            }
            push({
                type: 'dot',
                value
            });
            continue;
        }
        /**
     * Text
     */ push({
            type: 'text',
            value
        });
    }
    // Mark imbalanced braces and brackets as invalid
    do {
        block = stack.pop();
        if (block.type !== 'root') {
            block.nodes.forEach((node)=>{
                if (!node.nodes) {
                    if (node.type === 'open') node.isOpen = true;
                    if (node.type === 'close') node.isClose = true;
                    if (!node.nodes) node.type = 'text';
                    node.invalid = true;
                }
            });
            // get the location of the block on parent.nodes (block's siblings)
            const parent = stack[stack.length - 1];
            const index = parent.nodes.indexOf(block);
            // replace the (invalid) block with it's nodes
            parent.nodes.splice(index, 1, ...block.nodes);
        }
    }while (stack.length > 0)
    push({
        type: 'eos'
    });
    return ast;
};
module.exports = parse;
}}),
"[project]/node_modules/braces/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const stringify = __turbopack_context__.r("[project]/node_modules/braces/lib/stringify.js [app-route] (ecmascript)");
const compile = __turbopack_context__.r("[project]/node_modules/braces/lib/compile.js [app-route] (ecmascript)");
const expand = __turbopack_context__.r("[project]/node_modules/braces/lib/expand.js [app-route] (ecmascript)");
const parse = __turbopack_context__.r("[project]/node_modules/braces/lib/parse.js [app-route] (ecmascript)");
/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */ const braces = (input, options = {})=>{
    let output = [];
    if (Array.isArray(input)) {
        for (const pattern of input){
            const result = braces.create(pattern, options);
            if (Array.isArray(result)) {
                output.push(...result);
            } else {
                output.push(result);
            }
        }
    } else {
        output = [].concat(braces.create(input, options));
    }
    if (options && options.expand === true && options.nodupes === true) {
        output = [
            ...new Set(output)
        ];
    }
    return output;
};
/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */ braces.parse = (input, options = {})=>parse(input, options);
/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */ braces.stringify = (input, options = {})=>{
    if (typeof input === 'string') {
        return stringify(braces.parse(input, options), options);
    }
    return stringify(input, options);
};
/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */ braces.compile = (input, options = {})=>{
    if (typeof input === 'string') {
        input = braces.parse(input, options);
    }
    return compile(input, options);
};
/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */ braces.expand = (input, options = {})=>{
    if (typeof input === 'string') {
        input = braces.parse(input, options);
    }
    let result = expand(input, options);
    // filter out empty strings if specified
    if (options.noempty === true) {
        result = result.filter(Boolean);
    }
    // filter out duplicates if specified
    if (options.nodupes === true) {
        result = [
            ...new Set(result)
        ];
    }
    return result;
};
/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */ braces.create = (input, options = {})=>{
    if (input === '' || input.length < 3) {
        return [
            input
        ];
    }
    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
};
/**
 * Expose "braces"
 */ module.exports = braces;
}}),
"[project]/node_modules/is-number/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */ 'use strict';
module.exports = function(num) {
    if (typeof num === 'number') {
        return num - num === 0;
    }
    if (typeof num === 'string' && num.trim() !== '') {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
};
}}),
"[project]/node_modules/to-regex-range/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */ 'use strict';
const isNumber = __turbopack_context__.r("[project]/node_modules/is-number/index.js [app-route] (ecmascript)");
const toRegexRange = (min, max, options)=>{
    if (isNumber(min) === false) {
        throw new TypeError('toRegexRange: expected the first argument to be a number');
    }
    if (max === void 0 || min === max) {
        return String(min);
    }
    if (isNumber(max) === false) {
        throw new TypeError('toRegexRange: expected the second argument to be a number.');
    }
    let opts = {
        relaxZeros: true,
        ...options
    };
    if (typeof opts.strictZeros === 'boolean') {
        opts.relaxZeros = opts.strictZeros === false;
    }
    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;
    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
    }
    let a = Math.min(min, max);
    let b = Math.max(min, max);
    if (Math.abs(a - b) === 1) {
        let result = min + '|' + max;
        if (opts.capture) {
            return `(${result})`;
        }
        if (opts.wrap === false) {
            return result;
        }
        return `(?:${result})`;
    }
    let isPadded = hasPadding(min) || hasPadding(max);
    let state = {
        min,
        max,
        a,
        b
    };
    let positives = [];
    let negatives = [];
    if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
    }
    if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
    }
    if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
    }
    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives, opts);
    if (opts.capture === true) {
        state.result = `(${state.result})`;
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
    }
    toRegexRange.cache[cacheKey] = state;
    return state.result;
};
function collatePatterns(neg, pos, options) {
    let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
    let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
    let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join('|');
}
function splitToRanges(min, max) {
    let nines = 1;
    let zeros = 1;
    let stop = countNines(min, nines);
    let stops = new Set([
        max
    ]);
    while(min <= stop && stop <= max){
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
    }
    stop = countZeros(max + 1, zeros) - 1;
    while(min < stop && stop <= max){
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
    }
    stops = [
        ...stops
    ];
    stops.sort(compare);
    return stops;
}
/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */ function rangeToPattern(start, stop, options) {
    if (start === stop) {
        return {
            pattern: start,
            count: [],
            digits: 0
        };
    }
    let zipped = zip(start, stop);
    let digits = zipped.length;
    let pattern = '';
    let count = 0;
    for(let i = 0; i < digits; i++){
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
            pattern += startDigit;
        } else if (startDigit !== '0' || stopDigit !== '9') {
            pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
            count++;
        }
    }
    if (count) {
        pattern += options.shorthand === true ? '\\d' : '[0-9]';
    }
    return {
        pattern,
        count: [
            count
        ],
        digits
    };
}
function splitToPatterns(min, max, tok, options) {
    let ranges = splitToRanges(min, max);
    let tokens = [];
    let start = min;
    let prev;
    for(let i = 0; i < ranges.length; i++){
        let max = ranges[i];
        let obj = rangeToPattern(String(start), String(max), options);
        let zeros = '';
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
            if (prev.count.length > 1) {
                prev.count.pop();
            }
            prev.count.push(obj.count[0]);
            prev.string = prev.pattern + toQuantifier(prev.count);
            start = max + 1;
            continue;
        }
        if (tok.isPadded) {
            zeros = padZeros(max, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max + 1;
        prev = obj;
    }
    return tokens;
}
function filterPatterns(arr, comparison, prefix, intersection, options) {
    let result = [];
    for (let ele of arr){
        let { string } = ele;
        // only push if _both_ are negative...
        if (!intersection && !contains(comparison, 'string', string)) {
            result.push(prefix + string);
        }
        // or _both_ are positive
        if (intersection && contains(comparison, 'string', string)) {
            result.push(prefix + string);
        }
    }
    return result;
}
/**
 * Zip strings
 */ function zip(a, b) {
    let arr = [];
    for(let i = 0; i < a.length; i++)arr.push([
        a[i],
        b[i]
    ]);
    return arr;
}
function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
}
function contains(arr, key, val) {
    return arr.some((ele)=>ele[key] === val);
}
function countNines(min, len) {
    return Number(String(min).slice(0, -len) + '9'.repeat(len));
}
function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
}
function toQuantifier(digits) {
    let [start = 0, stop = ''] = digits;
    if (stop || start > 1) {
        return `{${start + (stop ? ',' + stop : '')}}`;
    }
    return '';
}
function toCharacterClass(a, b, options) {
    return `[${a}${b - a === 1 ? '' : '-'}${b}]`;
}
function hasPadding(str) {
    return /^-?(0+)\d/.test(str);
}
function padZeros(value, tok, options) {
    if (!tok.isPadded) {
        return value;
    }
    let diff = Math.abs(tok.maxLen - String(value).length);
    let relax = options.relaxZeros !== false;
    switch(diff){
        case 0:
            return '';
        case 1:
            return relax ? '0?' : '0';
        case 2:
            return relax ? '0{0,2}' : '00';
        default:
            {
                return relax ? `0{0,${diff}}` : `0{${diff}}`;
            }
    }
}
/**
 * Cache
 */ toRegexRange.cache = {};
toRegexRange.clearCache = ()=>toRegexRange.cache = {};
/**
 * Expose `toRegexRange`
 */ module.exports = toRegexRange;
}}),
"[project]/node_modules/fill-range/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */ 'use strict';
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const toRegexRange = __turbopack_context__.r("[project]/node_modules/to-regex-range/index.js [app-route] (ecmascript)");
const isObject = (val)=>val !== null && typeof val === 'object' && !Array.isArray(val);
const transform = (toNumber)=>{
    return (value)=>toNumber === true ? Number(value) : String(value);
};
const isValidValue = (value)=>{
    return typeof value === 'number' || typeof value === 'string' && value !== '';
};
const isNumber = (num)=>Number.isInteger(+num);
const zeros = (input)=>{
    let value = `${input}`;
    let index = -1;
    if (value[0] === '-') value = value.slice(1);
    if (value === '0') return false;
    while(value[++index] === '0');
    return index > 0;
};
const stringify = (start, end, options)=>{
    if (typeof start === 'string' || typeof end === 'string') {
        return true;
    }
    return options.stringify === true;
};
const pad = (input, maxLength, toNumber)=>{
    if (maxLength > 0) {
        let dash = input[0] === '-' ? '-' : '';
        if (dash) input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');
    }
    if (toNumber === false) {
        return String(input);
    }
    return input;
};
const toMaxLen = (input, maxLength)=>{
    let negative = input[0] === '-' ? '-' : '';
    if (negative) {
        input = input.slice(1);
        maxLength--;
    }
    while(input.length < maxLength)input = '0' + input;
    return negative ? '-' + input : input;
};
const toSequence = (parts, options, maxLen)=>{
    parts.negatives.sort((a, b)=>a < b ? -1 : a > b ? 1 : 0);
    parts.positives.sort((a, b)=>a < b ? -1 : a > b ? 1 : 0);
    let prefix = options.capture ? '' : '?:';
    let positives = '';
    let negatives = '';
    let result;
    if (parts.positives.length) {
        positives = parts.positives.map((v)=>toMaxLen(String(v), maxLen)).join('|');
    }
    if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.map((v)=>toMaxLen(String(v), maxLen)).join('|')})`;
    }
    if (positives && negatives) {
        result = `${positives}|${negatives}`;
    } else {
        result = positives || negatives;
    }
    if (options.wrap) {
        return `(${prefix}${result})`;
    }
    return result;
};
const toRange = (a, b, isNumbers, options)=>{
    if (isNumbers) {
        return toRegexRange(a, b, {
            wrap: false,
            ...options
        });
    }
    let start = String.fromCharCode(a);
    if (a === b) return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
};
const toRegex = (start, end, options)=>{
    if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? '' : '?:';
        return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
    }
    return toRegexRange(start, end, options);
};
const rangeError = (...args)=>{
    return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};
const invalidRange = (start, end, options)=>{
    if (options.strictRanges === true) throw rangeError([
        start,
        end
    ]);
    return [];
};
const invalidStep = (step, options)=>{
    if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
    }
    return [];
};
const fillNumbers = (start, end, step = 1, options = {})=>{
    let a = Number(start);
    let b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true) throw rangeError([
            start,
            end
        ]);
        return [];
    }
    // fix negative zero
    if (a === 0) a = 0;
    if (b === 0) b = 0;
    let descending = a > b;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify(start, end, options) === false;
    let format = options.transform || transform(toNumber);
    if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }
    let parts = {
        negatives: [],
        positives: []
    };
    let push = (num)=>parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
    let range = [];
    let index = 0;
    while(descending ? a >= b : a <= b){
        if (options.toRegex === true && step > 1) {
            push(a);
        } else {
            range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
    }
    if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, {
            wrap: false,
            ...options
        });
    }
    return range;
};
const fillLetters = (start, end, step = 1, options = {})=>{
    if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
    }
    let format = options.transform || ((val)=>String.fromCharCode(val));
    let a = `${start}`.charCodeAt(0);
    let b = `${end}`.charCodeAt(0);
    let descending = a > b;
    let min = Math.min(a, b);
    let max = Math.max(a, b);
    if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
    }
    let range = [];
    let index = 0;
    while(descending ? a >= b : a <= b){
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
    }
    if (options.toRegex === true) {
        return toRegex(range, null, {
            wrap: false,
            options
        });
    }
    return range;
};
const fill = (start, end, step, options = {})=>{
    if (end == null && isValidValue(start)) {
        return [
            start
        ];
    }
    if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
    }
    if (typeof step === 'function') {
        return fill(start, end, 1, {
            transform: step
        });
    }
    if (isObject(step)) {
        return fill(start, end, 0, step);
    }
    let opts = {
        ...options
    };
    if (opts.capture === true) opts.wrap = true;
    step = step || opts.step || 1;
    if (!isNumber(step)) {
        if (step != null && !isObject(step)) return invalidStep(step, opts);
        return fill(start, end, 1, step);
    }
    if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
    }
    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};
module.exports = fill;
}}),
"[project]/node_modules/picomatch/lib/constants.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;
/**
 * Posix glob regex
 */ const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;
const POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
};
/**
 * Windows glob regex
 */ const WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};
/**
 * POSIX Bracket Regex
 */ const POSIX_REGEX_SOURCE = {
    alnum: 'a-zA-Z0-9',
    alpha: 'a-zA-Z',
    ascii: '\\x00-\\x7F',
    blank: ' \\t',
    cntrl: '\\x00-\\x1F\\x7F',
    digit: '0-9',
    graph: '\\x21-\\x7E',
    lower: 'a-z',
    print: '\\x20-\\x7E ',
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: ' \\t\\r\\n\\v\\f',
    upper: 'A-Z',
    word: 'A-Za-z0-9_',
    xdigit: 'A-Fa-f0-9'
};
module.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
        '***': '*',
        '**/**': '**',
        '**/**/**': '**'
    },
    // Digits
    CHAR_0: 48,
    /* 0 */ CHAR_9: 57,
    /* 9 */ // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */ CHAR_LOWERCASE_A: 97,
    /* a */ CHAR_UPPERCASE_Z: 90,
    /* Z */ CHAR_LOWERCASE_Z: 122,
    /* z */ CHAR_LEFT_PARENTHESES: 40,
    /* ( */ CHAR_RIGHT_PARENTHESES: 41,
    /* ) */ CHAR_ASTERISK: 42,
    /* * */ // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */ CHAR_AT: 64,
    /* @ */ CHAR_BACKWARD_SLASH: 92,
    /* \ */ CHAR_CARRIAGE_RETURN: 13,
    /* \r */ CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */ CHAR_COLON: 58,
    /* : */ CHAR_COMMA: 44,
    /* , */ CHAR_DOT: 46,
    /* . */ CHAR_DOUBLE_QUOTE: 34,
    /* " */ CHAR_EQUAL: 61,
    /* = */ CHAR_EXCLAMATION_MARK: 33,
    /* ! */ CHAR_FORM_FEED: 12,
    /* \f */ CHAR_FORWARD_SLASH: 47,
    /* / */ CHAR_GRAVE_ACCENT: 96,
    /* ` */ CHAR_HASH: 35,
    /* # */ CHAR_HYPHEN_MINUS: 45,
    /* - */ CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */ CHAR_LEFT_CURLY_BRACE: 123,
    /* { */ CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */ CHAR_LINE_FEED: 10,
    /* \n */ CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */ CHAR_PERCENT: 37,
    /* % */ CHAR_PLUS: 43,
    /* + */ CHAR_QUESTION_MARK: 63,
    /* ? */ CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */ CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */ CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */ CHAR_SEMICOLON: 59,
    /* ; */ CHAR_SINGLE_QUOTE: 39,
    /* ' */ CHAR_SPACE: 32,
    /*   */ CHAR_TAB: 9,
    /* \t */ CHAR_UNDERSCORE: 95,
    /* _ */ CHAR_VERTICAL_LINE: 124,
    /* | */ CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */ SEP: path.sep,
    /**
   * Create EXTGLOB_CHARS
   */ extglobChars (chars) {
        return {
            '!': {
                type: 'negate',
                open: '(?:(?!(?:',
                close: `))${chars.STAR})`
            },
            '?': {
                type: 'qmark',
                open: '(?:',
                close: ')?'
            },
            '+': {
                type: 'plus',
                open: '(?:',
                close: ')+'
            },
            '*': {
                type: 'star',
                open: '(?:',
                close: ')*'
            },
            '@': {
                type: 'at',
                open: '(?:',
                close: ')'
            }
        };
    },
    /**
   * Create GLOB_CHARS
   */ globChars (win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
};
}}),
"[project]/node_modules/picomatch/lib/utils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const win32 = process.platform === 'win32';
const { REGEX_BACKSLASH, REGEX_REMOVE_BACKSLASH, REGEX_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_GLOBAL } = __turbopack_context__.r("[project]/node_modules/picomatch/lib/constants.js [app-route] (ecmascript)");
exports.isObject = (val)=>val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = (str)=>REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = (str)=>str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = (str)=>str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = (str)=>str.replace(REGEX_BACKSLASH, '/');
exports.removeBackslashes = (str)=>{
    return str.replace(REGEX_REMOVE_BACKSLASH, (match)=>{
        return match === '\\' ? '' : match;
    });
};
exports.supportsLookbehinds = ()=>{
    const segs = process.version.slice(1).split('.').map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
    }
    return false;
};
exports.isWindows = (options)=>{
    if (options && typeof options.windows === 'boolean') {
        return options.windows;
    }
    return win32 === true || path.sep === '\\';
};
exports.escapeLast = (input, char, lastIdx)=>{
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1) return input;
    if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};
exports.removePrefix = (input, state = {})=>{
    let output = input;
    if (output.startsWith('./')) {
        output = output.slice(2);
        state.prefix = './';
    }
    return output;
};
exports.wrapOutput = (input, state = {}, options = {})=>{
    const prepend = options.contains ? '' : '^';
    const append = options.contains ? '' : '$';
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
    }
    return output;
};
}}),
"[project]/node_modules/picomatch/lib/scan.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const utils = __turbopack_context__.r("[project]/node_modules/picomatch/lib/utils.js [app-route] (ecmascript)");
const { CHAR_ASTERISK, /* * */ CHAR_AT, /* @ */ CHAR_BACKWARD_SLASH, /* \ */ CHAR_COMMA, /* , */ CHAR_DOT, /* . */ CHAR_EXCLAMATION_MARK, /* ! */ CHAR_FORWARD_SLASH, /* / */ CHAR_LEFT_CURLY_BRACE, /* { */ CHAR_LEFT_PARENTHESES, /* ( */ CHAR_LEFT_SQUARE_BRACKET, /* [ */ CHAR_PLUS, /* + */ CHAR_QUESTION_MARK, /* ? */ CHAR_RIGHT_CURLY_BRACE, /* } */ CHAR_RIGHT_PARENTHESES, /* ) */ CHAR_RIGHT_SQUARE_BRACKET/* ] */  } = __turbopack_context__.r("[project]/node_modules/picomatch/lib/constants.js [app-route] (ecmascript)");
const isPathSeparator = (code)=>{
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};
const depth = (token)=>{
    if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
    }
};
/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */ const scan = (input, options)=>{
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = {
        value: '',
        depth: 0,
        isGlob: false
    };
    const eos = ()=>index >= length;
    const peek = ()=>str.charCodeAt(index + 1);
    const advance = ()=>{
        prev = code;
        return str.charCodeAt(++index);
    };
    while(index < length){
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === CHAR_LEFT_CURLY_BRACE) {
                braceEscaped = true;
            }
            continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while(eos() !== true && (code = advance())){
                if (code === CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    advance();
                    continue;
                }
                if (code === CHAR_LEFT_CURLY_BRACE) {
                    braces++;
                    continue;
                }
                if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
                    isBrace = token.isBrace = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (scanToEnd === true) {
                        continue;
                    }
                    break;
                }
                if (braceEscaped !== true && code === CHAR_COMMA) {
                    isBrace = token.isBrace = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (scanToEnd === true) {
                        continue;
                    }
                    break;
                }
                if (code === CHAR_RIGHT_CURLY_BRACE) {
                    braces--;
                    if (braces === 0) {
                        braceEscaped = false;
                        isBrace = token.isBrace = true;
                        finished = true;
                        break;
                    }
                }
            }
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
        if (code === CHAR_FORWARD_SLASH) {
            slashes.push(index);
            tokens.push(token);
            token = {
                value: '',
                depth: 0,
                isGlob: false
            };
            if (finished === true) continue;
            if (prev === CHAR_DOT && index === start + 1) {
                start += 2;
                continue;
            }
            lastIndex = index + 1;
            continue;
        }
        if (opts.noext !== true) {
            const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
                isGlob = token.isGlob = true;
                isExtglob = token.isExtglob = true;
                finished = true;
                if (code === CHAR_EXCLAMATION_MARK && index === start) {
                    negatedExtglob = true;
                }
                if (scanToEnd === true) {
                    while(eos() !== true && (code = advance())){
                        if (code === CHAR_BACKWARD_SLASH) {
                            backslashes = token.backslashes = true;
                            code = advance();
                            continue;
                        }
                        if (code === CHAR_RIGHT_PARENTHESES) {
                            isGlob = token.isGlob = true;
                            finished = true;
                            break;
                        }
                    }
                    continue;
                }
                break;
            }
        }
        if (code === CHAR_ASTERISK) {
            if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
        if (code === CHAR_QUESTION_MARK) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
            while(eos() !== true && (next = advance())){
                if (next === CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    advance();
                    continue;
                }
                if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                    isBracket = token.isBracket = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                }
            }
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
                while(eos() !== true && (code = advance())){
                    if (code === CHAR_LEFT_PARENTHESES) {
                        backslashes = token.backslashes = true;
                        code = advance();
                        continue;
                    }
                    if (code === CHAR_RIGHT_PARENTHESES) {
                        finished = true;
                        break;
                    }
                }
                continue;
            }
            break;
        }
        if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
    }
    if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
    }
    let base = str;
    let prefix = '';
    let glob = '';
    if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
    } else if (isGlob === true) {
        base = '';
        glob = str;
    } else {
        base = str;
    }
    if (base && base !== '' && base !== '/' && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
            base = base.slice(0, -1);
        }
    }
    if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
            base = utils.removeBackslashes(base);
        }
    }
    const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
    };
    if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
            tokens.push(token);
        }
        state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for(let idx = 0; idx < slashes.length; idx++){
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts.tokens) {
                if (idx === 0 && start !== 0) {
                    tokens[idx].isPrefix = true;
                    tokens[idx].value = prefix;
                } else {
                    tokens[idx].value = value;
                }
                depth(tokens[idx]);
                state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== '') {
                parts.push(value);
            }
            prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
            const value = input.slice(prevIndex + 1);
            parts.push(value);
            if (opts.tokens) {
                tokens[tokens.length - 1].value = value;
                depth(tokens[tokens.length - 1]);
                state.maxDepth += tokens[tokens.length - 1].depth;
            }
        }
        state.slashes = slashes;
        state.parts = parts;
    }
    return state;
};
module.exports = scan;
}}),
"[project]/node_modules/picomatch/lib/parse.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const constants = __turbopack_context__.r("[project]/node_modules/picomatch/lib/constants.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/picomatch/lib/utils.js [app-route] (ecmascript)");
/**
 * Constants
 */ const { MAX_LENGTH, POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS } = constants;
/**
 * Helpers
 */ const expandRange = (args, options)=>{
    if (typeof options.expandRange === 'function') {
        return options.expandRange(...args, options);
    }
    args.sort();
    const value = `[${args.join('-')}]`;
    try {
        /* eslint-disable-next-line no-new */ new RegExp(value);
    } catch (ex) {
        return args.map((v)=>utils.escapeRegex(v)).join('..');
    }
    return value;
};
/**
 * Create the message for a syntax error
 */ const syntaxError = (type, char)=>{
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};
/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */ const parse = (input, options)=>{
    if (typeof input !== 'string') {
        throw new TypeError('Expected a string');
    }
    input = REPLACEMENTS[input] || input;
    const opts = {
        ...options
    };
    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    const bos = {
        type: 'bos',
        value: '',
        output: opts.prepend || ''
    };
    const tokens = [
        bos
    ];
    const capture = opts.capture ? '' : '?:';
    const win32 = utils.isWindows(options);
    // create constants based on platform, for windows or posix
    const PLATFORM_CHARS = constants.globChars(win32);
    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    const { DOT_LITERAL, PLUS_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK, QMARK_NO_DOT, STAR, START_ANCHOR } = PLATFORM_CHARS;
    const globstar = (opts)=>{
        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? '' : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
        star = `(${star})`;
    }
    // minimatch options support
    if (typeof opts.noext === 'boolean') {
        opts.noextglob = opts.noext;
    }
    const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: '',
        output: '',
        prefix: '',
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
    };
    input = utils.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    /**
   * Tokenizing helpers
   */ const eos = ()=>state.index === len - 1;
    const peek = state.peek = (n = 1)=>input[state.index + n];
    const advance = state.advance = ()=>input[++state.index] || '';
    const remaining = ()=>input.slice(state.index + 1);
    const consume = (value = '', num = 0)=>{
        state.consumed += value;
        state.index += num;
    };
    const append = (token)=>{
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
    };
    const negate = ()=>{
        let count = 1;
        while(peek() === '!' && (peek(2) !== '(' || peek(3) === '?')){
            advance();
            state.start++;
            count++;
        }
        if (count % 2 === 0) {
            return false;
        }
        state.negated = true;
        state.start++;
        return true;
    };
    const increment = (type)=>{
        state[type]++;
        stack.push(type);
    };
    const decrement = (type)=>{
        state[type]--;
        stack.pop();
    };
    /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */ const push = (tok)=>{
        if (prev.type === 'globstar') {
            const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');
            if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
                state.output = state.output.slice(0, -prev.output.length);
                prev.type = 'star';
                prev.value = '*';
                prev.output = star;
                state.output += prev.output;
            }
        }
        if (extglobs.length && tok.type !== 'paren') {
            extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === 'text' && tok.type === 'text') {
            prev.value += tok.value;
            prev.output = (prev.output || '') + tok.value;
            return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
    };
    const extglobOpen = (type, value)=>{
        const token = {
            ...EXTGLOB_CHARS[value],
            conditions: 1,
            inner: ''
        };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? '(' : '') + token.open;
        increment('parens');
        push({
            type,
            value,
            output: state.output ? '' : ONE_CHAR
        });
        push({
            type: 'paren',
            extglob: true,
            value: advance(),
            output
        });
        extglobs.push(token);
    };
    const extglobClose = (token)=>{
        let output = token.close + (opts.capture ? ')' : '');
        let rest;
        if (token.type === 'negate') {
            let extglobStar = star;
            if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
                extglobStar = globstar(opts);
            }
            if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
                output = token.close = `)$))${extglobStar}`;
            }
            if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
                // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
                // In this case, we need to parse the string and use it in the output of the original pattern.
                // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
                //
                // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
                const expression = parse(rest, {
                    ...options,
                    fastpaths: false
                }).output;
                output = token.close = `)${expression})${extglobStar})`;
            }
            if (token.prev.type === 'bos') {
                state.negatedExtglob = true;
            }
        }
        push({
            type: 'paren',
            extglob: true,
            value,
            output
        });
        decrement('parens');
    };
    /**
   * Fast paths
   */ if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index)=>{
            if (first === '\\') {
                backslashes = true;
                return m;
            }
            if (first === '?') {
                if (esc) {
                    return esc + first + (rest ? QMARK.repeat(rest.length) : '');
                }
                if (index === 0) {
                    return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
                }
                return QMARK.repeat(chars.length);
            }
            if (first === '.') {
                return DOT_LITERAL.repeat(chars.length);
            }
            if (first === '*') {
                if (esc) {
                    return esc + first + (rest ? star : '');
                }
                return star;
            }
            return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
            if (opts.unescape === true) {
                output = output.replace(/\\/g, '');
            } else {
                output = output.replace(/\\+/g, (m)=>{
                    return m.length % 2 === 0 ? '\\\\' : m ? '\\' : '';
                });
            }
        }
        if (output === input && opts.contains === true) {
            state.output = input;
            return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
    }
    /**
   * Tokenize input until we reach end-of-string
   */ while(!eos()){
        value = advance();
        if (value === '\u0000') {
            continue;
        }
        /**
     * Escaped characters
     */ if (value === '\\') {
            const next = peek();
            if (next === '/' && opts.bash !== true) {
                continue;
            }
            if (next === '.' || next === ';') {
                continue;
            }
            if (!next) {
                value += '\\';
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            // collapse slashes to reduce potential for exploits
            const match = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match && match[0].length > 2) {
                slashes = match[0].length;
                state.index += slashes;
                if (slashes % 2 !== 0) {
                    value += '\\';
                }
            }
            if (opts.unescape === true) {
                value = advance();
            } else {
                value += advance();
            }
            if (state.brackets === 0) {
                push({
                    type: 'text',
                    value
                });
                continue;
            }
        }
        /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */ if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
            if (opts.posix !== false && value === ':') {
                const inner = prev.value.slice(1);
                if (inner.includes('[')) {
                    prev.posix = true;
                    if (inner.includes(':')) {
                        const idx = prev.value.lastIndexOf('[');
                        const pre = prev.value.slice(0, idx);
                        const rest = prev.value.slice(idx + 2);
                        const posix = POSIX_REGEX_SOURCE[rest];
                        if (posix) {
                            prev.value = pre + posix;
                            state.backtrack = true;
                            advance();
                            if (!bos.output && tokens.indexOf(prev) === 1) {
                                bos.output = ONE_CHAR;
                            }
                            continue;
                        }
                    }
                }
            }
            if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {
                value = `\\${value}`;
            }
            if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
                value = `\\${value}`;
            }
            if (opts.posix === true && value === '!' && prev.value === '[') {
                value = '^';
            }
            prev.value += value;
            append({
                value
            });
            continue;
        }
        /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */ if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value);
            prev.value += value;
            append({
                value
            });
            continue;
        }
        /**
     * Double quotes
     */ if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) {
                push({
                    type: 'text',
                    value
                });
            }
            continue;
        }
        /**
     * Parentheses
     */ if (value === '(') {
            increment('parens');
            push({
                type: 'paren',
                value
            });
            continue;
        }
        if (value === ')') {
            if (state.parens === 0 && opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError('opening', '('));
            }
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
                extglobClose(extglobs.pop());
                continue;
            }
            push({
                type: 'paren',
                value,
                output: state.parens ? ')' : '\\)'
            });
            decrement('parens');
            continue;
        }
        /**
     * Square brackets
     */ if (value === '[') {
            if (opts.nobracket === true || !remaining().includes(']')) {
                if (opts.nobracket !== true && opts.strictBrackets === true) {
                    throw new SyntaxError(syntaxError('closing', ']'));
                }
                value = `\\${value}`;
            } else {
                increment('brackets');
            }
            push({
                type: 'bracket',
                value
            });
            continue;
        }
        if (value === ']') {
            if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {
                push({
                    type: 'text',
                    value,
                    output: `\\${value}`
                });
                continue;
            }
            if (state.brackets === 0) {
                if (opts.strictBrackets === true) {
                    throw new SyntaxError(syntaxError('opening', '['));
                }
                push({
                    type: 'text',
                    value,
                    output: `\\${value}`
                });
                continue;
            }
            decrement('brackets');
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
                value = `/${value}`;
            }
            prev.value += value;
            append({
                value
            });
            // when literal brackets are explicitly disabled
            // assume we should match with a regex character class
            if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
                continue;
            }
            const escaped = utils.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            // when literal brackets are explicitly enabled
            // assume we should escape the brackets to match literal characters
            if (opts.literalBrackets === true) {
                state.output += escaped;
                prev.value = escaped;
                continue;
            }
            // when the user specifies nothing, try to match both
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
        }
        /**
     * Braces
     */ if (value === '{' && opts.nobrace !== true) {
            increment('braces');
            const open = {
                type: 'brace',
                value,
                output: '(',
                outputIndex: state.output.length,
                tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
        }
        if (value === '}') {
            const brace = braces[braces.length - 1];
            if (opts.nobrace === true || !brace) {
                push({
                    type: 'text',
                    value,
                    output: value
                });
                continue;
            }
            let output = ')';
            if (brace.dots === true) {
                const arr = tokens.slice();
                const range = [];
                for(let i = arr.length - 1; i >= 0; i--){
                    tokens.pop();
                    if (arr[i].type === 'brace') {
                        break;
                    }
                    if (arr[i].type !== 'dots') {
                        range.unshift(arr[i].value);
                    }
                }
                output = expandRange(range, opts);
                state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
                const out = state.output.slice(0, brace.outputIndex);
                const toks = state.tokens.slice(brace.tokensIndex);
                brace.value = brace.output = '\\{';
                value = output = '\\}';
                state.output = out;
                for (const t of toks){
                    state.output += t.output || t.value;
                }
            }
            push({
                type: 'brace',
                value,
                output
            });
            decrement('braces');
            braces.pop();
            continue;
        }
        /**
     * Pipes
     */ if (value === '|') {
            if (extglobs.length > 0) {
                extglobs[extglobs.length - 1].conditions++;
            }
            push({
                type: 'text',
                value
            });
            continue;
        }
        /**
     * Commas
     */ if (value === ',') {
            let output = value;
            const brace = braces[braces.length - 1];
            if (brace && stack[stack.length - 1] === 'braces') {
                brace.comma = true;
                output = '|';
            }
            push({
                type: 'comma',
                value,
                output
            });
            continue;
        }
        /**
     * Slashes
     */ if (value === '/') {
            // if the beginning of the glob is "./", advance the start
            // to the current index, and don't add the "./" characters
            // to the state. This greatly simplifies lookbehinds when
            // checking for BOS characters like "!" and "." (not "./")
            if (prev.type === 'dot' && state.index === state.start + 1) {
                state.start = state.index + 1;
                state.consumed = '';
                state.output = '';
                tokens.pop();
                prev = bos; // reset "prev" to the first token
                continue;
            }
            push({
                type: 'slash',
                value,
                output: SLASH_LITERAL
            });
            continue;
        }
        /**
     * Dots
     */ if (value === '.') {
            if (state.braces > 0 && prev.type === 'dot') {
                if (prev.value === '.') prev.output = DOT_LITERAL;
                const brace = braces[braces.length - 1];
                prev.type = 'dots';
                prev.output += value;
                prev.value += value;
                brace.dots = true;
                continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
                push({
                    type: 'text',
                    value,
                    output: DOT_LITERAL
                });
                continue;
            }
            push({
                type: 'dot',
                value,
                output: DOT_LITERAL
            });
            continue;
        }
        /**
     * Question marks
     */ if (value === '?') {
            const isGroup = prev && prev.value === '(';
            if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
                extglobOpen('qmark', value);
                continue;
            }
            if (prev && prev.type === 'paren') {
                const next = peek();
                let output = value;
                if (next === '<' && !utils.supportsLookbehinds()) {
                    throw new Error('Node.js v10 or higher is required for regex lookbehinds');
                }
                if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\w+>)/.test(remaining())) {
                    output = `\\${value}`;
                }
                push({
                    type: 'text',
                    value,
                    output
                });
                continue;
            }
            if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
                push({
                    type: 'qmark',
                    value,
                    output: QMARK_NO_DOT
                });
                continue;
            }
            push({
                type: 'qmark',
                value,
                output: QMARK
            });
            continue;
        }
        /**
     * Exclamation
     */ if (value === '!') {
            if (opts.noextglob !== true && peek() === '(') {
                if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
                    extglobOpen('negate', value);
                    continue;
                }
            }
            if (opts.nonegate !== true && state.index === 0) {
                negate();
                continue;
            }
        }
        /**
     * Plus
     */ if (value === '+') {
            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
                extglobOpen('plus', value);
                continue;
            }
            if (prev && prev.value === '(' || opts.regex === false) {
                push({
                    type: 'plus',
                    value,
                    output: PLUS_LITERAL
                });
                continue;
            }
            if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {
                push({
                    type: 'plus',
                    value
                });
                continue;
            }
            push({
                type: 'plus',
                value: PLUS_LITERAL
            });
            continue;
        }
        /**
     * Plain text
     */ if (value === '@') {
            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
                push({
                    type: 'at',
                    extglob: true,
                    value,
                    output: ''
                });
                continue;
            }
            push({
                type: 'text',
                value
            });
            continue;
        }
        /**
     * Plain text
     */ if (value !== '*') {
            if (value === '$' || value === '^') {
                value = `\\${value}`;
            }
            const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match) {
                value += match[0];
                state.index += match[0].length;
            }
            push({
                type: 'text',
                value
            });
            continue;
        }
        /**
     * Stars
     */ if (prev && (prev.type === 'globstar' || prev.star === true)) {
            prev.type = 'star';
            prev.star = true;
            prev.value += value;
            prev.output = star;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen('star', value);
            continue;
        }
        if (prev.type === 'star') {
            if (opts.noglobstar === true) {
                consume(value);
                continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === 'slash' || prior.type === 'bos';
            const afterStar = before && (before.type === 'star' || before.type === 'globstar');
            if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {
                push({
                    type: 'star',
                    value,
                    output: ''
                });
                continue;
            }
            const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
            const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
            if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
                push({
                    type: 'star',
                    value,
                    output: ''
                });
                continue;
            }
            // strip consecutive `/**/`
            while(rest.slice(0, 3) === '/**'){
                const after = input[state.index + 4];
                if (after && after !== '/') {
                    break;
                }
                rest = rest.slice(3);
                consume('/**', 3);
            }
            if (prior.type === 'bos' && eos()) {
                prev.type = 'globstar';
                prev.value += value;
                prev.output = globstar(opts);
                state.output = prev.output;
                state.globstar = true;
                consume(value);
                continue;
            }
            if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
                state.output = state.output.slice(0, -(prior.output + prev.output).length);
                prior.output = `(?:${prior.output}`;
                prev.type = 'globstar';
                prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
                prev.value += value;
                state.globstar = true;
                state.output += prior.output + prev.output;
                consume(value);
                continue;
            }
            if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
                const end = rest[1] !== void 0 ? '|$' : '';
                state.output = state.output.slice(0, -(prior.output + prev.output).length);
                prior.output = `(?:${prior.output}`;
                prev.type = 'globstar';
                prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
                prev.value += value;
                state.output += prior.output + prev.output;
                state.globstar = true;
                consume(value + advance());
                push({
                    type: 'slash',
                    value: '/',
                    output: ''
                });
                continue;
            }
            if (prior.type === 'bos' && rest[0] === '/') {
                prev.type = 'globstar';
                prev.value += value;
                prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
                state.output = prev.output;
                state.globstar = true;
                consume(value + advance());
                push({
                    type: 'slash',
                    value: '/',
                    output: ''
                });
                continue;
            }
            // remove single star from output
            state.output = state.output.slice(0, -prev.output.length);
            // reset previous token to globstar
            prev.type = 'globstar';
            prev.output = globstar(opts);
            prev.value += value;
            // reset output with globstar
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
        }
        const token = {
            type: 'star',
            value,
            output: star
        };
        if (opts.bash === true) {
            token.output = '.*?';
            if (prev.type === 'bos' || prev.type === 'slash') {
                token.output = nodot + token.output;
            }
            push(token);
            continue;
        }
        if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
        }
        if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
            if (prev.type === 'dot') {
                state.output += NO_DOT_SLASH;
                prev.output += NO_DOT_SLASH;
            } else if (opts.dot === true) {
                state.output += NO_DOTS_SLASH;
                prev.output += NO_DOTS_SLASH;
            } else {
                state.output += nodot;
                prev.output += nodot;
            }
            if (peek() !== '*') {
                state.output += ONE_CHAR;
                prev.output += ONE_CHAR;
            }
        }
        push(token);
    }
    while(state.brackets > 0){
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
        state.output = utils.escapeLast(state.output, '[');
        decrement('brackets');
    }
    while(state.parens > 0){
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
        state.output = utils.escapeLast(state.output, '(');
        decrement('parens');
    }
    while(state.braces > 0){
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
        state.output = utils.escapeLast(state.output, '{');
        decrement('braces');
    }
    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
        push({
            type: 'maybe_slash',
            value: '',
            output: `${SLASH_LITERAL}?`
        });
    }
    // rebuild the output if we had to backtrack at any point
    if (state.backtrack === true) {
        state.output = '';
        for (const token of state.tokens){
            state.output += token.output != null ? token.output : token.value;
            if (token.suffix) {
                state.output += token.suffix;
            }
        }
    }
    return state;
};
/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */ parse.fastpaths = (input, options)=>{
    const opts = {
        ...options
    };
    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;
    if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    input = REPLACEMENTS[input] || input;
    const win32 = utils.isWindows(options);
    // create constants based on platform, for windows or posix
    const { DOT_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOTS_SLASH, STAR, START_ANCHOR } = constants.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? '' : '?:';
    const state = {
        negated: false,
        prefix: ''
    };
    let star = opts.bash === true ? '.*?' : STAR;
    if (opts.capture) {
        star = `(${star})`;
    }
    const globstar = (opts)=>{
        if (opts.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create = (str)=>{
        switch(str){
            case '*':
                return `${nodot}${ONE_CHAR}${star}`;
            case '.*':
                return `${DOT_LITERAL}${ONE_CHAR}${star}`;
            case '*.*':
                return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case '*/*':
                return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
            case '**':
                return nodot + globstar(opts);
            case '**/*':
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
            case '**/*.*':
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case '**/.*':
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
            default:
                {
                    const match = /^(.*?)\.(\w+)$/.exec(str);
                    if (!match) return;
                    const source = create(match[1]);
                    if (!source) return;
                    return source + DOT_LITERAL + match[2];
                }
        }
    };
    const output = utils.removePrefix(input, state);
    let source = create(output);
    if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
    }
    return source;
};
module.exports = parse;
}}),
"[project]/node_modules/picomatch/lib/picomatch.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const scan = __turbopack_context__.r("[project]/node_modules/picomatch/lib/scan.js [app-route] (ecmascript)");
const parse = __turbopack_context__.r("[project]/node_modules/picomatch/lib/parse.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/picomatch/lib/utils.js [app-route] (ecmascript)");
const constants = __turbopack_context__.r("[project]/node_modules/picomatch/lib/constants.js [app-route] (ecmascript)");
const isObject = (val)=>val && typeof val === 'object' && !Array.isArray(val);
/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */ const picomatch = (glob, options, returnState = false)=>{
    if (Array.isArray(glob)) {
        const fns = glob.map((input)=>picomatch(input, options, returnState));
        const arrayMatcher = (str)=>{
            for (const isMatch of fns){
                const state = isMatch(str);
                if (state) return state;
            }
            return false;
        };
        return arrayMatcher;
    }
    const isState = isObject(glob) && glob.tokens && glob.input;
    if (glob === '' || typeof glob !== 'string' && !isState) {
        throw new TypeError('Expected pattern to be a non-empty string');
    }
    const opts = options || {};
    const posix = utils.isWindows(options);
    const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = ()=>false;
    if (opts.ignore) {
        const ignoreOpts = {
            ...options,
            ignore: null,
            onMatch: null,
            onResult: null
        };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false)=>{
        const { isMatch, match, output } = picomatch.test(input, regex, options, {
            glob,
            posix
        });
        const result = {
            glob,
            state,
            regex,
            posix,
            input,
            output,
            match,
            isMatch
        };
        if (typeof opts.onResult === 'function') {
            opts.onResult(result);
        }
        if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
        }
        if (isIgnored(input)) {
            if (typeof opts.onIgnore === 'function') {
                opts.onIgnore(result);
            }
            result.isMatch = false;
            return returnObject ? result : false;
        }
        if (typeof opts.onMatch === 'function') {
            opts.onMatch(result);
        }
        return returnObject ? result : true;
    };
    if (returnState) {
        matcher.state = state;
    }
    return matcher;
};
/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */ picomatch.test = (input, regex, options, { glob, posix } = {})=>{
    if (typeof input !== 'string') {
        throw new TypeError('Expected input to be a string');
    }
    if (input === '') {
        return {
            isMatch: false,
            output: ''
        };
    }
    const opts = options || {};
    const format = opts.format || (posix ? utils.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format ? format(input) : input;
    if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
    }
    if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
            match = picomatch.matchBase(input, regex, options, posix);
        } else {
            match = regex.exec(output);
        }
    }
    return {
        isMatch: Boolean(match),
        match,
        output
    };
};
/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */ picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options))=>{
    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
    return regex.test(path.basename(input));
};
/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */ picomatch.isMatch = (str, patterns, options)=>picomatch(patterns, options)(str);
/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */ picomatch.parse = (pattern, options)=>{
    if (Array.isArray(pattern)) return pattern.map((p)=>picomatch.parse(p, options));
    return parse(pattern, {
        ...options,
        fastpaths: false
    });
};
/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */ picomatch.scan = (input, options)=>scan(input, options);
/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */ picomatch.compileRe = (state, options, returnOutput = false, returnState = false)=>{
    if (returnOutput === true) {
        return state.output;
    }
    const opts = options || {};
    const prepend = opts.contains ? '' : '^';
    const append = opts.contains ? '' : '$';
    let source = `${prepend}(?:${state.output})${append}`;
    if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
    }
    const regex = picomatch.toRegex(source, options);
    if (returnState === true) {
        regex.state = state;
    }
    return regex;
};
/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */ picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false)=>{
    if (!input || typeof input !== 'string') {
        throw new TypeError('Expected a non-empty string');
    }
    let parsed = {
        negated: false,
        fastpaths: true
    };
    if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
        parsed.output = parse.fastpaths(input, options);
    }
    if (!parsed.output) {
        parsed = parse(input, options);
    }
    return picomatch.compileRe(parsed, options, returnOutput, returnState);
};
/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */ picomatch.toRegex = (source, options)=>{
    try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
    } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
    }
};
/**
 * Picomatch constants.
 * @return {Object}
 */ picomatch.constants = constants;
/**
 * Expose "picomatch"
 */ module.exports = picomatch;
}}),
"[project]/node_modules/picomatch/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = __turbopack_context__.r("[project]/node_modules/picomatch/lib/picomatch.js [app-route] (ecmascript)");
}}),
"[project]/node_modules/micromatch/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const braces = __turbopack_context__.r("[project]/node_modules/braces/index.js [app-route] (ecmascript)");
const picomatch = __turbopack_context__.r("[project]/node_modules/picomatch/index.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/picomatch/lib/utils.js [app-route] (ecmascript)");
const isEmptyString = (v)=>v === '' || v === './';
const hasBraces = (v)=>{
    const index = v.indexOf('{');
    return index > -1 && v.indexOf('}', index) > -1;
};
/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} `list` List of strings to match.
 * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */ const micromatch = (list, patterns, options)=>{
    patterns = [].concat(patterns);
    list = [].concat(list);
    let omit = new Set();
    let keep = new Set();
    let items = new Set();
    let negatives = 0;
    let onResult = (state)=>{
        items.add(state.output);
        if (options && options.onResult) {
            options.onResult(state);
        }
    };
    for(let i = 0; i < patterns.length; i++){
        let isMatch = picomatch(String(patterns[i]), {
            ...options,
            onResult
        }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated) negatives++;
        for (let item of list){
            let matched = isMatch(item, true);
            let match = negated ? !matched.isMatch : matched.isMatch;
            if (!match) continue;
            if (negated) {
                omit.add(matched.output);
            } else {
                omit.delete(matched.output);
                keep.add(matched.output);
            }
        }
    }
    let result = negatives === patterns.length ? [
        ...items
    ] : [
        ...keep
    ];
    let matches = result.filter((item)=>!omit.has(item));
    if (options && matches.length === 0) {
        if (options.failglob === true) {
            throw new Error(`No matches found for "${patterns.join(', ')}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
            return options.unescape ? patterns.map((p)=>p.replace(/\\/g, '')) : patterns;
        }
    }
    return matches;
};
/**
 * Backwards compatibility
 */ micromatch.match = micromatch;
/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */ micromatch.matcher = (pattern, options)=>picomatch(pattern, options);
/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `[options]` See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */ micromatch.isMatch = (str, patterns, options)=>picomatch(patterns, options)(str);
/**
 * Backwards compatibility
 */ micromatch.any = micromatch.isMatch;
/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */ micromatch.not = (list, patterns, options = {})=>{
    patterns = [].concat(patterns).map(String);
    let result = new Set();
    let items = [];
    let onResult = (state)=>{
        if (options.onResult) options.onResult(state);
        items.push(state.output);
    };
    let matches = new Set(micromatch(list, patterns, {
        ...options,
        onResult
    }));
    for (let item of items){
        if (!matches.has(item)) {
            result.add(item);
        }
    }
    return [
        ...result
    ];
};
/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any of the patterns matches any part of `str`.
 * @api public
 */ micromatch.contains = (str, pattern, options)=>{
    if (typeof str !== 'string') {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
    }
    if (Array.isArray(pattern)) {
        return pattern.some((p)=>micromatch.contains(str, p, options));
    }
    if (typeof pattern === 'string') {
        if (isEmptyString(str) || isEmptyString(pattern)) {
            return false;
        }
        if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {
            return true;
        }
    }
    return micromatch.isMatch(str, pattern, {
        ...options,
        contains: true
    });
};
/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */ micromatch.matchKeys = (obj, patterns, options)=>{
    if (!utils.isObject(obj)) {
        throw new TypeError('Expected the first argument to be an object');
    }
    let keys = micromatch(Object.keys(obj), patterns, options);
    let res = {};
    for (let key of keys)res[key] = obj[key];
    return res;
};
/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`
 * @api public
 */ micromatch.some = (list, patterns, options)=>{
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)){
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item)=>isMatch(item))) {
            return true;
        }
    }
    return false;
};
/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`
 * @api public
 */ micromatch.every = (list, patterns, options)=>{
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)){
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item)=>isMatch(item))) {
            return false;
        }
    }
    return true;
};
/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */ micromatch.all = (str, patterns, options)=>{
    if (typeof str !== 'string') {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
    }
    return [].concat(patterns).every((p)=>picomatch(p, options)(str));
};
/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */ micromatch.capture = (glob, input, options)=>{
    let posix = utils.isWindows(options);
    let regex = picomatch.makeRe(String(glob), {
        ...options,
        capture: true
    });
    let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
    if (match) {
        return match.slice(1).map((v)=>v === void 0 ? '' : v);
    }
};
/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */ micromatch.makeRe = (...args)=>picomatch.makeRe(...args);
/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */ micromatch.scan = (...args)=>picomatch.scan(...args);
/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.parse(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */ micromatch.parse = (patterns, options)=>{
    let res = [];
    for (let pattern of [].concat(patterns || [])){
        for (let str of braces(String(pattern), options)){
            res.push(picomatch.parse(str, options));
        }
    }
    return res;
};
/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */ micromatch.braces = (pattern, options)=>{
    if (typeof pattern !== 'string') throw new TypeError('Expected a string');
    if (options && options.nobrace === true || !hasBraces(pattern)) {
        return [
            pattern
        ];
    }
    return braces(pattern, options);
};
/**
 * Expand braces
 */ micromatch.braceExpand = (pattern, options)=>{
    if (typeof pattern !== 'string') throw new TypeError('Expected a string');
    return micromatch.braces(pattern, {
        ...options,
        expand: true
    });
};
/**
 * Expose micromatch
 */ // exposed for tests
micromatch.hasBraces = hasBraces;
module.exports = micromatch;
}}),
"[project]/node_modules/normalize-path/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */ module.exports = function(path, stripTrailing) {
    if (typeof path !== 'string') {
        throw new TypeError('expected path to be a string');
    }
    if (path === '\\' || path === '/') return '/';
    var len = path.length;
    if (len <= 1) return path;
    // ensure that win32 namespaces has two leading slashes, so that the path is
    // handled properly by the win32 version of path.parse() after being normalized
    // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces
    var prefix = '';
    if (len > 4 && path[3] === '\\') {
        var ch = path[2];
        if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
            path = path.slice(2);
            prefix = '//';
        }
    }
    var segs = path.split(/[/\\]+/);
    if (stripTrailing !== false && segs[segs.length - 1] === '') {
        segs.pop();
    }
    return prefix + segs.join('/');
};
}}),
"[project]/node_modules/ini/ini.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
exports.parse = exports.decode = decode;
exports.stringify = exports.encode = encode;
exports.safe = safe;
exports.unsafe = unsafe;
var eol = ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : '\n';
function encode(obj, opt) {
    var children = [];
    var out = '';
    if (typeof opt === 'string') {
        opt = {
            section: opt,
            whitespace: false
        };
    } else {
        opt = opt || {};
        opt.whitespace = opt.whitespace === true;
    }
    var separator = opt.whitespace ? ' = ' : '=';
    Object.keys(obj).forEach(function(k, _, __) {
        var val = obj[k];
        if (val && Array.isArray(val)) {
            val.forEach(function(item) {
                out += safe(k + '[]') + separator + safe(item) + '\n';
            });
        } else if (val && typeof val === 'object') children.push(k);
        else out += safe(k) + separator + safe(val) + eol;
    });
    if (opt.section && out.length) out = '[' + safe(opt.section) + ']' + eol + out;
    children.forEach(function(k, _, __) {
        var nk = dotSplit(k).join('\\.');
        var section = (opt.section ? opt.section + '.' : '') + nk;
        var child = encode(obj[k], {
            section: section,
            whitespace: opt.whitespace
        });
        if (out.length && child.length) out += eol;
        out += child;
    });
    return out;
}
function dotSplit(str) {
    return str.replace(/\1/g, '\u0002LITERAL\\1LITERAL\u0002').replace(/\\\./g, '\u0001').split(/\./).map(function(part) {
        return part.replace(/\1/g, '\\.').replace(/\2LITERAL\\1LITERAL\2/g, '\u0001');
    });
}
function decode(str) {
    var out = {};
    var p = out;
    var section = null;
    //          section     |key      = value
    var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
    var lines = str.split(/[\r\n]+/g);
    lines.forEach(function(line, _, __) {
        if (!line || line.match(/^\s*[;#]/)) return;
        var match = line.match(re);
        if (!match) return;
        if (match[1] !== undefined) {
            section = unsafe(match[1]);
            if (section === '__proto__') {
                // not allowed
                // keep parsing the section, but don't attach it.
                p = {};
                return;
            }
            p = out[section] = out[section] || {};
            return;
        }
        var key = unsafe(match[2]);
        if (key === '__proto__') return;
        var value = match[3] ? unsafe(match[4]) : true;
        switch(value){
            case 'true':
            case 'false':
            case 'null':
                value = JSON.parse(value);
        }
        // Convert keys with '[]' suffix to an array
        if (key.length > 2 && key.slice(-2) === '[]') {
            key = key.substring(0, key.length - 2);
            if (key === '__proto__') return;
            if (!p[key]) p[key] = [];
            else if (!Array.isArray(p[key])) p[key] = [
                p[key]
            ];
        }
        // safeguard against resetting a previously defined
        // array by accidentally forgetting the brackets
        if (Array.isArray(p[key])) p[key].push(value);
        else p[key] = value;
    });
    // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
    // use a filter to return the keys that have to be deleted.
    Object.keys(out).filter(function(k, _, __) {
        if (!out[k] || typeof out[k] !== 'object' || Array.isArray(out[k])) return false;
        // see if the parent section is also an object.
        // if so, add it to that, and mark this one for deletion
        var parts = dotSplit(k);
        var p = out;
        var l = parts.pop();
        var nl = l.replace(/\\\./g, '.');
        parts.forEach(function(part, _, __) {
            if (part === '__proto__') return;
            if (!p[part] || typeof p[part] !== 'object') p[part] = {};
            p = p[part];
        });
        if (p === out && nl === l) return false;
        p[nl] = out[k];
        return true;
    }).forEach(function(del, _, __) {
        delete out[del];
    });
    return out;
}
function isQuoted(val) {
    return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
}
function safe(val) {
    return typeof val !== 'string' || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, '\\;').replace(/#/g, '\\#');
}
function unsafe(val, doUnesc) {
    val = (val || '').trim();
    if (isQuoted(val)) {
        // remove the single quotes before calling JSON.parse
        if (val.charAt(0) === "'") val = val.substr(1, val.length - 2);
        try {
            val = JSON.parse(val);
        } catch (_) {}
    } else {
        // walk the val to find the first not-escaped ; character
        var esc = false;
        var unesc = '';
        for(var i = 0, l = val.length; i < l; i++){
            var c = val.charAt(i);
            if (esc) {
                if ('\\;#'.indexOf(c) !== -1) unesc += c;
                else unesc += '\\' + c;
                esc = false;
            } else if (';#'.indexOf(c) !== -1) break;
            else if (c === '\\') esc = true;
            else unesc += c;
        }
        if (esc) unesc += '\\';
        return unesc.trim();
    }
    return val;
}
}}),
"[project]/node_modules/isexe/mode.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = isexe;
isexe.sync = sync;
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
    });
}
function sync(path, options) {
    return checkStat(fs.statSync(path), options);
}
function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
}
function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
    var u = parseInt('100', 8);
    var g = parseInt('010', 8);
    var o = parseInt('001', 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
}
}}),
"[project]/node_modules/isexe/windows.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = isexe;
isexe.sync = sync;
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
function checkPathExt(path, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
        return true;
    }
    pathext = pathext.split(';');
    if (pathext.indexOf('') !== -1) {
        return true;
    }
    for(var i = 0; i < pathext.length; i++){
        var p = pathext[i].toLowerCase();
        if (p && path.substr(-p.length).toLowerCase() === p) {
            return true;
        }
    }
    return false;
}
function checkStat(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
    }
    return checkPathExt(path, options);
}
function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path, options));
    });
}
function sync(path, options) {
    return checkStat(fs.statSync(path), path, options);
}
}}),
"[project]/node_modules/isexe/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var core;
if (process.platform === 'win32' || global.TESTING_WINDOWS) {
    core = __turbopack_context__.r("[project]/node_modules/isexe/windows.js [app-route] (ecmascript)");
} else {
    core = __turbopack_context__.r("[project]/node_modules/isexe/mode.js [app-route] (ecmascript)");
}
module.exports = isexe;
isexe.sync = sync;
function isexe(path, options, cb) {
    if (typeof options === 'function') {
        cb = options;
        options = {};
    }
    if (!cb) {
        if (typeof Promise !== 'function') {
            throw new TypeError('callback not provided');
        }
        return new Promise(function(resolve, reject) {
            isexe(path, options || {}, function(er, is) {
                if (er) {
                    reject(er);
                } else {
                    resolve(is);
                }
            });
        });
    }
    core(path, options || {}, function(er, is) {
        // ignore EACCES because that just means we aren't allowed to run it
        if (er) {
            if (er.code === 'EACCES' || options && options.ignoreErrors) {
                er = null;
                is = false;
            }
        }
        cb(er, is);
    });
}
function sync(path, options) {
    // my kingdom for a filtered catch
    try {
        return core.sync(path, options || {});
    } catch (er) {
        if (options && options.ignoreErrors || er.code === 'EACCES') {
            return false;
        } else {
            throw er;
        }
    }
}
}}),
"[project]/node_modules/global-prefix/node_modules/which/which.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = which;
which.sync = whichSync;
var isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';
var path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
var COLON = isWindows ? ';' : ':';
var isexe = __turbopack_context__.r("[project]/node_modules/isexe/index.js [app-route] (ecmascript)");
function getNotFoundError(cmd) {
    var er = new Error('not found: ' + cmd);
    er.code = 'ENOENT';
    return er;
}
function getPathInfo(cmd, opt) {
    var colon = opt.colon || COLON;
    var pathEnv = opt.path || process.env.PATH || '';
    var pathExt = [
        ''
    ];
    pathEnv = pathEnv.split(colon);
    var pathExtExe = '';
    if (isWindows) {
        pathEnv.unshift(process.cwd());
        pathExtExe = opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM';
        pathExt = pathExtExe.split(colon);
        // Always test the cmd itself first.  isexe will check to make sure
        // it's found in the pathExt set.
        if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');
    }
    // If it has a slash, then we don't bother searching the pathenv.
    // just check the file itself, and that's it.
    if (cmd.match(/\//) || isWindows && cmd.match(/\\/)) pathEnv = [
        ''
    ];
    return {
        env: pathEnv,
        ext: pathExt,
        extExe: pathExtExe
    };
}
function which(cmd, opt, cb) {
    if (typeof opt === 'function') {
        cb = opt;
        opt = {};
    }
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];
    (function F(i, l) {
        if (i === l) {
            if (opt.all && found.length) return cb(null, found);
            else return cb(getNotFoundError(cmd));
        }
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"') pathPart = pathPart.slice(1, -1);
        var p = path.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
            p = cmd.slice(0, 2) + p;
        }
        ;
        (function E(ii, ll) {
            if (ii === ll) return F(i + 1, l);
            var ext = pathExt[ii];
            isexe(p + ext, {
                pathExt: pathExtExe
            }, function(er, is) {
                if (!er && is) {
                    if (opt.all) found.push(p + ext);
                    else return cb(null, p + ext);
                }
                return E(ii + 1, ll);
            });
        })(0, pathExt.length);
    })(0, pathEnv.length);
}
function whichSync(cmd, opt) {
    opt = opt || {};
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];
    for(var i = 0, l = pathEnv.length; i < l; i++){
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"') pathPart = pathPart.slice(1, -1);
        var p = path.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
            p = cmd.slice(0, 2) + p;
        }
        for(var j = 0, ll = pathExt.length; j < ll; j++){
            var cur = p + pathExt[j];
            var is;
            try {
                is = isexe.sync(cur, {
                    pathExt: pathExtExe
                });
                if (is) {
                    if (opt.all) found.push(cur);
                    else return cur;
                }
            } catch (ex) {}
        }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw getNotFoundError(cmd);
}
}}),
"[project]/node_modules/global-prefix/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * global-prefix <https://github.com/jonschlinkert/global-prefix>
 *
 * Copyright (c) 2015-present Jon Schlinkert.
 * Licensed under the MIT license.
 */ 'use strict';
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const ini = __turbopack_context__.r("[project]/node_modules/ini/ini.js [app-route] (ecmascript)");
let prefix;
const getPrefix = ()=>{
    if (process.env.PREFIX) return process.env.PREFIX;
    if (prefix) return prefix;
    // Start by checking if the global prefix is set by the user
    let home = os.homedir();
    // os.homedir() returns undefined if $HOME is not set; path.resolve requires strings
    if (home) {
        prefix = tryConfigPath(path.resolve(home, '.npmrc'));
    }
    if (prefix) {
        return prefix;
    }
    // Otherwise find the path of npm
    let npm = tryNpmPath();
    if (npm) {
        // Check the built-in npm config file
        prefix = tryConfigPath(path.resolve(npm, '..', '..', 'npmrc'));
        if (prefix) {
            // Now the global npm config can also be checked.
            prefix = tryConfigPath(path.resolve(prefix, 'etc', 'npmrc')) || prefix;
        }
    }
    if (!prefix) {
        let { APPDATA, DESTDIR, OSTYPE } = process.env;
        // c:\node\node.exe --> prefix=c:\node\
        if (process.platform === 'win32' || OSTYPE === 'msys' || OSTYPE === 'cygwin') {
            prefix = APPDATA ? path.join(APPDATA, 'npm') : path.dirname(process.execPath);
            return prefix;
        }
        // /usr/local/bin/node --> prefix=/usr/local
        prefix = path.dirname(path.dirname(process.execPath));
        // destdir only is respected on Unix
        if (DESTDIR) {
            prefix = path.join(DESTDIR, prefix);
        }
    }
    return prefix;
};
function tryNpmPath() {
    try {
        return fs.realpathSync(__turbopack_context__.r("[project]/node_modules/global-prefix/node_modules/which/which.js [app-route] (ecmascript)").sync('npm'));
    } catch (err) {}
}
function tryConfigPath(configPath) {
    try {
        return ini.parse(fs.readFileSync(configPath, 'utf-8')).prefix;
    } catch (err) {}
}
/**
 * Expose `prefix`
 */ Reflect.defineProperty(module, 'exports', {
    get () {
        return getPrefix();
    }
});
}}),
"[project]/node_modules/global-modules/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * global-modules <https://github.com/jonschlinkert/global-modules>
 *
 * Copyright (c) 2015-2017 Jon Schlinkert.
 * Licensed under the MIT license.
 */ 'use strict';
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const prefix = __turbopack_context__.r("[project]/node_modules/global-prefix/index.js [app-route] (ecmascript)");
let gm;
function getPath() {
    if (process.platform === 'win32' || process.env.OSTYPE === 'msys' || process.env.OSTYPE === 'cygwin') {
        return path.resolve(prefix, 'node_modules');
    }
    return path.resolve(prefix, 'lib/node_modules');
}
/**
 * Expose `global-modules` path
 */ Reflect.defineProperty(module, 'exports', {
    get () {
        return gm || (gm = getPath());
    }
});
}}),
"[project]/node_modules/@dual-bundle/import-meta-resolve/lib/errors.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @typedef ErrnoExceptionFields
 * @property {number | undefined} [errnode]
 * @property {string | undefined} [code]
 * @property {string | undefined} [path]
 * @property {string | undefined} [syscall]
 * @property {string | undefined} [url]
 *
 * @typedef {Error & ErrnoExceptionFields} ErrnoException
 */ /**
 * @typedef {(...parameters: Array<any>) => string} MessageFunction
 */ // Manually “tree shaken” from:
// <https://github.com/nodejs/node/blob/45f5c9b/lib/internal/errors.js>
// Last checked on: Apr 29, 2024.
__turbopack_context__.s({
    "codes": (()=>codes)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$v8__$5b$external$5d$__$28$node$3a$v8$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:v8 [external] (node:v8, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:assert [external] (node:assert, cjs)");
// Needed for types.
// eslint-disable-next-line no-unused-vars
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:url [external] (node:url, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
;
;
;
;
const own = {}.hasOwnProperty;
const classRegExp = /^([A-Z][a-z\d]*)+$/;
// Sorted by a rough estimate on most frequently used entries.
const kTypes = new Set([
    'string',
    'function',
    'number',
    'object',
    // Accept 'Function' and 'Object' as alternative to the lower cased version.
    'Function',
    'Object',
    'boolean',
    'bigint',
    'symbol'
]);
const codes = {};
/**
 * Create a list string in the form like 'A and B' or 'A, B, ..., and Z'.
 * We cannot use Intl.ListFormat because it's not available in
 * --without-intl builds.
 *
 * @param {Array<string>} array
 *   An array of strings.
 * @param {string} [type]
 *   The list type to be inserted before the last element.
 * @returns {string}
 */ function formatList(array, type = 'and') {
    return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(', ')}, ${type} ${array[array.length - 1]}`;
}
/** @type {Map<string, MessageFunction | string>} */ const messages = new Map();
const nodeInternalPrefix = '__node_internal_';
/** @type {number} */ let userStackTraceLimit;
codes.ERR_INVALID_ARG_TYPE = createError('ERR_INVALID_ARG_TYPE', /**
   * @param {string} name
   * @param {Array<string> | string} expected
   * @param {unknown} actual
   */ (name, expected, actual)=>{
    (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__["default"])(typeof name === 'string', "'name' must be a string");
    if (!Array.isArray(expected)) {
        expected = [
            expected
        ];
    }
    let message = 'The ';
    if (name.endsWith(' argument')) {
        // For cases like 'first argument'
        message += `${name} `;
    } else {
        const type = name.includes('.') ? 'property' : 'argument';
        message += `"${name}" ${type} `;
    }
    message += 'must be ';
    /** @type {Array<string>} */ const types = [];
    /** @type {Array<string>} */ const instances = [];
    /** @type {Array<string>} */ const other = [];
    for (const value of expected){
        (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__["default"])(typeof value === 'string', 'All expected entries have to be of type string');
        if (kTypes.has(value)) {
            types.push(value.toLowerCase());
        } else if (classRegExp.exec(value) === null) {
            (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__["default"])(value !== 'object', 'The value "object" should be written as "Object"');
            other.push(value);
        } else {
            instances.push(value);
        }
    }
    // Special handle `object` in case other instances are allowed to outline
    // the differences between each other.
    if (instances.length > 0) {
        const pos = types.indexOf('object');
        if (pos !== -1) {
            types.slice(pos, 1);
            instances.push('Object');
        }
    }
    if (types.length > 0) {
        message += `${types.length > 1 ? 'one of type' : 'of type'} ${formatList(types, 'or')}`;
        if (instances.length > 0 || other.length > 0) message += ' or ';
    }
    if (instances.length > 0) {
        message += `an instance of ${formatList(instances, 'or')}`;
        if (other.length > 0) message += ' or ';
    }
    if (other.length > 0) {
        if (other.length > 1) {
            message += `one of ${formatList(other, 'or')}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) message += 'an ';
            message += `${other[0]}`;
        }
    }
    message += `. Received ${determineSpecificType(actual)}`;
    return message;
}, TypeError);
codes.ERR_INVALID_MODULE_SPECIFIER = createError('ERR_INVALID_MODULE_SPECIFIER', /**
   * @param {string} request
   * @param {string} reason
   * @param {string} [base]
   */ (request, reason, base = undefined)=>{
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ''}`;
}, TypeError);
codes.ERR_INVALID_PACKAGE_CONFIG = createError('ERR_INVALID_PACKAGE_CONFIG', /**
   * @param {string} path
   * @param {string} [base]
   * @param {string} [message]
   */ (path, base, message)=>{
    return `Invalid package config ${path}${base ? ` while importing ${base}` : ''}${message ? `. ${message}` : ''}`;
}, Error);
codes.ERR_INVALID_PACKAGE_TARGET = createError('ERR_INVALID_PACKAGE_TARGET', /**
   * @param {string} packagePath
   * @param {string} key
   * @param {unknown} target
   * @param {boolean} [isImport=false]
   * @param {string} [base]
   */ (packagePath, key, target, isImport = false, base = undefined)=>{
    const relatedError = typeof target === 'string' && !isImport && target.length > 0 && !target.startsWith('./');
    if (key === '.') {
        (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__["default"])(isImport === false);
        return `Invalid "exports" main target ${JSON.stringify(target)} defined ` + `in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ''}${relatedError ? '; targets must start with "./"' : ''}`;
    }
    return `Invalid "${isImport ? 'imports' : 'exports'}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ''}${relatedError ? '; targets must start with "./"' : ''}`;
}, Error);
codes.ERR_MODULE_NOT_FOUND = createError('ERR_MODULE_NOT_FOUND', /**
   * @param {string} path
   * @param {string} base
   * @param {boolean} [exactUrl]
   */ (path, base, exactUrl = false)=>{
    return `Cannot find ${exactUrl ? 'module' : 'package'} '${path}' imported from ${base}`;
}, Error);
codes.ERR_NETWORK_IMPORT_DISALLOWED = createError('ERR_NETWORK_IMPORT_DISALLOWED', "import of '%s' by %s is not supported: %s", Error);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError('ERR_PACKAGE_IMPORT_NOT_DEFINED', /**
   * @param {string} specifier
   * @param {string} packagePath
   * @param {string} base
   */ (specifier, packagePath, base)=>{
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ''} imported from ${base}`;
}, TypeError);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError('ERR_PACKAGE_PATH_NOT_EXPORTED', /**
   * @param {string} packagePath
   * @param {string} subpath
   * @param {string} [base]
   */ (packagePath, subpath, base = undefined)=>{
    if (subpath === '.') return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ''}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ''}`;
}, Error);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError('ERR_UNSUPPORTED_DIR_IMPORT', "Directory import '%s' is not supported " + 'resolving ES modules imported from %s', Error);
codes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError('ERR_UNSUPPORTED_RESOLVE_REQUEST', 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError('ERR_UNKNOWN_FILE_EXTENSION', /**
   * @param {string} extension
   * @param {string} path
   */ (extension, path)=>{
    return `Unknown file extension "${extension}" for ${path}`;
}, TypeError);
codes.ERR_INVALID_ARG_VALUE = createError('ERR_INVALID_ARG_VALUE', /**
   * @param {string} name
   * @param {unknown} value
   * @param {string} [reason='is invalid']
   */ (name, value, reason = 'is invalid')=>{
    let inspected = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["inspect"])(value);
    if (inspected.length > 128) {
        inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name.includes('.') ? 'property' : 'argument';
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
}, TypeError);
/**
 * Utility function for registering the error codes. Only used here. Exported
 * *only* to allow for testing.
 * @param {string} sym
 * @param {MessageFunction | string} value
 * @param {ErrorConstructor} constructor
 * @returns {new (...parameters: Array<any>) => Error}
 */ function createError(sym, value, constructor) {
    // Special case for SystemError that formats the error message differently
    // The SystemErrors only have SystemError as their base classes.
    messages.set(sym, value);
    return makeNodeErrorWithCode(constructor, sym);
}
/**
 * @param {ErrorConstructor} Base
 * @param {string} key
 * @returns {ErrorConstructor}
 */ function makeNodeErrorWithCode(Base, key) {
    // @ts-expect-error It’s a Node error.
    return NodeError;
    "TURBOPACK unreachable";
    /**
   * @param {Array<unknown>} parameters
   */ function NodeError(...parameters) {
        const limit = Error.stackTraceLimit;
        if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
        const error = new Base();
        // Reset the limit and setting the name property.
        if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
        const message = getMessage(key, parameters, error);
        Object.defineProperties(error, {
            // Note: no need to implement `kIsNodeError` symbol, would be hard,
            // probably.
            message: {
                value: message,
                enumerable: false,
                writable: true,
                configurable: true
            },
            toString: {
                /** @this {Error} */ value () {
                    return `${this.name} [${key}]: ${this.message}`;
                },
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        captureLargerStackTrace(error);
        // @ts-expect-error It’s a Node error.
        error.code = key;
        return error;
    }
}
/**
 * @returns {boolean}
 */ function isErrorStackTraceLimitWritable() {
    // Do no touch Error.stackTraceLimit as V8 would attempt to install
    // it again during deserialization.
    try {
        if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$v8__$5b$external$5d$__$28$node$3a$v8$2c$__cjs$29$__["default"].startupSnapshot.isBuildingSnapshot()) {
            return false;
        }
    } catch  {}
    const desc = Object.getOwnPropertyDescriptor(Error, 'stackTraceLimit');
    if (desc === undefined) {
        return Object.isExtensible(Error);
    }
    return own.call(desc, 'writable') && desc.writable !== undefined ? desc.writable : desc.set !== undefined;
}
/**
 * This function removes unnecessary frames from Node.js core errors.
 * @template {(...parameters: unknown[]) => unknown} T
 * @param {T} wrappedFunction
 * @returns {T}
 */ function hideStackFrames(wrappedFunction) {
    // We rename the functions that will be hidden to cut off the stacktrace
    // at the outermost one
    const hidden = nodeInternalPrefix + wrappedFunction.name;
    Object.defineProperty(wrappedFunction, 'name', {
        value: hidden
    });
    return wrappedFunction;
}
const captureLargerStackTrace = hideStackFrames(/**
   * @param {Error} error
   * @returns {Error}
   */ // @ts-expect-error: fine
function(error) {
    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
    if (stackTraceLimitIsWritable) {
        userStackTraceLimit = Error.stackTraceLimit;
        Error.stackTraceLimit = Number.POSITIVE_INFINITY;
    }
    Error.captureStackTrace(error);
    // Reset the limit
    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
    return error;
});
/**
 * @param {string} key
 * @param {Array<unknown>} parameters
 * @param {Error} self
 * @returns {string}
 */ function getMessage(key, parameters, self) {
    const message = messages.get(key);
    (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__["default"])(message !== undefined, 'expected `message` to be found');
    if (typeof message === 'function') {
        (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__["default"])(message.length <= parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not ` + `match the required ones (${message.length}).`);
        return Reflect.apply(message, self, parameters);
    }
    const regex = /%[dfijoOs]/g;
    let expectedLength = 0;
    while(regex.exec(message) !== null)expectedLength++;
    (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__["default"])(expectedLength === parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not ` + `match the required ones (${expectedLength}).`);
    if (parameters.length === 0) return message;
    parameters.unshift(message);
    return Reflect.apply(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["format"], null, parameters);
}
/**
 * Determine the specific type of a value for type-mismatch errors.
 * @param {unknown} value
 * @returns {string}
 */ function determineSpecificType(value) {
    if (value === null || value === undefined) {
        return String(value);
    }
    if (typeof value === 'function' && value.name) {
        return `function ${value.name}`;
    }
    if (typeof value === 'object') {
        if (value.constructor && value.constructor.name) {
            return `an instance of ${value.constructor.name}`;
        }
        return `${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["inspect"])(value, {
            depth: -1
        })}`;
    }
    let inspected = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["inspect"])(value, {
        colors: false
    });
    if (inspected.length > 28) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return `type ${typeof value} (${inspected})`;
}
}}),
"[project]/node_modules/@dual-bundle/import-meta-resolve/lib/package-json-reader.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Manually “tree shaken” from:
// <https://github.com/nodejs/node/blob/7c3dce0/lib/internal/modules/package_json_reader.js>
// Last checked on: Apr 29, 2024.
// Removed the native dependency.
// Also: no need to cache, we do that in resolve already.
/**
 * @typedef {import('./errors.js').ErrnoException} ErrnoException
 *
 * @typedef {'commonjs' | 'module' | 'none'} PackageType
 *
 * @typedef PackageConfig
 * @property {string} pjsonPath
 * @property {boolean} exists
 * @property {string | undefined} [main]
 * @property {string | undefined} [name]
 * @property {PackageType} type
 * @property {Record<string, unknown> | undefined} [exports]
 * @property {Record<string, unknown> | undefined} [imports]
 */ __turbopack_context__.s({
    "getPackageScopeConfig": (()=>getPackageScopeConfig),
    "getPackageType": (()=>getPackageType),
    "read": (()=>read)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:url [external] (node:url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dual-bundle/import-meta-resolve/lib/errors.js [app-route] (ecmascript)");
;
;
;
;
const hasOwnProperty = {}.hasOwnProperty;
const { ERR_INVALID_PACKAGE_CONFIG } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["codes"];
/** @type {Map<string, PackageConfig>} */ const cache = new Map();
function read(jsonPath, { base, specifier }) {
    const existing = cache.get(jsonPath);
    if (existing) {
        return existing;
    }
    /** @type {string | undefined} */ let string;
    try {
        string = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].readFileSync(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].toNamespacedPath(jsonPath), 'utf8');
    } catch (error) {
        const exception = error;
        if (exception.code !== 'ENOENT') {
            throw exception;
        }
    }
    /** @type {PackageConfig} */ const result = {
        exists: false,
        pjsonPath: jsonPath,
        main: undefined,
        name: undefined,
        type: 'none',
        exports: undefined,
        imports: undefined
    };
    if (string !== undefined) {
        /** @type {Record<string, unknown>} */ let parsed;
        try {
            parsed = JSON.parse(string);
        } catch (error_) {
            const cause = error_;
            const error = new ERR_INVALID_PACKAGE_CONFIG(jsonPath, (base ? `"${specifier}" from ` : '') + (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base || specifier), cause.message);
            error.cause = cause;
            throw error;
        }
        result.exists = true;
        if (hasOwnProperty.call(parsed, 'name') && typeof parsed.name === 'string') {
            result.name = parsed.name;
        }
        if (hasOwnProperty.call(parsed, 'main') && typeof parsed.main === 'string') {
            result.main = parsed.main;
        }
        if (hasOwnProperty.call(parsed, 'exports')) {
            // @ts-expect-error: assume valid.
            result.exports = parsed.exports;
        }
        if (hasOwnProperty.call(parsed, 'imports')) {
            // @ts-expect-error: assume valid.
            result.imports = parsed.imports;
        }
        // Ignore unknown types for forwards compatibility
        if (hasOwnProperty.call(parsed, 'type') && (parsed.type === 'commonjs' || parsed.type === 'module')) {
            result.type = parsed.type;
        }
    }
    cache.set(jsonPath, result);
    return result;
}
function getPackageScopeConfig(resolved) {
    // Note: in Node, this is now a native module.
    let packageJSONUrl = new URL('package.json', resolved);
    while(true){
        const packageJSONPath = packageJSONUrl.pathname;
        if (packageJSONPath.endsWith('node_modules/package.json')) {
            break;
        }
        const packageConfig = read((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(packageJSONUrl), {
            specifier: resolved
        });
        if (packageConfig.exists) {
            return packageConfig;
        }
        const lastPackageJSONUrl = packageJSONUrl;
        packageJSONUrl = new URL('../package.json', packageJSONUrl);
        // Terminates at root where ../package.json equals ../../package.json
        // (can't just check "/package.json" for Windows support).
        if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
            break;
        }
    }
    const packageJSONPath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(packageJSONUrl);
    // ^^ Note: in Node, this is now a native module.
    return {
        pjsonPath: packageJSONPath,
        exists: false,
        type: 'none'
    };
}
function getPackageType(url) {
    // To do @anonrig: Write a C++ function that returns only "type".
    return getPackageScopeConfig(url).type;
}
}}),
"[project]/node_modules/@dual-bundle/import-meta-resolve/lib/get-format.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Manually “tree shaken” from:
// <https://github.com/nodejs/node/blob/7c3dce0/lib/internal/modules/esm/get_format.js>
// Last checked on: Apr 29, 2024.
__turbopack_context__.s({
    "defaultGetFormatWithoutErrors": (()=>defaultGetFormatWithoutErrors)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:url [external] (node:url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$package$2d$json$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dual-bundle/import-meta-resolve/lib/package-json-reader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dual-bundle/import-meta-resolve/lib/errors.js [app-route] (ecmascript)");
;
;
;
const { ERR_UNKNOWN_FILE_EXTENSION } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["codes"];
const hasOwnProperty = {}.hasOwnProperty;
/** @type {Record<string, string>} */ const extensionFormatMap = {
    // @ts-expect-error: hush.
    __proto__: null,
    '.cjs': 'commonjs',
    '.js': 'module',
    '.json': 'json',
    '.mjs': 'module'
};
/**
 * @param {string | null} mime
 * @returns {string | null}
 */ function mimeToFormat(mime) {
    if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime)) return 'module';
    if (mime === 'application/json') return 'json';
    return null;
}
/**
 * @callback ProtocolHandler
 * @param {URL} parsed
 * @param {{parentURL: string, source?: Buffer}} context
 * @param {boolean} ignoreErrors
 * @returns {string | null | void}
 */ /**
 * @type {Record<string, ProtocolHandler>}
 */ const protocolHandlers = {
    // @ts-expect-error: hush.
    __proto__: null,
    'data:': getDataProtocolModuleFormat,
    'file:': getFileProtocolModuleFormat,
    'http:': getHttpProtocolModuleFormat,
    'https:': getHttpProtocolModuleFormat,
    'node:' () {
        return 'builtin';
    }
};
/**
 * @param {URL} parsed
 */ function getDataProtocolModuleFormat(parsed) {
    const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [
        null,
        null,
        null
    ];
    return mimeToFormat(mime);
}
/**
 * Returns the file extension from a URL.
 *
 * Should give similar result to
 * `require('node:path').extname(require('node:url').fileURLToPath(url))`
 * when used with a `file:` URL.
 *
 * @param {URL} url
 * @returns {string}
 */ function extname(url) {
    const pathname = url.pathname;
    let index = pathname.length;
    while(index--){
        const code = pathname.codePointAt(index);
        if (code === 47 /* `/` */ ) {
            return '';
        }
        if (code === 46 /* `.` */ ) {
            return pathname.codePointAt(index - 1) === 47 /* `/` */  ? '' : pathname.slice(index);
        }
    }
    return '';
}
/**
 * @type {ProtocolHandler}
 */ function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
    const value = extname(url);
    if (value === '.js') {
        const packageType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$package$2d$json$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getPackageType"])(url);
        if (packageType !== 'none') {
            return packageType;
        }
        return 'commonjs';
    }
    if (value === '') {
        const packageType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$package$2d$json$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getPackageType"])(url);
        // Legacy behavior
        if (packageType === 'none' || packageType === 'commonjs') {
            return 'commonjs';
        }
        // Note: we don’t implement WASM, so we don’t need
        // `getFormatOfExtensionlessFile` from `formats`.
        return 'module';
    }
    const format = extensionFormatMap[value];
    if (format) return format;
    // Explicit undefined return indicates load hook should rerun format check
    if (ignoreErrors) {
        return undefined;
    }
    const filepath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(url);
    throw new ERR_UNKNOWN_FILE_EXTENSION(value, filepath);
}
function getHttpProtocolModuleFormat() {
// To do: HTTPS imports.
}
function defaultGetFormatWithoutErrors(url, context) {
    const protocol = url.protocol;
    if (!hasOwnProperty.call(protocolHandlers, protocol)) {
        return null;
    }
    return protocolHandlers[protocol](url, context, true) || null;
}
}}),
"[project]/node_modules/@dual-bundle/import-meta-resolve/lib/utils.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Manually “tree shaken” from:
// <https://github.com/nodejs/node/blob/81a9a97/lib/internal/modules/esm/utils.js>
// Last checked on: Apr 29, 2024.
__turbopack_context__.s({
    "getConditionsSet": (()=>getConditionsSet)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dual-bundle/import-meta-resolve/lib/errors.js [app-route] (ecmascript)");
;
const { ERR_INVALID_ARG_VALUE } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["codes"];
// In Node itself these values are populated from CLI arguments, before any
// user code runs.
// Here we just define the defaults.
const DEFAULT_CONDITIONS = Object.freeze([
    'node',
    'import'
]);
const DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
/**
 * Returns the default conditions for ES module loading.
 */ function getDefaultConditions() {
    return DEFAULT_CONDITIONS;
}
/**
 * Returns the default conditions for ES module loading, as a Set.
 */ function getDefaultConditionsSet() {
    return DEFAULT_CONDITIONS_SET;
}
function getConditionsSet(conditions) {
    if (conditions !== undefined && conditions !== getDefaultConditions()) {
        if (!Array.isArray(conditions)) {
            throw new ERR_INVALID_ARG_VALUE('conditions', conditions, 'expected an array');
        }
        return new Set(conditions);
    }
    return getDefaultConditionsSet();
}
}}),
"[project]/node_modules/@dual-bundle/import-meta-resolve/lib/resolve.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Manually “tree shaken” from:
// <https://github.com/nodejs/node/blob/81a9a97/lib/internal/modules/esm/resolve.js>
// Last checked on: Apr 29, 2024.
/**
 * @typedef {import('node:fs').Stats} Stats
 * @typedef {import('./errors.js').ErrnoException} ErrnoException
 * @typedef {import('./package-json-reader.js').PackageConfig} PackageConfig
 */ __turbopack_context__.s({
    "defaultResolve": (()=>defaultResolve),
    "moduleResolve": (()=>moduleResolve)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:assert [external] (node:assert, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:url [external] (node:url, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$module__$5b$external$5d$__$28$node$3a$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:module [external] (node:module, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$get$2d$format$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dual-bundle/import-meta-resolve/lib/get-format.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dual-bundle/import-meta-resolve/lib/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$package$2d$json$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dual-bundle/import-meta-resolve/lib/package-json-reader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dual-bundle/import-meta-resolve/lib/utils.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
const RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
const { ERR_NETWORK_IMPORT_DISALLOWED, ERR_INVALID_MODULE_SPECIFIER, ERR_INVALID_PACKAGE_CONFIG, ERR_INVALID_PACKAGE_TARGET, ERR_MODULE_NOT_FOUND, ERR_PACKAGE_IMPORT_NOT_DEFINED, ERR_PACKAGE_PATH_NOT_EXPORTED, ERR_UNSUPPORTED_DIR_IMPORT, ERR_UNSUPPORTED_RESOLVE_REQUEST } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["codes"];
const own = {}.hasOwnProperty;
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
const deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const invalidPackageNameRegEx = /^\.|%|\\/;
const patternRegEx = /\*/g;
const encodedSeparatorRegEx = /%2f|%5c/i;
/** @type {Set<string>} */ const emittedPackageWarnings = new Set();
const doubleSlashRegEx = /[/\\]{2}/;
/**
 *
 * @param {string} target
 * @param {string} request
 * @param {string} match
 * @param {URL} packageJsonUrl
 * @param {boolean} internal
 * @param {URL} base
 * @param {boolean} isTarget
 */ function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
    // @ts-expect-error: apparently it does exist, TS.
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].noDeprecation) {
        return;
    }
    const pjsonPath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(packageJsonUrl);
    const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
    __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].emitWarning(`Use of deprecated ${double ? 'double slash' : 'leading or trailing slash matching'} resolving "${target}" for module ` + `request "${request}" ${request === match ? '' : `matched to "${match}" `}in the "${internal ? 'imports' : 'exports'}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base)}` : ''}.`, 'DeprecationWarning', 'DEP0166');
}
/**
 * @param {URL} url
 * @param {URL} packageJsonUrl
 * @param {URL} base
 * @param {string} [main]
 * @returns {void}
 */ function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
    // @ts-expect-error: apparently it does exist, TS.
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].noDeprecation) {
        return;
    }
    const format = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$get$2d$format$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultGetFormatWithoutErrors"])(url, {
        parentURL: base.href
    });
    if (format !== 'module') return;
    const urlPath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(url.href);
    const packagePath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"]('.', packageJsonUrl));
    const basePath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base);
    if (!main) {
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].emitWarning(`No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(packagePath.length)}", imported from ${basePath}.\nDefault "index" lookups for the main are deprecated for ES modules.`, 'DeprecationWarning', 'DEP0151');
    } else if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(packagePath, main) !== urlPath) {
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].emitWarning(`Package ${packagePath} has a "main" field set to "${main}", ` + `excluding the full filename and extension to the resolved file at "${urlPath.slice(packagePath.length)}", imported from ${basePath}.\n Automatic extension resolution of the "main" field is ` + 'deprecated for ES modules.', 'DeprecationWarning', 'DEP0151');
    }
}
/**
 * @param {string} path
 * @returns {Stats | undefined}
 */ function tryStatSync(path) {
    // Note: from Node 15 onwards we can use `throwIfNoEntry: false` instead.
    try {
        return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["statSync"])(path);
    } catch  {
    // Note: in Node code this returns `new Stats`,
    // but in Node 22 that’s marked as a deprecated internal API.
    // Which, well, we kinda are, but still to prevent that warning,
    // just yield `undefined`.
    }
}
/**
 * Legacy CommonJS main resolution:
 * 1. let M = pkg_url + (json main field)
 * 2. TRY(M, M.js, M.json, M.node)
 * 3. TRY(M/index.js, M/index.json, M/index.node)
 * 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)
 * 5. NOT_FOUND
 *
 * @param {URL} url
 * @returns {boolean}
 */ function fileExists(url) {
    const stats = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["statSync"])(url, {
        throwIfNoEntry: false
    });
    const isFile = stats ? stats.isFile() : undefined;
    return isFile === null || isFile === undefined ? false : isFile;
}
/**
 * @param {URL} packageJsonUrl
 * @param {PackageConfig} packageConfig
 * @param {URL} base
 * @returns {URL}
 */ function legacyMainResolve(packageJsonUrl, packageConfig, base) {
    /** @type {URL | undefined} */ let guess;
    if (packageConfig.main !== undefined) {
        guess = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](packageConfig.main, packageJsonUrl);
        // Note: fs check redundances will be handled by Descriptor cache here.
        if (fileExists(guess)) return guess;
        const tries = [
            `./${packageConfig.main}.js`,
            `./${packageConfig.main}.json`,
            `./${packageConfig.main}.node`,
            `./${packageConfig.main}/index.js`,
            `./${packageConfig.main}/index.json`,
            `./${packageConfig.main}/index.node`
        ];
        let i = -1;
        while(++i < tries.length){
            guess = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](tries[i], packageJsonUrl);
            if (fileExists(guess)) break;
            guess = undefined;
        }
        if (guess) {
            emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
            return guess;
        }
    // Fallthrough.
    }
    const tries = [
        './index.js',
        './index.json',
        './index.node'
    ];
    let i = -1;
    while(++i < tries.length){
        guess = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](tries[i], packageJsonUrl);
        if (fileExists(guess)) break;
        guess = undefined;
    }
    if (guess) {
        emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
        return guess;
    }
    // Not found.
    throw new ERR_MODULE_NOT_FOUND((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"]('.', packageJsonUrl)), (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base));
}
/**
 * @param {URL} resolved
 * @param {URL} base
 * @param {boolean} [preserveSymlinks]
 * @returns {URL}
 */ function finalizeResolution(resolved, base, preserveSymlinks) {
    if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {
        throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, 'must not include encoded "/" or "\\" characters', (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base));
    }
    /** @type {string} */ let filePath;
    try {
        filePath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(resolved);
    } catch (error) {
        const cause = error;
        Object.defineProperty(cause, 'input', {
            value: String(resolved)
        });
        Object.defineProperty(cause, 'module', {
            value: String(base)
        });
        throw cause;
    }
    const stats = tryStatSync(filePath.endsWith('/') ? filePath.slice(-1) : filePath);
    if (stats && stats.isDirectory()) {
        const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base));
        // @ts-expect-error Add this for `import.meta.resolve`.
        error.url = String(resolved);
        throw error;
    }
    if (!stats || !stats.isFile()) {
        const error = new ERR_MODULE_NOT_FOUND(filePath || resolved.pathname, base && (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base), true);
        // @ts-expect-error Add this for `import.meta.resolve`.
        error.url = String(resolved);
        throw error;
    }
    if (!preserveSymlinks) {
        const real = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["realpathSync"])(filePath);
        const { search, hash } = resolved;
        resolved = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["pathToFileURL"])(real + (filePath.endsWith(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].sep) ? '/' : ''));
        resolved.search = search;
        resolved.hash = hash;
    }
    return resolved;
}
/**
 * @param {string} specifier
 * @param {URL | undefined} packageJsonUrl
 * @param {URL} base
 * @returns {Error}
 */ function importNotDefined(specifier, packageJsonUrl, base) {
    return new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl && (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"]('.', packageJsonUrl)), (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base));
}
/**
 * @param {string} subpath
 * @param {URL} packageJsonUrl
 * @param {URL} base
 * @returns {Error}
 */ function exportsNotFound(subpath, packageJsonUrl, base) {
    return new ERR_PACKAGE_PATH_NOT_EXPORTED((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"]('.', packageJsonUrl)), subpath, base && (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base));
}
/**
 * @param {string} request
 * @param {string} match
 * @param {URL} packageJsonUrl
 * @param {boolean} internal
 * @param {URL} [base]
 * @returns {never}
 */ function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
    const reason = `request is not a valid match in pattern "${match}" for the "${internal ? 'imports' : 'exports'}" resolution of ${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(packageJsonUrl)}`;
    throw new ERR_INVALID_MODULE_SPECIFIER(request, reason, base && (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base));
}
/**
 * @param {string} subpath
 * @param {unknown} target
 * @param {URL} packageJsonUrl
 * @param {boolean} internal
 * @param {URL} [base]
 * @returns {Error}
 */ function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
    target = typeof target === 'object' && target !== null ? JSON.stringify(target, null, '') : `${target}`;
    return new ERR_INVALID_PACKAGE_TARGET((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"]('.', packageJsonUrl)), subpath, target, internal, base && (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base));
}
/**
 * @param {string} target
 * @param {string} subpath
 * @param {string} match
 * @param {URL} packageJsonUrl
 * @param {URL} base
 * @param {boolean} pattern
 * @param {boolean} internal
 * @param {boolean} isPathMap
 * @param {Set<string> | undefined} conditions
 * @returns {URL}
 */ function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
    if (subpath !== '' && !pattern && target[target.length - 1] !== '/') throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    if (!target.startsWith('./')) {
        if (internal && !target.startsWith('../') && !target.startsWith('/')) {
            let isURL = false;
            try {
                new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](target);
                isURL = true;
            } catch  {
            // Continue regardless of error.
            }
            if (!isURL) {
                const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, ()=>subpath) : target + subpath;
                return packageResolve(exportTarget, packageJsonUrl, conditions);
            }
        }
        throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    }
    if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
        if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
            if (!isPathMap) {
                const request = pattern ? match.replace('*', ()=>subpath) : match + subpath;
                const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, ()=>subpath) : target;
                emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, true);
            }
        } else {
            throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
        }
    }
    const resolved = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](target, packageJsonUrl);
    const resolvedPath = resolved.pathname;
    const packagePath = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"]('.', packageJsonUrl).pathname;
    if (!resolvedPath.startsWith(packagePath)) throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    if (subpath === '') return resolved;
    if (invalidSegmentRegEx.exec(subpath) !== null) {
        const request = pattern ? match.replace('*', ()=>subpath) : match + subpath;
        if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
            if (!isPathMap) {
                const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, ()=>subpath) : target;
                emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, false);
            }
        } else {
            throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
        }
    }
    if (pattern) {
        return new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](RegExpPrototypeSymbolReplace.call(patternRegEx, resolved.href, ()=>subpath));
    }
    return new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](subpath, resolved);
}
/**
 * @param {string} key
 * @returns {boolean}
 */ function isArrayIndex(key) {
    const keyNumber = Number(key);
    if (`${keyNumber}` !== key) return false;
    return keyNumber >= 0 && keyNumber < 0xff_ff_ff_ff;
}
/**
 * @param {URL} packageJsonUrl
 * @param {unknown} target
 * @param {string} subpath
 * @param {string} packageSubpath
 * @param {URL} base
 * @param {boolean} pattern
 * @param {boolean} internal
 * @param {boolean} isPathMap
 * @param {Set<string> | undefined} conditions
 * @returns {URL | null}
 */ function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
    if (typeof target === 'string') {
        return resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, isPathMap, conditions);
    }
    if (Array.isArray(target)) {
        /** @type {Array<unknown>} */ const targetList = target;
        if (targetList.length === 0) return null;
        /** @type {ErrnoException | null | undefined} */ let lastException;
        let i = -1;
        while(++i < targetList.length){
            const targetItem = targetList[i];
            /** @type {URL | null} */ let resolveResult;
            try {
                resolveResult = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
            } catch (error) {
                const exception = error;
                lastException = exception;
                if (exception.code === 'ERR_INVALID_PACKAGE_TARGET') continue;
                throw error;
            }
            if (resolveResult === undefined) continue;
            if (resolveResult === null) {
                lastException = null;
                continue;
            }
            return resolveResult;
        }
        if (lastException === undefined || lastException === null) {
            return null;
        }
        throw lastException;
    }
    if (typeof target === 'object' && target !== null) {
        const keys = Object.getOwnPropertyNames(target);
        let i = -1;
        while(++i < keys.length){
            const key = keys[i];
            if (isArrayIndex(key)) {
                throw new ERR_INVALID_PACKAGE_CONFIG((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(packageJsonUrl), base, '"exports" cannot contain numeric property keys.');
            }
        }
        i = -1;
        while(++i < keys.length){
            const key = keys[i];
            if (key === 'default' || conditions && conditions.has(key)) {
                // @ts-expect-error: indexable.
                const conditionalTarget = target[key];
                const resolveResult = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
                if (resolveResult === undefined) continue;
                return resolveResult;
            }
        }
        return null;
    }
    if (target === null) {
        return null;
    }
    throw invalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);
}
/**
 * @param {unknown} exports
 * @param {URL} packageJsonUrl
 * @param {URL} base
 * @returns {boolean}
 */ function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
    if (typeof exports === 'string' || Array.isArray(exports)) return true;
    if (typeof exports !== 'object' || exports === null) return false;
    const keys = Object.getOwnPropertyNames(exports);
    let isConditionalSugar = false;
    let i = 0;
    let keyIndex = -1;
    while(++keyIndex < keys.length){
        const key = keys[keyIndex];
        const currentIsConditionalSugar = key === '' || key[0] !== '.';
        if (i++ === 0) {
            isConditionalSugar = currentIsConditionalSugar;
        } else if (isConditionalSugar !== currentIsConditionalSugar) {
            throw new ERR_INVALID_PACKAGE_CONFIG((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(packageJsonUrl), base, '"exports" cannot contain some keys starting with \'.\' and some not.' + ' The exports object must either be an object of package subpath keys' + ' or an object of main entry condition name keys only.');
        }
    }
    return isConditionalSugar;
}
/**
 * @param {string} match
 * @param {URL} pjsonUrl
 * @param {URL} base
 */ function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
    // @ts-expect-error: apparently it does exist, TS.
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].noDeprecation) {
        return;
    }
    const pjsonPath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(pjsonUrl);
    if (emittedPackageWarnings.has(pjsonPath + '|' + match)) return;
    emittedPackageWarnings.add(pjsonPath + '|' + match);
    __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].emitWarning(`Use of deprecated trailing slash pattern mapping "${match}" in the ` + `"exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base)}` : ''}. Mapping specifiers ending in "/" is no longer supported.`, 'DeprecationWarning', 'DEP0155');
}
/**
 * @param {URL} packageJsonUrl
 * @param {string} packageSubpath
 * @param {Record<string, unknown>} packageConfig
 * @param {URL} base
 * @param {Set<string> | undefined} conditions
 * @returns {URL}
 */ function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
    let exports = packageConfig.exports;
    if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {
        exports = {
            '.': exports
        };
    }
    if (own.call(exports, packageSubpath) && !packageSubpath.includes('*') && !packageSubpath.endsWith('/')) {
        // @ts-expect-error: indexable.
        const target = exports[packageSubpath];
        const resolveResult = resolvePackageTarget(packageJsonUrl, target, '', packageSubpath, base, false, false, false, conditions);
        if (resolveResult === null || resolveResult === undefined) {
            throw exportsNotFound(packageSubpath, packageJsonUrl, base);
        }
        return resolveResult;
    }
    let bestMatch = '';
    let bestMatchSubpath = '';
    const keys = Object.getOwnPropertyNames(exports);
    let i = -1;
    while(++i < keys.length){
        const key = keys[i];
        const patternIndex = key.indexOf('*');
        if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
            // When this reaches EOL, this can throw at the top of the whole function:
            //
            // if (StringPrototypeEndsWith(packageSubpath, '/'))
            //   throwInvalidSubpath(packageSubpath)
            //
            // To match "imports" and the spec.
            if (packageSubpath.endsWith('/')) {
                emitTrailingSlashPatternDeprecation(packageSubpath, packageJsonUrl, base);
            }
            const patternTrailer = key.slice(patternIndex + 1);
            if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf('*') === patternIndex) {
                bestMatch = key;
                bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);
            }
        }
    }
    if (bestMatch) {
        // @ts-expect-error: indexable.
        const target = exports[bestMatch];
        const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, false, packageSubpath.endsWith('/'), conditions);
        if (resolveResult === null || resolveResult === undefined) {
            throw exportsNotFound(packageSubpath, packageJsonUrl, base);
        }
        return resolveResult;
    }
    throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
/**
 * @param {string} a
 * @param {string} b
 */ function patternKeyCompare(a, b) {
    const aPatternIndex = a.indexOf('*');
    const bPatternIndex = b.indexOf('*');
    const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
    const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
    if (baseLengthA > baseLengthB) return -1;
    if (baseLengthB > baseLengthA) return 1;
    if (aPatternIndex === -1) return 1;
    if (bPatternIndex === -1) return -1;
    if (a.length > b.length) return -1;
    if (b.length > a.length) return 1;
    return 0;
}
/**
 * @param {string} name
 * @param {URL} base
 * @param {Set<string>} [conditions]
 * @returns {URL}
 */ function packageImportsResolve(name, base, conditions) {
    if (name === '#' || name.startsWith('#/') || name.endsWith('/')) {
        const reason = 'is not a valid internal imports specifier name';
        throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base));
    }
    /** @type {URL | undefined} */ let packageJsonUrl;
    const packageConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$package$2d$json$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getPackageScopeConfig"])(base);
    if (packageConfig.exists) {
        packageJsonUrl = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["pathToFileURL"])(packageConfig.pjsonPath);
        const imports = packageConfig.imports;
        if (imports) {
            if (own.call(imports, name) && !name.includes('*')) {
                const resolveResult = resolvePackageTarget(packageJsonUrl, imports[name], '', name, base, false, true, false, conditions);
                if (resolveResult !== null && resolveResult !== undefined) {
                    return resolveResult;
                }
            } else {
                let bestMatch = '';
                let bestMatchSubpath = '';
                const keys = Object.getOwnPropertyNames(imports);
                let i = -1;
                while(++i < keys.length){
                    const key = keys[i];
                    const patternIndex = key.indexOf('*');
                    if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
                        const patternTrailer = key.slice(patternIndex + 1);
                        if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf('*') === patternIndex) {
                            bestMatch = key;
                            bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length);
                        }
                    }
                }
                if (bestMatch) {
                    const target = imports[bestMatch];
                    const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, true, false, conditions);
                    if (resolveResult !== null && resolveResult !== undefined) {
                        return resolveResult;
                    }
                }
            }
        }
    }
    throw importNotDefined(name, packageJsonUrl, base);
}
/**
 * @param {string} specifier
 * @param {URL} base
 */ function parsePackageName(specifier, base) {
    let separatorIndex = specifier.indexOf('/');
    let validPackageName = true;
    let isScoped = false;
    if (specifier[0] === '@') {
        isScoped = true;
        if (separatorIndex === -1 || specifier.length === 0) {
            validPackageName = false;
        } else {
            separatorIndex = specifier.indexOf('/', separatorIndex + 1);
        }
    }
    const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
    // Package name cannot have leading . and cannot have percent-encoding or
    // \\ separators.
    if (invalidPackageNameRegEx.exec(packageName) !== null) {
        validPackageName = false;
    }
    if (!validPackageName) {
        throw new ERR_INVALID_MODULE_SPECIFIER(specifier, 'is not a valid package name', (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(base));
    }
    const packageSubpath = '.' + (separatorIndex === -1 ? '' : specifier.slice(separatorIndex));
    return {
        packageName,
        packageSubpath,
        isScoped
    };
}
/**
 * @param {string} specifier
 * @param {URL} base
 * @param {Set<string> | undefined} conditions
 * @returns {URL}
 */ function packageResolve(specifier, base, conditions) {
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$module__$5b$external$5d$__$28$node$3a$module$2c$__cjs$29$__["builtinModules"].includes(specifier)) {
        return new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"]('node:' + specifier);
    }
    const { packageName, packageSubpath, isScoped } = parsePackageName(specifier, base);
    // ResolveSelf
    const packageConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$package$2d$json$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getPackageScopeConfig"])(base);
    // Can’t test.
    /* c8 ignore next 16 */ if (packageConfig.exists) {
        const packageJsonUrl = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["pathToFileURL"])(packageConfig.pjsonPath);
        if (packageConfig.name === packageName && packageConfig.exports !== undefined && packageConfig.exports !== null) {
            return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions);
        }
    }
    let packageJsonUrl = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"]('./node_modules/' + packageName + '/package.json', base);
    let packageJsonPath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(packageJsonUrl);
    /** @type {string} */ let lastPath;
    do {
        const stat = tryStatSync(packageJsonPath.slice(0, -13));
        if (!stat || !stat.isDirectory()) {
            lastPath = packageJsonPath;
            packageJsonUrl = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"]((isScoped ? '../../../../node_modules/' : '../../../node_modules/') + packageName + '/package.json', packageJsonUrl);
            packageJsonPath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(packageJsonUrl);
            continue;
        }
        // Package match.
        const packageConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$package$2d$json$2d$reader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["read"])(packageJsonPath, {
            base,
            specifier
        });
        if (packageConfig.exports !== undefined && packageConfig.exports !== null) {
            return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions);
        }
        if (packageSubpath === '.') {
            return legacyMainResolve(packageJsonUrl, packageConfig, base);
        }
        return new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](packageSubpath, packageJsonUrl);
    // Cross-platform root check.
    }while (packageJsonPath.length !== lastPath.length)
    throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base), false);
}
/**
 * @param {string} specifier
 * @returns {boolean}
 */ function isRelativeSpecifier(specifier) {
    if (specifier[0] === '.') {
        if (specifier.length === 1 || specifier[1] === '/') return true;
        if (specifier[1] === '.' && (specifier.length === 2 || specifier[2] === '/')) {
            return true;
        }
    }
    return false;
}
/**
 * @param {string} specifier
 * @returns {boolean}
 */ function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
    if (specifier === '') return false;
    if (specifier[0] === '/') return true;
    return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
    // Note: The Node code supports `base` as a string (in this internal API) too,
    // we don’t.
    const protocol = base.protocol;
    const isData = protocol === 'data:';
    const isRemote = isData || protocol === 'http:' || protocol === 'https:';
    // Order swapped from spec for minor perf gain.
    // Ok since relative URLs cannot parse as URLs.
    /** @type {URL | undefined} */ let resolved;
    if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
        try {
            resolved = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](specifier, base);
        } catch (error_) {
            const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
            error.cause = error_;
            throw error;
        }
    } else if (protocol === 'file:' && specifier[0] === '#') {
        resolved = packageImportsResolve(specifier, base, conditions);
    } else {
        try {
            resolved = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](specifier);
        } catch (error_) {
            // Note: actual code uses `canBeRequiredWithoutScheme`.
            if (isRemote && !__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$module__$5b$external$5d$__$28$node$3a$module$2c$__cjs$29$__["builtinModules"].includes(specifier)) {
                const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
                error.cause = error_;
                throw error;
            }
            resolved = packageResolve(specifier, base, conditions);
        }
    }
    (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__["default"])(resolved !== undefined, 'expected to be defined');
    if (resolved.protocol !== 'file:') {
        return resolved;
    }
    return finalizeResolution(resolved, base, preserveSymlinks);
}
/**
 * @param {string} specifier
 * @param {URL | undefined} parsed
 * @param {URL | undefined} parsedParentURL
 */ function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
    if (parsedParentURL) {
        // Avoid accessing the `protocol` property due to the lazy getters.
        const parentProtocol = parsedParentURL.protocol;
        if (parentProtocol === 'http:' || parentProtocol === 'https:') {
            if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
                // Avoid accessing the `protocol` property due to the lazy getters.
                const parsedProtocol = parsed?.protocol;
                // `data:` and `blob:` disallowed due to allowing file: access via
                // indirection
                if (parsedProtocol && parsedProtocol !== 'https:' && parsedProtocol !== 'http:') {
                    throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, 'remote imports cannot import from a local location.');
                }
                return {
                    url: parsed?.href || ''
                };
            }
            if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$module__$5b$external$5d$__$28$node$3a$module$2c$__cjs$29$__["builtinModules"].includes(specifier)) {
                throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, 'remote imports cannot import from a local location.');
            }
            throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, 'only relative and absolute specifiers are supported.');
        }
    }
}
// Note: this is from:
// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>
/**
 * Checks if a value has the shape of a WHATWG URL object.
 *
 * Using a symbol or instanceof would not be able to recognize URL objects
 * coming from other implementations (e.g. in Electron), so instead we are
 * checking some well known properties for a lack of a better test.
 *
 * We use `href` and `protocol` as they are the only properties that are
 * easy to retrieve and calculate due to the lazy nature of the getters.
 *
 * @template {unknown} Value
 * @param {Value} self
 * @returns {Value is URL}
 */ function isURL(self) {
    return Boolean(self && typeof self === 'object' && 'href' in self && typeof self.href === 'string' && 'protocol' in self && typeof self.protocol === 'string' && self.href && self.protocol);
}
/**
 * Validate user-input in `context` supplied by a custom loader.
 *
 * @param {unknown} parentURL
 * @returns {asserts parentURL is URL | string | undefined}
 */ function throwIfInvalidParentURL(parentURL) {
    if (parentURL === undefined) {
        return; // Main entry point, so no parent
    }
    if (typeof parentURL !== 'string' && !isURL(parentURL)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["codes"].ERR_INVALID_ARG_TYPE('parentURL', [
            'string',
            'URL'
        ], parentURL);
    }
}
function defaultResolve(specifier, context = {}) {
    const { parentURL } = context;
    (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$assert__$5b$external$5d$__$28$node$3a$assert$2c$__cjs$29$__["default"])(parentURL !== undefined, 'expected `parentURL` to be defined');
    throwIfInvalidParentURL(parentURL);
    /** @type {URL | undefined} */ let parsedParentURL;
    if (parentURL) {
        try {
            parsedParentURL = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](parentURL);
        } catch  {
        // Ignore exception
        }
    }
    /** @type {URL | undefined} */ let parsed;
    /** @type {string | undefined} */ let protocol;
    try {
        parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](specifier, parsedParentURL) : new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](specifier);
        // Avoid accessing the `protocol` property due to the lazy getters.
        protocol = parsed.protocol;
        if (protocol === 'data:') {
            return {
                url: parsed.href,
                format: null
            };
        }
    } catch  {
    // Ignore exception
    }
    // There are multiple deep branches that can either throw or return; instead
    // of duplicating that deeply nested logic for the possible returns, DRY and
    // check for a return. This seems the least gnarly.
    const maybeReturn = checkIfDisallowedImport(specifier, parsed, parsedParentURL);
    if (maybeReturn) return maybeReturn;
    // This must come after checkIfDisallowedImport
    if (protocol === undefined && parsed) {
        protocol = parsed.protocol;
    }
    if (protocol === 'node:') {
        return {
            url: specifier
        };
    }
    // This must come after checkIfDisallowedImport
    if (parsed && parsed.protocol === 'node:') return {
        url: specifier
    };
    const conditions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getConditionsSet"])(context.conditions);
    const url = moduleResolve(specifier, new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URL"](parentURL), conditions, false);
    return {
        // Do NOT cast `url` to a string: that will work even when there are real
        // problems, silencing them
        url: url.href,
        format: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$get$2d$format$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultGetFormatWithoutErrors"])(url, {
            parentURL
        })
    };
}
}}),
"[project]/node_modules/@dual-bundle/import-meta-resolve/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @typedef {import('./lib/errors.js').ErrnoException} ErrnoException
 */ __turbopack_context__.s({
    "resolve": (()=>resolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$resolve$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dual-bundle/import-meta-resolve/lib/resolve.js [app-route] (ecmascript)");
;
;
function resolve(specifier, parent) {
    if (!parent) {
        throw new Error('Please pass `parent`: `import-meta-resolve` cannot ponyfill that');
    }
    try {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dual$2d$bundle$2f$import$2d$meta$2d$resolve$2f$lib$2f$resolve$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultResolve"])(specifier, {
            parentURL: parent
        }).url;
    } catch (error) {
        // See: <https://github.com/nodejs/node/blob/45f5c9b/lib/internal/modules/esm/initialize_import_meta.js#L34>
        const exception = error;
        if ((exception.code === 'ERR_UNSUPPORTED_DIR_IMPORT' || exception.code === 'ERR_MODULE_NOT_FOUND') && typeof exception.url === 'string') {
            return exception.url;
        }
        throw error;
    }
}
}}),
"[project]/node_modules/ignore/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// A simple implementation of make-array
function makeArray(subject) {
    return Array.isArray(subject) ? subject : [
        subject
    ];
}
const UNDEFINED = undefined;
const EMPTY = '';
const SPACE = ' ';
const ESCAPE = '\\';
const REGEX_TEST_BLANK_LINE = /^\s+$/;
const REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
const REGEX_SPLITALL_CRLF = /\r?\n/g;
// Invalid:
// - /foo,
// - ./foo,
// - ../foo,
// - .
// - ..
// Valid:
// - .foo
const REGEX_TEST_INVALID_PATH = /^\.{0,2}\/|^\.{1,2}$/;
const REGEX_TEST_TRAILING_SLASH = /\/$/;
const SLASH = '/';
// Do not use ternary expression here, since "istanbul ignore next" is buggy
let TMP_KEY_IGNORE = 'node-ignore';
/* istanbul ignore else */ if (typeof Symbol !== 'undefined') {
    TMP_KEY_IGNORE = Symbol.for('node-ignore');
}
const KEY_IGNORE = TMP_KEY_IGNORE;
const define = (object, key, value)=>{
    Object.defineProperty(object, key, {
        value
    });
    return value;
};
const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
const RETURN_FALSE = ()=>false;
// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = (range)=>range.replace(REGEX_REGEXP_RANGE, (match, from, to)=>from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
// See fixtures #59
const cleanRangeBackSlash = (slashes)=>{
    const { length } = slashes;
    return slashes.slice(0, length - length % 2);
};
// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`
// '`foo/`' should not continue with the '`..`'
const REPLACERS = [
    [
        // Remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        ()=>EMPTY
    ],
    // > Trailing spaces are ignored unless they are quoted with backslash ("\")
    [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a ) -> (a)
        // (a \ ) -> (a  )
        /((?:\\\\)*?)(\\?\s+)$/,
        (_, m1, m2)=>m1 + (m2.indexOf('\\') === 0 ? SPACE : EMPTY)
    ],
    // Replace (\ ) with ' '
    // (\ ) -> ' '
    // (\\ ) -> '\\ '
    // (\\\ ) -> '\\ '
    [
        /(\\+?)\s/g,
        (_, m1)=>{
            const { length } = m1;
            return m1.slice(0, length - length % 2) + SPACE;
        }
    ],
    // Escape metacharacters
    // which is written down by users but means special for regular expressions.
    // > There are 12 characters with special meanings:
    // > - the backslash \,
    // > - the caret ^,
    // > - the dollar sign $,
    // > - the period or dot .,
    // > - the vertical bar or pipe symbol |,
    // > - the question mark ?,
    // > - the asterisk or star *,
    // > - the plus sign +,
    // > - the opening parenthesis (,
    // > - the closing parenthesis ),
    // > - and the opening square bracket [,
    // > - the opening curly brace {,
    // > These special characters are often called "metacharacters".
    [
        /[\\$.|*+(){^]/g,
        (match)=>`\\${match}`
    ],
    [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        ()=>'[^/]'
    ],
    // leading slash
    [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        ()=>'^'
    ],
    // replace special metacharacter slash after the leading slash
    [
        /\//g,
        ()=>'\\/'
    ],
    [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        ()=>'^(?:.*\\/)?'
    ],
    // starting
    [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
            // If has a slash `/` at the beginning or middle
            return !/\/(?!$)/.test(this) ? '(?:^|\\/)' : '^';
        }
    ],
    // two globstars
    [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str)=>index + 6 < str.length ? '(?:\\/[^\\/]+)*' : '\\/.+'
    ],
    // normal intermediate wildcards
    [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2)=>{
            // 1.
            // > An asterisk "*" matches anything except a slash.
            // 2.
            // > Other consecutive asterisks are considered regular asterisks
            // > and will match according to the previous rules.
            const unescaped = p2.replace(/\\\*/g, '[^\\/]*');
            return p1 + unescaped;
        }
    ],
    [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        ()=>ESCAPE
    ],
    [
        // '\\\\' -> '\\'
        /\\\\/g,
        ()=>ESCAPE
    ],
    [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close)=>leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === ']' ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : '[]' : '[]'
    ],
    // ending
    [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match)=>/\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
    ]
];
const REGEX_REPLACE_TRAILING_WILDCARD = /(^|\\\/)?\\\*$/;
const MODE_IGNORE = 'regex';
const MODE_CHECK_IGNORE = 'checkRegex';
const UNDERSCORE = '_';
const TRAILING_WILD_CARD_REPLACERS = {
    [MODE_IGNORE] (_, p1) {
        const prefix = p1 ? `${p1}[^/]+` : '[^/]*';
        return `${prefix}(?=$|\\/$)`;
    },
    [MODE_CHECK_IGNORE] (_, p1) {
        // When doing `git check-ignore`
        const prefix = p1 ? `${p1}[^/]*` : '[^/]*';
        return `${prefix}(?=$|\\/$)`;
    }
};
// @param {pattern}
const makeRegexPrefix = (pattern)=>REPLACERS.reduce((prev, [matcher, replacer])=>prev.replace(matcher, replacer.bind(pattern)), pattern);
const isString = (subject)=>typeof subject === 'string';
// > A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = (pattern)=>pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf('#') !== 0;
const splitPattern = (pattern)=>pattern.split(REGEX_SPLITALL_CRLF).filter(Boolean);
class IgnoreRule {
    constructor(pattern, mark, body, ignoreCase, negative, prefix){
        this.pattern = pattern;
        this.mark = mark;
        this.negative = negative;
        define(this, 'body', body);
        define(this, 'ignoreCase', ignoreCase);
        define(this, 'regexPrefix', prefix);
    }
    get regex() {
        const key = UNDERSCORE + MODE_IGNORE;
        if (this[key]) {
            return this[key];
        }
        return this._make(MODE_IGNORE, key);
    }
    get checkRegex() {
        const key = UNDERSCORE + MODE_CHECK_IGNORE;
        if (this[key]) {
            return this[key];
        }
        return this._make(MODE_CHECK_IGNORE, key);
    }
    _make(mode, key) {
        const str = this.regexPrefix.replace(REGEX_REPLACE_TRAILING_WILDCARD, // It does not need to bind pattern
        TRAILING_WILD_CARD_REPLACERS[mode]);
        const regex = this.ignoreCase ? new RegExp(str, 'i') : new RegExp(str);
        return define(this, key, regex);
    }
}
const createRule = ({ pattern, mark }, ignoreCase)=>{
    let negative = false;
    let body = pattern;
    // > An optional prefix "!" which negates the pattern;
    if (body.indexOf('!') === 0) {
        negative = true;
        body = body.substr(1);
    }
    body = body// > Put a backslash ("\") in front of the first "!" for patterns that
    // >   begin with a literal "!", for example, `"\!important!.txt"`.
    .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')// > Put a backslash ("\") in front of the first hash for patterns that
    // >   begin with a hash.
    .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');
    const regexPrefix = makeRegexPrefix(body);
    return new IgnoreRule(pattern, mark, body, ignoreCase, negative, regexPrefix);
};
class RuleManager {
    constructor(ignoreCase){
        this._ignoreCase = ignoreCase;
        this._rules = [];
    }
    _add(pattern) {
        // #32
        if (pattern && pattern[KEY_IGNORE]) {
            this._rules = this._rules.concat(pattern._rules._rules);
            this._added = true;
            return;
        }
        if (isString(pattern)) {
            pattern = {
                pattern
            };
        }
        if (checkPattern(pattern.pattern)) {
            const rule = createRule(pattern, this._ignoreCase);
            this._added = true;
            this._rules.push(rule);
        }
    }
    // @param {Array<string> | string | Ignore} pattern
    add(pattern) {
        this._added = false;
        makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._add, this);
        return this._added;
    }
    // Test one single path without recursively checking parent directories
    //
    // - checkUnignored `boolean` whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.
    // - check `string` either `MODE_IGNORE` or `MODE_CHECK_IGNORE`
    // @returns {TestResult} true if a file is ignored
    test(path, checkUnignored, mode) {
        let ignored = false;
        let unignored = false;
        let matchedRule;
        this._rules.forEach((rule)=>{
            const { negative } = rule;
            //          |           ignored : unignored
            // -------- | ---------------------------------------
            // negative |   0:0   |   0:1   |   1:0   |   1:1
            // -------- | ------- | ------- | ------- | --------
            //     0    |  TEST   |  TEST   |  SKIP   |    X
            //     1    |  TESTIF |  SKIP   |  TEST   |    X
            // - SKIP: always skip
            // - TEST: always test
            // - TESTIF: only test if checkUnignored
            // - X: that never happen
            if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
                return;
            }
            const matched = rule[mode].test(path);
            if (!matched) {
                return;
            }
            ignored = !negative;
            unignored = negative;
            matchedRule = negative ? UNDEFINED : rule;
        });
        const ret = {
            ignored,
            unignored
        };
        if (matchedRule) {
            ret.rule = matchedRule;
        }
        return ret;
    }
}
const throwError = (message, Ctor)=>{
    throw new Ctor(message);
};
const checkPath = (path, originalPath, doThrow)=>{
    if (!isString(path)) {
        return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
    }
    // We don't know if we should ignore EMPTY, so throw
    if (!path) {
        return doThrow(`path must not be empty`, TypeError);
    }
    // Check if it is a relative path
    if (checkPath.isNotRelative(path)) {
        const r = '`path.relative()`d';
        return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
    }
    return true;
};
const isNotRelative = (path)=>REGEX_TEST_INVALID_PATH.test(path);
checkPath.isNotRelative = isNotRelative;
// On windows, the following function will be replaced
/* istanbul ignore next */ checkPath.convert = (p)=>p;
class Ignore {
    constructor({ ignorecase = true, ignoreCase = ignorecase, allowRelativePaths = false } = {}){
        define(this, KEY_IGNORE, true);
        this._rules = new RuleManager(ignoreCase);
        this._strictPathCheck = !allowRelativePaths;
        this._initCache();
    }
    _initCache() {
        // A cache for the result of `.ignores()`
        this._ignoreCache = Object.create(null);
        // A cache for the result of `.test()`
        this._testCache = Object.create(null);
    }
    add(pattern) {
        if (this._rules.add(pattern)) {
            // Some rules have just added to the ignore,
            //   making the behavior changed,
            //   so we need to re-initialize the result cache
            this._initCache();
        }
        return this;
    }
    // legacy
    addPattern(pattern) {
        return this.add(pattern);
    }
    // @returns {TestResult}
    _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(path, originalPath, this._strictPathCheck ? throwError : RETURN_FALSE);
        return this._t(path, cache, checkUnignored, slices);
    }
    checkIgnore(path) {
        // If the path doest not end with a slash, `.ignores()` is much equivalent
        //   to `git check-ignore`
        if (!REGEX_TEST_TRAILING_SLASH.test(path)) {
            return this.test(path);
        }
        const slices = path.split(SLASH).filter(Boolean);
        slices.pop();
        if (slices.length) {
            const parent = this._t(slices.join(SLASH) + SLASH, this._testCache, true, slices);
            if (parent.ignored) {
                return parent;
            }
        }
        return this._rules.test(path, false, MODE_CHECK_IGNORE);
    }
    _t(// The path to be tested
    path, // The cache for the result of a certain checking
    cache, // Whether should check if the path is unignored
    checkUnignored, // The path slices
    slices) {
        if (path in cache) {
            return cache[path];
        }
        if (!slices) {
            // path/to/a.js
            // ['path', 'to', 'a.js']
            slices = path.split(SLASH).filter(Boolean);
        }
        slices.pop();
        // If the path has no parent directory, just test it
        if (!slices.length) {
            return cache[path] = this._rules.test(path, checkUnignored, MODE_IGNORE);
        }
        const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
        // If the path contains a parent directory, check the parent first
        return cache[path] = parent.ignored ? parent : this._rules.test(path, checkUnignored, MODE_IGNORE);
    }
    ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
    }
    createFilter() {
        return (path)=>!this.ignores(path);
    }
    filter(paths) {
        return makeArray(paths).filter(this.createFilter());
    }
    // @returns {TestResult}
    test(path) {
        return this._test(path, this._testCache, true);
    }
}
const factory = (options)=>new Ignore(options);
const isPathValid = (path)=>checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
// Windows
// --------------------------------------------------------------
/* istanbul ignore next */ if (// Detect `process` so that it can run in browsers.
typeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {
    /* eslint no-control-regex: "off" */ const makePosix = (str)=>/^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, '/');
    checkPath.convert = makePosix;
    // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
    // 'd:\\foo'
    const REGEX_TEST_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
    checkPath.isNotRelative = (path)=>REGEX_TEST_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
}
// COMMONJS_EXPORTS ////////////////////////////////////////////////////////////
module.exports = factory;
// Although it is an anti-pattern,
//   it is still widely misused by a lot of libraries in github
// Ref: https://github.com/search?q=ignore.default%28%29&type=code
factory.default = factory;
module.exports.isPathValid = isPathValid;
}}),
"[project]/node_modules/globby/node_modules/ignore/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// A simple implementation of make-array
function makeArray(subject) {
    return Array.isArray(subject) ? subject : [
        subject
    ];
}
const EMPTY = '';
const SPACE = ' ';
const ESCAPE = '\\';
const REGEX_TEST_BLANK_LINE = /^\s+$/;
const REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
const REGEX_SPLITALL_CRLF = /\r?\n/g;
// /foo,
// ./foo,
// ../foo,
// .
// ..
const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
const SLASH = '/';
// Do not use ternary expression here, since "istanbul ignore next" is buggy
let TMP_KEY_IGNORE = 'node-ignore';
/* istanbul ignore else */ if (typeof Symbol !== 'undefined') {
    TMP_KEY_IGNORE = Symbol.for('node-ignore');
}
const KEY_IGNORE = TMP_KEY_IGNORE;
const define = (object, key, value)=>Object.defineProperty(object, key, {
        value
    });
const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
const RETURN_FALSE = ()=>false;
// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = (range)=>range.replace(REGEX_REGEXP_RANGE, (match, from, to)=>from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
// See fixtures #59
const cleanRangeBackSlash = (slashes)=>{
    const { length } = slashes;
    return slashes.slice(0, length - length % 2);
};
// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`
// '`foo/`' should not continue with the '`..`'
const REPLACERS = [
    [
        // remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        ()=>EMPTY
    ],
    // > Trailing spaces are ignored unless they are quoted with backslash ("\")
    [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a ) -> (a)
        // (a \ ) -> (a  )
        /((?:\\\\)*?)(\\?\s+)$/,
        (_, m1, m2)=>m1 + (m2.indexOf('\\') === 0 ? SPACE : EMPTY)
    ],
    // replace (\ ) with ' '
    // (\ ) -> ' '
    // (\\ ) -> '\\ '
    // (\\\ ) -> '\\ '
    [
        /(\\+?)\s/g,
        (_, m1)=>{
            const { length } = m1;
            return m1.slice(0, length - length % 2) + SPACE;
        }
    ],
    // Escape metacharacters
    // which is written down by users but means special for regular expressions.
    // > There are 12 characters with special meanings:
    // > - the backslash \,
    // > - the caret ^,
    // > - the dollar sign $,
    // > - the period or dot .,
    // > - the vertical bar or pipe symbol |,
    // > - the question mark ?,
    // > - the asterisk or star *,
    // > - the plus sign +,
    // > - the opening parenthesis (,
    // > - the closing parenthesis ),
    // > - and the opening square bracket [,
    // > - the opening curly brace {,
    // > These special characters are often called "metacharacters".
    [
        /[\\$.|*+(){^]/g,
        (match)=>`\\${match}`
    ],
    [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        ()=>'[^/]'
    ],
    // leading slash
    [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        ()=>'^'
    ],
    // replace special metacharacter slash after the leading slash
    [
        /\//g,
        ()=>'\\/'
    ],
    [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        ()=>'^(?:.*\\/)?'
    ],
    // starting
    [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
            // If has a slash `/` at the beginning or middle
            return !/\/(?!$)/.test(this) ? '(?:^|\\/)' : '^';
        }
    ],
    // two globstars
    [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str)=>index + 6 < str.length ? '(?:\\/[^\\/]+)*' : '\\/.+'
    ],
    // normal intermediate wildcards
    [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2)=>{
            // 1.
            // > An asterisk "*" matches anything except a slash.
            // 2.
            // > Other consecutive asterisks are considered regular asterisks
            // > and will match according to the previous rules.
            const unescaped = p2.replace(/\\\*/g, '[^\\/]*');
            return p1 + unescaped;
        }
    ],
    [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        ()=>ESCAPE
    ],
    [
        // '\\\\' -> '\\'
        /\\\\/g,
        ()=>ESCAPE
    ],
    [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close)=>leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === ']' ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : '[]' : '[]'
    ],
    // ending
    [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match)=>/\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
    ],
    // trailing wildcard
    [
        /(\^|\\\/)?\\\*$/,
        (_, p1)=>{
            const prefix = p1 ? `${p1}[^/]+` : '[^/]*';
            return `${prefix}(?=$|\\/$)`;
        }
    ]
];
// A simple cache, because an ignore rule only has only one certain meaning
const regexCache = Object.create(null);
// @param {pattern}
const makeRegex = (pattern, ignoreCase)=>{
    let source = regexCache[pattern];
    if (!source) {
        source = REPLACERS.reduce((prev, [matcher, replacer])=>prev.replace(matcher, replacer.bind(pattern)), pattern);
        regexCache[pattern] = source;
    }
    return ignoreCase ? new RegExp(source, 'i') : new RegExp(source);
};
const isString = (subject)=>typeof subject === 'string';
// > A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = (pattern)=>pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf('#') !== 0;
const splitPattern = (pattern)=>pattern.split(REGEX_SPLITALL_CRLF);
class IgnoreRule {
    constructor(origin, pattern, negative, regex){
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
    }
}
const createRule = (pattern, ignoreCase)=>{
    const origin = pattern;
    let negative = false;
    // > An optional prefix "!" which negates the pattern;
    if (pattern.indexOf('!') === 0) {
        negative = true;
        pattern = pattern.substr(1);
    }
    pattern = pattern// > Put a backslash ("\") in front of the first "!" for patterns that
    // >   begin with a literal "!", for example, `"\!important!.txt"`.
    .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')// > Put a backslash ("\") in front of the first hash for patterns that
    // >   begin with a hash.
    .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');
    const regex = makeRegex(pattern, ignoreCase);
    return new IgnoreRule(origin, pattern, negative, regex);
};
const throwError = (message, Ctor)=>{
    throw new Ctor(message);
};
const checkPath = (path, originalPath, doThrow)=>{
    if (!isString(path)) {
        return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
    }
    // We don't know if we should ignore EMPTY, so throw
    if (!path) {
        return doThrow(`path must not be empty`, TypeError);
    }
    // Check if it is a relative path
    if (checkPath.isNotRelative(path)) {
        const r = '`path.relative()`d';
        return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
    }
    return true;
};
const isNotRelative = (path)=>REGEX_TEST_INVALID_PATH.test(path);
checkPath.isNotRelative = isNotRelative;
checkPath.convert = (p)=>p;
class Ignore {
    constructor({ ignorecase = true, ignoreCase = ignorecase, allowRelativePaths = false } = {}){
        define(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
    }
    _initCache() {
        this._ignoreCache = Object.create(null);
        this._testCache = Object.create(null);
    }
    _addPattern(pattern) {
        // #32
        if (pattern && pattern[KEY_IGNORE]) {
            this._rules = this._rules.concat(pattern._rules);
            this._added = true;
            return;
        }
        if (checkPattern(pattern)) {
            const rule = createRule(pattern, this._ignoreCase);
            this._added = true;
            this._rules.push(rule);
        }
    }
    // @param {Array<string> | string | Ignore} pattern
    add(pattern) {
        this._added = false;
        makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
        // Some rules have just added to the ignore,
        // making the behavior changed.
        if (this._added) {
            this._initCache();
        }
        return this;
    }
    // legacy
    addPattern(pattern) {
        return this.add(pattern);
    }
    //          |           ignored : unignored
    // negative |   0:0   |   0:1   |   1:0   |   1:1
    // -------- | ------- | ------- | ------- | --------
    //     0    |  TEST   |  TEST   |  SKIP   |    X
    //     1    |  TESTIF |  SKIP   |  TEST   |    X
    // - SKIP: always skip
    // - TEST: always test
    // - TESTIF: only test if checkUnignored
    // - X: that never happen
    // @param {boolean} whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.
    // @returns {TestResult} true if a file is ignored
    _testOne(path, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule)=>{
            const { negative } = rule;
            if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
                return;
            }
            const matched = rule.regex.test(path);
            if (matched) {
                ignored = !negative;
                unignored = negative;
            }
        });
        return {
            ignored,
            unignored
        };
    }
    // @returns {TestResult}
    _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);
        return this._t(path, cache, checkUnignored, slices);
    }
    _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
            return cache[path];
        }
        if (!slices) {
            // path/to/a.js
            // ['path', 'to', 'a.js']
            slices = path.split(SLASH);
        }
        slices.pop();
        // If the path has no parent directory, just test it
        if (!slices.length) {
            return cache[path] = this._testOne(path, checkUnignored);
        }
        const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
        // If the path contains a parent directory, check the parent first
        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
    }
    ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
    }
    createFilter() {
        return (path)=>!this.ignores(path);
    }
    filter(paths) {
        return makeArray(paths).filter(this.createFilter());
    }
    // @returns {TestResult}
    test(path) {
        return this._test(path, this._testCache, true);
    }
}
const factory = (options)=>new Ignore(options);
const isPathValid = (path)=>checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
factory.isPathValid = isPathValid;
// Fixes typescript
factory.default = factory;
module.exports = factory;
// Windows
// --------------------------------------------------------------
/* istanbul ignore if */ if (// Detect `process` so that it can run in browsers.
typeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {
    /* eslint no-control-regex: "off" */ const makePosix = (str)=>/^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, '/');
    checkPath.convert = makePosix;
    // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
    // 'd:\\foo'
    const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
    checkPath.isNotRelative = (path)=>REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
}
}}),
"[project]/node_modules/@csstools/css-tokenizer/dist/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "HashType": (()=>u),
    "NumberType": (()=>a),
    "ParseError": (()=>ParseError),
    "ParseErrorMessage": (()=>e),
    "ParseErrorWithToken": (()=>ParseErrorWithToken),
    "TokenType": (()=>c),
    "cloneTokens": (()=>cloneTokens),
    "isToken": (()=>isToken),
    "isTokenAtKeyword": (()=>isTokenAtKeyword),
    "isTokenBadString": (()=>isTokenBadString),
    "isTokenBadURL": (()=>isTokenBadURL),
    "isTokenCDC": (()=>isTokenCDC),
    "isTokenCDO": (()=>isTokenCDO),
    "isTokenCloseCurly": (()=>isTokenCloseCurly),
    "isTokenCloseParen": (()=>isTokenCloseParen),
    "isTokenCloseSquare": (()=>isTokenCloseSquare),
    "isTokenColon": (()=>isTokenColon),
    "isTokenComma": (()=>isTokenComma),
    "isTokenComment": (()=>isTokenComment),
    "isTokenDelim": (()=>isTokenDelim),
    "isTokenDimension": (()=>isTokenDimension),
    "isTokenEOF": (()=>isTokenEOF),
    "isTokenFunction": (()=>isTokenFunction),
    "isTokenHash": (()=>isTokenHash),
    "isTokenIdent": (()=>isTokenIdent),
    "isTokenNumber": (()=>isTokenNumber),
    "isTokenNumeric": (()=>isTokenNumeric),
    "isTokenOpenCurly": (()=>isTokenOpenCurly),
    "isTokenOpenParen": (()=>isTokenOpenParen),
    "isTokenOpenSquare": (()=>isTokenOpenSquare),
    "isTokenPercentage": (()=>isTokenPercentage),
    "isTokenSemicolon": (()=>isTokenSemicolon),
    "isTokenString": (()=>isTokenString),
    "isTokenURL": (()=>isTokenURL),
    "isTokenUnicodeRange": (()=>isTokenUnicodeRange),
    "isTokenWhiteSpaceOrComment": (()=>isTokenWhiteSpaceOrComment),
    "isTokenWhitespace": (()=>isTokenWhitespace),
    "mirrorVariant": (()=>mirrorVariant),
    "mirrorVariantType": (()=>mirrorVariantType),
    "mutateIdent": (()=>mutateIdent),
    "mutateUnit": (()=>mutateUnit),
    "stringify": (()=>stringify),
    "tokenize": (()=>tokenize),
    "tokenizer": (()=>tokenizer)
});
class ParseError extends Error {
    sourceStart;
    sourceEnd;
    parserState;
    constructor(e, n, t, o){
        super(e), this.name = "ParseError", this.sourceStart = n, this.sourceEnd = t, this.parserState = o;
    }
}
class ParseErrorWithToken extends ParseError {
    token;
    constructor(e, n, t, o, r){
        super(e, n, t, o), this.token = r;
    }
}
const e = {
    UnexpectedNewLineInString: "Unexpected newline while consuming a string token.",
    UnexpectedEOFInString: "Unexpected EOF while consuming a string token.",
    UnexpectedEOFInComment: "Unexpected EOF while consuming a comment.",
    UnexpectedEOFInURL: "Unexpected EOF while consuming a url token.",
    UnexpectedEOFInEscapedCodePoint: "Unexpected EOF while consuming an escaped code point.",
    UnexpectedCharacterInURL: "Unexpected character while consuming a url token.",
    InvalidEscapeSequenceInURL: "Invalid escape sequence while consuming a url token.",
    InvalidEscapeSequenceAfterBackslash: 'Invalid escape sequence after "\\"'
}, n = "undefined" != typeof globalThis && "structuredClone" in globalThis;
function cloneTokens(e) {
    return n ? structuredClone(e) : JSON.parse(JSON.stringify(e));
}
function stringify(...e) {
    let n = "";
    for(let t = 0; t < e.length; t++)n += e[t][1];
    return n;
}
const t = 13, o = 45, r = 10, i = 43, s = 65533;
function checkIfFourCodePointsWouldStartCDO(e) {
    return 60 === e.source.codePointAt(e.cursor) && 33 === e.source.codePointAt(e.cursor + 1) && e.source.codePointAt(e.cursor + 2) === o && e.source.codePointAt(e.cursor + 3) === o;
}
function isDigitCodePoint(e) {
    return e >= 48 && e <= 57;
}
function isUppercaseLetterCodePoint(e) {
    return e >= 65 && e <= 90;
}
function isLowercaseLetterCodePoint(e) {
    return e >= 97 && e <= 122;
}
function isHexDigitCodePoint(e) {
    return e >= 48 && e <= 57 || e >= 97 && e <= 102 || e >= 65 && e <= 70;
}
function isLetterCodePoint(e) {
    return isLowercaseLetterCodePoint(e) || isUppercaseLetterCodePoint(e);
}
function isIdentStartCodePoint(e) {
    return isLetterCodePoint(e) || isNonASCII_IdentCodePoint(e) || 95 === e;
}
function isIdentCodePoint(e) {
    return isIdentStartCodePoint(e) || isDigitCodePoint(e) || e === o;
}
function isNonASCII_IdentCodePoint(e) {
    return 183 === e || 8204 === e || 8205 === e || 8255 === e || 8256 === e || 8204 === e || 192 <= e && e <= 214 || 216 <= e && e <= 246 || 248 <= e && e <= 893 || 895 <= e && e <= 8191 || 8304 <= e && e <= 8591 || 11264 <= e && e <= 12271 || 12289 <= e && e <= 55295 || 63744 <= e && e <= 64975 || 65008 <= e && e <= 65533 || 0 === e || !!isSurrogate(e) || e >= 65536;
}
function isNewLine(e) {
    return e === r || e === t || 12 === e;
}
function isWhitespace(e) {
    return 32 === e || e === r || 9 === e || e === t || 12 === e;
}
function isSurrogate(e) {
    return e >= 55296 && e <= 57343;
}
function checkIfTwoCodePointsAreAValidEscape(e) {
    return 92 === e.source.codePointAt(e.cursor) && !isNewLine(e.source.codePointAt(e.cursor + 1) ?? -1);
}
function checkIfThreeCodePointsWouldStartAnIdentSequence(e, n) {
    return n.source.codePointAt(n.cursor) === o ? n.source.codePointAt(n.cursor + 1) === o || !!isIdentStartCodePoint(n.source.codePointAt(n.cursor + 1) ?? -1) || 92 === n.source.codePointAt(n.cursor + 1) && !isNewLine(n.source.codePointAt(n.cursor + 2) ?? -1) : !!isIdentStartCodePoint(n.source.codePointAt(n.cursor) ?? -1) || checkIfTwoCodePointsAreAValidEscape(n);
}
function checkIfThreeCodePointsWouldStartANumber(e) {
    return e.source.codePointAt(e.cursor) === i || e.source.codePointAt(e.cursor) === o ? !!isDigitCodePoint(e.source.codePointAt(e.cursor + 1) ?? -1) || 46 === e.source.codePointAt(e.cursor + 1) && isDigitCodePoint(e.source.codePointAt(e.cursor + 2) ?? -1) : 46 === e.source.codePointAt(e.cursor) ? isDigitCodePoint(e.source.codePointAt(e.cursor + 1) ?? -1) : isDigitCodePoint(e.source.codePointAt(e.cursor) ?? -1);
}
function checkIfTwoCodePointsStartAComment(e) {
    return 47 === e.source.codePointAt(e.cursor) && 42 === e.source.codePointAt(e.cursor + 1);
}
function checkIfThreeCodePointsWouldStartCDC(e) {
    return e.source.codePointAt(e.cursor) === o && e.source.codePointAt(e.cursor + 1) === o && 62 === e.source.codePointAt(e.cursor + 2);
}
var c, a, u;
function mirrorVariantType(e) {
    switch(e){
        case c.OpenParen:
            return c.CloseParen;
        case c.CloseParen:
            return c.OpenParen;
        case c.OpenCurly:
            return c.CloseCurly;
        case c.CloseCurly:
            return c.OpenCurly;
        case c.OpenSquare:
            return c.CloseSquare;
        case c.CloseSquare:
            return c.OpenSquare;
        default:
            return null;
    }
}
function mirrorVariant(e) {
    switch(e[0]){
        case c.OpenParen:
            return [
                c.CloseParen,
                ")",
                -1,
                -1,
                void 0
            ];
        case c.CloseParen:
            return [
                c.OpenParen,
                "(",
                -1,
                -1,
                void 0
            ];
        case c.OpenCurly:
            return [
                c.CloseCurly,
                "}",
                -1,
                -1,
                void 0
            ];
        case c.CloseCurly:
            return [
                c.OpenCurly,
                "{",
                -1,
                -1,
                void 0
            ];
        case c.OpenSquare:
            return [
                c.CloseSquare,
                "]",
                -1,
                -1,
                void 0
            ];
        case c.CloseSquare:
            return [
                c.OpenSquare,
                "[",
                -1,
                -1,
                void 0
            ];
        default:
            return null;
    }
}
function consumeComment(n, t) {
    for(t.advanceCodePoint(2);;){
        const o = t.readCodePoint();
        if (void 0 === o) {
            const o = [
                c.Comment,
                t.source.slice(t.representationStart, t.representationEnd + 1),
                t.representationStart,
                t.representationEnd,
                void 0
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInComment, t.representationStart, t.representationEnd, [
                "4.3.2. Consume comments",
                "Unexpected EOF"
            ], o)), o;
        }
        if (42 === o && void 0 !== t.source.codePointAt(t.cursor) && 47 === t.source.codePointAt(t.cursor)) {
            t.advanceCodePoint();
            break;
        }
    }
    return [
        c.Comment,
        t.source.slice(t.representationStart, t.representationEnd + 1),
        t.representationStart,
        t.representationEnd,
        void 0
    ];
}
function consumeEscapedCodePoint(n, o) {
    const i = o.readCodePoint();
    if (void 0 === i) return n.onParseError(new ParseError(e.UnexpectedEOFInEscapedCodePoint, o.representationStart, o.representationEnd, [
        "4.3.7. Consume an escaped code point",
        "Unexpected EOF"
    ])), s;
    if (isHexDigitCodePoint(i)) {
        const e = [
            i
        ];
        let n;
        for(; void 0 !== (n = o.source.codePointAt(o.cursor)) && isHexDigitCodePoint(n) && e.length < 6;)e.push(n), o.advanceCodePoint();
        isWhitespace(o.source.codePointAt(o.cursor) ?? -1) && (o.source.codePointAt(o.cursor) === t && o.source.codePointAt(o.cursor + 1) === r && o.advanceCodePoint(), o.advanceCodePoint());
        const c = parseInt(String.fromCodePoint(...e), 16);
        return 0 === c || isSurrogate(c) || c > 1114111 ? s : c;
    }
    return 0 === i || isSurrogate(i) ? s : i;
}
function consumeIdentSequence(e, n) {
    const t = [];
    for(;;){
        const o = n.source.codePointAt(n.cursor) ?? -1;
        if (0 === o || isSurrogate(o)) t.push(s), n.advanceCodePoint(+(o > 65535) + 1);
        else if (isIdentCodePoint(o)) t.push(o), n.advanceCodePoint(+(o > 65535) + 1);
        else {
            if (!checkIfTwoCodePointsAreAValidEscape(n)) return t;
            n.advanceCodePoint(), t.push(consumeEscapedCodePoint(e, n));
        }
    }
}
function consumeHashToken(e, n) {
    n.advanceCodePoint();
    const t = n.source.codePointAt(n.cursor);
    if (void 0 !== t && (isIdentCodePoint(t) || checkIfTwoCodePointsAreAValidEscape(n))) {
        let t = u.Unrestricted;
        checkIfThreeCodePointsWouldStartAnIdentSequence(0, n) && (t = u.ID);
        const o = consumeIdentSequence(e, n);
        return [
            c.Hash,
            n.source.slice(n.representationStart, n.representationEnd + 1),
            n.representationStart,
            n.representationEnd,
            {
                value: String.fromCodePoint(...o),
                type: t
            }
        ];
    }
    return [
        c.Delim,
        "#",
        n.representationStart,
        n.representationEnd,
        {
            value: "#"
        }
    ];
}
function consumeNumber(e, n) {
    let t = a.Integer;
    for(n.source.codePointAt(n.cursor) !== i && n.source.codePointAt(n.cursor) !== o || n.advanceCodePoint(); isDigitCodePoint(n.source.codePointAt(n.cursor) ?? -1);)n.advanceCodePoint();
    if (46 === n.source.codePointAt(n.cursor) && isDigitCodePoint(n.source.codePointAt(n.cursor + 1) ?? -1)) for(n.advanceCodePoint(2), t = a.Number; isDigitCodePoint(n.source.codePointAt(n.cursor) ?? -1);)n.advanceCodePoint();
    if (101 === n.source.codePointAt(n.cursor) || 69 === n.source.codePointAt(n.cursor)) {
        if (isDigitCodePoint(n.source.codePointAt(n.cursor + 1) ?? -1)) n.advanceCodePoint(2);
        else {
            if (n.source.codePointAt(n.cursor + 1) !== o && n.source.codePointAt(n.cursor + 1) !== i || !isDigitCodePoint(n.source.codePointAt(n.cursor + 2) ?? -1)) return t;
            n.advanceCodePoint(3);
        }
        for(t = a.Number; isDigitCodePoint(n.source.codePointAt(n.cursor) ?? -1);)n.advanceCodePoint();
    }
    return t;
}
function consumeNumericToken(e, n) {
    let t;
    {
        const e = n.source.codePointAt(n.cursor);
        e === o ? t = "-" : e === i && (t = "+");
    }
    const r = consumeNumber(0, n), s = parseFloat(n.source.slice(n.representationStart, n.representationEnd + 1));
    if (checkIfThreeCodePointsWouldStartAnIdentSequence(0, n)) {
        const o = consumeIdentSequence(e, n);
        return [
            c.Dimension,
            n.source.slice(n.representationStart, n.representationEnd + 1),
            n.representationStart,
            n.representationEnd,
            {
                value: s,
                signCharacter: t,
                type: r,
                unit: String.fromCodePoint(...o)
            }
        ];
    }
    return 37 === n.source.codePointAt(n.cursor) ? (n.advanceCodePoint(), [
        c.Percentage,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            value: s,
            signCharacter: t
        }
    ]) : [
        c.Number,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            value: s,
            signCharacter: t,
            type: r
        }
    ];
}
function consumeWhiteSpace(e) {
    for(; isWhitespace(e.source.codePointAt(e.cursor) ?? -1);)e.advanceCodePoint();
    return [
        c.Whitespace,
        e.source.slice(e.representationStart, e.representationEnd + 1),
        e.representationStart,
        e.representationEnd,
        void 0
    ];
}
!function(e) {
    e.Comment = "comment", e.AtKeyword = "at-keyword-token", e.BadString = "bad-string-token", e.BadURL = "bad-url-token", e.CDC = "CDC-token", e.CDO = "CDO-token", e.Colon = "colon-token", e.Comma = "comma-token", e.Delim = "delim-token", e.Dimension = "dimension-token", e.EOF = "EOF-token", e.Function = "function-token", e.Hash = "hash-token", e.Ident = "ident-token", e.Number = "number-token", e.Percentage = "percentage-token", e.Semicolon = "semicolon-token", e.String = "string-token", e.URL = "url-token", e.Whitespace = "whitespace-token", e.OpenParen = "(-token", e.CloseParen = ")-token", e.OpenSquare = "[-token", e.CloseSquare = "]-token", e.OpenCurly = "{-token", e.CloseCurly = "}-token", e.UnicodeRange = "unicode-range-token";
}(c || (c = {})), function(e) {
    e.Integer = "integer", e.Number = "number";
}(a || (a = {})), function(e) {
    e.Unrestricted = "unrestricted", e.ID = "id";
}(u || (u = {}));
class Reader {
    cursor = 0;
    source = "";
    representationStart = 0;
    representationEnd = -1;
    constructor(e){
        this.source = e;
    }
    advanceCodePoint(e = 1) {
        this.cursor = this.cursor + e, this.representationEnd = this.cursor - 1;
    }
    readCodePoint() {
        const e = this.source.codePointAt(this.cursor);
        if (void 0 !== e) return this.cursor = this.cursor + 1, this.representationEnd = this.cursor - 1, e;
    }
    unreadCodePoint(e = 1) {
        this.cursor = this.cursor - e, this.representationEnd = this.cursor - 1;
    }
    resetRepresentation() {
        this.representationStart = this.cursor, this.representationEnd = -1;
    }
}
function consumeStringToken(n, o) {
    let i = "";
    const a = o.readCodePoint();
    for(;;){
        const u = o.readCodePoint();
        if (void 0 === u) {
            const t = [
                c.String,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                {
                    value: i
                }
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInString, o.representationStart, o.representationEnd, [
                "4.3.5. Consume a string token",
                "Unexpected EOF"
            ], t)), t;
        }
        if (isNewLine(u)) {
            o.unreadCodePoint();
            const i = [
                c.BadString,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                void 0
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedNewLineInString, o.representationStart, o.source.codePointAt(o.cursor) === t && o.source.codePointAt(o.cursor + 1) === r ? o.representationEnd + 2 : o.representationEnd + 1, [
                "4.3.5. Consume a string token",
                "Unexpected newline"
            ], i)), i;
        }
        if (u === a) return [
            c.String,
            o.source.slice(o.representationStart, o.representationEnd + 1),
            o.representationStart,
            o.representationEnd,
            {
                value: i
            }
        ];
        if (92 !== u) 0 === u || isSurrogate(u) ? i += String.fromCodePoint(s) : i += String.fromCodePoint(u);
        else {
            if (void 0 === o.source.codePointAt(o.cursor)) continue;
            if (isNewLine(o.source.codePointAt(o.cursor) ?? -1)) {
                o.source.codePointAt(o.cursor) === t && o.source.codePointAt(o.cursor + 1) === r && o.advanceCodePoint(), o.advanceCodePoint();
                continue;
            }
            i += String.fromCodePoint(consumeEscapedCodePoint(n, o));
        }
    }
}
function checkIfCodePointsMatchURLIdent(e) {
    return !(3 !== e.length || 117 !== e[0] && 85 !== e[0] || 114 !== e[1] && 82 !== e[1] || 108 !== e[2] && 76 !== e[2]);
}
function consumeBadURL(e, n) {
    for(;;){
        const t = n.source.codePointAt(n.cursor);
        if (void 0 === t) return;
        if (41 === t) return void n.advanceCodePoint();
        checkIfTwoCodePointsAreAValidEscape(n) ? (n.advanceCodePoint(), consumeEscapedCodePoint(e, n)) : n.advanceCodePoint();
    }
}
function consumeUrlToken(n, t) {
    for(; isWhitespace(t.source.codePointAt(t.cursor) ?? -1);)t.advanceCodePoint();
    let o = "";
    for(;;){
        if (void 0 === t.source.codePointAt(t.cursor)) {
            const r = [
                c.URL,
                t.source.slice(t.representationStart, t.representationEnd + 1),
                t.representationStart,
                t.representationEnd,
                {
                    value: o
                }
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInURL, t.representationStart, t.representationEnd, [
                "4.3.6. Consume a url token",
                "Unexpected EOF"
            ], r)), r;
        }
        if (41 === t.source.codePointAt(t.cursor)) return t.advanceCodePoint(), [
            c.URL,
            t.source.slice(t.representationStart, t.representationEnd + 1),
            t.representationStart,
            t.representationEnd,
            {
                value: o
            }
        ];
        if (isWhitespace(t.source.codePointAt(t.cursor) ?? -1)) {
            for(t.advanceCodePoint(); isWhitespace(t.source.codePointAt(t.cursor) ?? -1);)t.advanceCodePoint();
            if (void 0 === t.source.codePointAt(t.cursor)) {
                const r = [
                    c.URL,
                    t.source.slice(t.representationStart, t.representationEnd + 1),
                    t.representationStart,
                    t.representationEnd,
                    {
                        value: o
                    }
                ];
                return n.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInURL, t.representationStart, t.representationEnd, [
                    "4.3.6. Consume a url token",
                    "Consume as much whitespace as possible",
                    "Unexpected EOF"
                ], r)), r;
            }
            return 41 === t.source.codePointAt(t.cursor) ? (t.advanceCodePoint(), [
                c.URL,
                t.source.slice(t.representationStart, t.representationEnd + 1),
                t.representationStart,
                t.representationEnd,
                {
                    value: o
                }
            ]) : (consumeBadURL(n, t), [
                c.BadURL,
                t.source.slice(t.representationStart, t.representationEnd + 1),
                t.representationStart,
                t.representationEnd,
                void 0
            ]);
        }
        const i = t.source.codePointAt(t.cursor);
        if (34 === i || 39 === i || 40 === i || 11 === (r = i ?? -1) || 127 === r || 0 <= r && r <= 8 || 14 <= r && r <= 31) {
            consumeBadURL(n, t);
            const o = [
                c.BadURL,
                t.source.slice(t.representationStart, t.representationEnd + 1),
                t.representationStart,
                t.representationEnd,
                void 0
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedCharacterInURL, t.representationStart, t.representationEnd, [
                "4.3.6. Consume a url token",
                "Unexpected U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('), U+0028 LEFT PARENTHESIS (() or non-printable code point"
            ], o)), o;
        }
        if (92 === i) {
            if (checkIfTwoCodePointsAreAValidEscape(t)) {
                t.advanceCodePoint(), o += String.fromCodePoint(consumeEscapedCodePoint(n, t));
                continue;
            }
            consumeBadURL(n, t);
            const r = [
                c.BadURL,
                t.source.slice(t.representationStart, t.representationEnd + 1),
                t.representationStart,
                t.representationEnd,
                void 0
            ];
            return n.onParseError(new ParseErrorWithToken(e.InvalidEscapeSequenceInURL, t.representationStart, t.representationEnd, [
                "4.3.6. Consume a url token",
                "U+005C REVERSE SOLIDUS (\\)",
                "The input stream does not start with a valid escape sequence"
            ], r)), r;
        }
        0 === t.source.codePointAt(t.cursor) || isSurrogate(t.source.codePointAt(t.cursor) ?? -1) ? (o += String.fromCodePoint(s), t.advanceCodePoint()) : (o += t.source[t.cursor], t.advanceCodePoint());
    }
    var r;
}
function consumeIdentLikeToken(e, n) {
    const t = consumeIdentSequence(e, n);
    if (40 !== n.source.codePointAt(n.cursor)) return [
        c.Ident,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            value: String.fromCodePoint(...t)
        }
    ];
    if (checkIfCodePointsMatchURLIdent(t)) {
        n.advanceCodePoint();
        let o = 0;
        for(;;){
            const e = isWhitespace(n.source.codePointAt(n.cursor) ?? -1), r = isWhitespace(n.source.codePointAt(n.cursor + 1) ?? -1);
            if (e && r) {
                o += 1, n.advanceCodePoint(1);
                continue;
            }
            const i = e ? n.source.codePointAt(n.cursor + 1) : n.source.codePointAt(n.cursor);
            if (34 === i || 39 === i) return o > 0 && n.unreadCodePoint(o), [
                c.Function,
                n.source.slice(n.representationStart, n.representationEnd + 1),
                n.representationStart,
                n.representationEnd,
                {
                    value: String.fromCodePoint(...t)
                }
            ];
            break;
        }
        return consumeUrlToken(e, n);
    }
    return n.advanceCodePoint(), [
        c.Function,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            value: String.fromCodePoint(...t)
        }
    ];
}
function checkIfThreeCodePointsWouldStartAUnicodeRange(e) {
    return !(117 !== e.source.codePointAt(e.cursor) && 85 !== e.source.codePointAt(e.cursor) || e.source.codePointAt(e.cursor + 1) !== i || 63 !== e.source.codePointAt(e.cursor + 2) && !isHexDigitCodePoint(e.source.codePointAt(e.cursor + 2) ?? -1));
}
function consumeUnicodeRangeToken(e, n) {
    n.advanceCodePoint(2);
    const t = [], r = [];
    let i;
    for(; void 0 !== (i = n.source.codePointAt(n.cursor)) && t.length < 6 && isHexDigitCodePoint(i);)t.push(i), n.advanceCodePoint();
    for(; void 0 !== (i = n.source.codePointAt(n.cursor)) && t.length < 6 && 63 === i;)0 === r.length && r.push(...t), t.push(48), r.push(70), n.advanceCodePoint();
    if (!r.length && n.source.codePointAt(n.cursor) === o && isHexDigitCodePoint(n.source.codePointAt(n.cursor + 1) ?? -1)) for(n.advanceCodePoint(); void 0 !== (i = n.source.codePointAt(n.cursor)) && r.length < 6 && isHexDigitCodePoint(i);)r.push(i), n.advanceCodePoint();
    if (!r.length) {
        const e = parseInt(String.fromCodePoint(...t), 16);
        return [
            c.UnicodeRange,
            n.source.slice(n.representationStart, n.representationEnd + 1),
            n.representationStart,
            n.representationEnd,
            {
                startOfRange: e,
                endOfRange: e
            }
        ];
    }
    const s = parseInt(String.fromCodePoint(...t), 16), a = parseInt(String.fromCodePoint(...r), 16);
    return [
        c.UnicodeRange,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            startOfRange: s,
            endOfRange: a
        }
    ];
}
function tokenize(e, n) {
    const t = tokenizer(e, n), o = [];
    for(; !t.endOfFile();)o.push(t.nextToken());
    return o.push(t.nextToken()), o;
}
function tokenizer(n, s) {
    const a = n.css.valueOf(), u = n.unicodeRangesAllowed ?? !1, d = new Reader(a), p = {
        onParseError: s?.onParseError ?? noop
    };
    return {
        nextToken: function nextToken() {
            d.resetRepresentation();
            const n = d.source.codePointAt(d.cursor);
            if (void 0 === n) return [
                c.EOF,
                "",
                -1,
                -1,
                void 0
            ];
            if (47 === n && checkIfTwoCodePointsStartAComment(d)) return consumeComment(p, d);
            if (u && (117 === n || 85 === n) && checkIfThreeCodePointsWouldStartAUnicodeRange(d)) return consumeUnicodeRangeToken(0, d);
            if (isIdentStartCodePoint(n)) return consumeIdentLikeToken(p, d);
            if (isDigitCodePoint(n)) return consumeNumericToken(p, d);
            switch(n){
                case 44:
                    return d.advanceCodePoint(), [
                        c.Comma,
                        ",",
                        d.representationStart,
                        d.representationEnd,
                        void 0
                    ];
                case 58:
                    return d.advanceCodePoint(), [
                        c.Colon,
                        ":",
                        d.representationStart,
                        d.representationEnd,
                        void 0
                    ];
                case 59:
                    return d.advanceCodePoint(), [
                        c.Semicolon,
                        ";",
                        d.representationStart,
                        d.representationEnd,
                        void 0
                    ];
                case 40:
                    return d.advanceCodePoint(), [
                        c.OpenParen,
                        "(",
                        d.representationStart,
                        d.representationEnd,
                        void 0
                    ];
                case 41:
                    return d.advanceCodePoint(), [
                        c.CloseParen,
                        ")",
                        d.representationStart,
                        d.representationEnd,
                        void 0
                    ];
                case 91:
                    return d.advanceCodePoint(), [
                        c.OpenSquare,
                        "[",
                        d.representationStart,
                        d.representationEnd,
                        void 0
                    ];
                case 93:
                    return d.advanceCodePoint(), [
                        c.CloseSquare,
                        "]",
                        d.representationStart,
                        d.representationEnd,
                        void 0
                    ];
                case 123:
                    return d.advanceCodePoint(), [
                        c.OpenCurly,
                        "{",
                        d.representationStart,
                        d.representationEnd,
                        void 0
                    ];
                case 125:
                    return d.advanceCodePoint(), [
                        c.CloseCurly,
                        "}",
                        d.representationStart,
                        d.representationEnd,
                        void 0
                    ];
                case 39:
                case 34:
                    return consumeStringToken(p, d);
                case 35:
                    return consumeHashToken(p, d);
                case i:
                case 46:
                    return checkIfThreeCodePointsWouldStartANumber(d) ? consumeNumericToken(p, d) : (d.advanceCodePoint(), [
                        c.Delim,
                        d.source[d.representationStart],
                        d.representationStart,
                        d.representationEnd,
                        {
                            value: d.source[d.representationStart]
                        }
                    ]);
                case r:
                case t:
                case 12:
                case 9:
                case 32:
                    return consumeWhiteSpace(d);
                case o:
                    return checkIfThreeCodePointsWouldStartANumber(d) ? consumeNumericToken(p, d) : checkIfThreeCodePointsWouldStartCDC(d) ? (d.advanceCodePoint(3), [
                        c.CDC,
                        "--\x3e",
                        d.representationStart,
                        d.representationEnd,
                        void 0
                    ]) : checkIfThreeCodePointsWouldStartAnIdentSequence(0, d) ? consumeIdentLikeToken(p, d) : (d.advanceCodePoint(), [
                        c.Delim,
                        "-",
                        d.representationStart,
                        d.representationEnd,
                        {
                            value: "-"
                        }
                    ]);
                case 60:
                    return checkIfFourCodePointsWouldStartCDO(d) ? (d.advanceCodePoint(4), [
                        c.CDO,
                        "\x3c!--",
                        d.representationStart,
                        d.representationEnd,
                        void 0
                    ]) : (d.advanceCodePoint(), [
                        c.Delim,
                        "<",
                        d.representationStart,
                        d.representationEnd,
                        {
                            value: "<"
                        }
                    ]);
                case 64:
                    if (d.advanceCodePoint(), checkIfThreeCodePointsWouldStartAnIdentSequence(0, d)) {
                        const e = consumeIdentSequence(p, d);
                        return [
                            c.AtKeyword,
                            d.source.slice(d.representationStart, d.representationEnd + 1),
                            d.representationStart,
                            d.representationEnd,
                            {
                                value: String.fromCodePoint(...e)
                            }
                        ];
                    }
                    return [
                        c.Delim,
                        "@",
                        d.representationStart,
                        d.representationEnd,
                        {
                            value: "@"
                        }
                    ];
                case 92:
                    {
                        if (checkIfTwoCodePointsAreAValidEscape(d)) return consumeIdentLikeToken(p, d);
                        d.advanceCodePoint();
                        const n = [
                            c.Delim,
                            "\\",
                            d.representationStart,
                            d.representationEnd,
                            {
                                value: "\\"
                            }
                        ];
                        return p.onParseError(new ParseErrorWithToken(e.InvalidEscapeSequenceAfterBackslash, d.representationStart, d.representationEnd, [
                            "4.3.1. Consume a token",
                            "U+005C REVERSE SOLIDUS (\\)",
                            "The input stream does not start with a valid escape sequence"
                        ], n)), n;
                    }
            }
            return d.advanceCodePoint(), [
                c.Delim,
                d.source[d.representationStart],
                d.representationStart,
                d.representationEnd,
                {
                    value: d.source[d.representationStart]
                }
            ];
        },
        endOfFile: function endOfFile() {
            return void 0 === d.source.codePointAt(d.cursor);
        }
    };
}
function noop() {}
function mutateIdent(e, n) {
    const t = [];
    for (const e of n)t.push(e.codePointAt(0));
    const o = String.fromCodePoint(...ensureThatValueRoundTripsAsIdent(t));
    e[1] = o, e[4].value = n;
}
function mutateUnit(e, n) {
    const t = [];
    for (const e of n)t.push(e.codePointAt(0));
    const o = ensureThatValueRoundTripsAsIdent(t);
    101 === o[0] && insertEscapedCodePoint(o, 0, o[0]);
    const r = String.fromCodePoint(...o), i = "+" === e[4].signCharacter ? e[4].signCharacter : "", s = e[4].value.toString();
    e[1] = `${i}${s}${r}`, e[4].unit = n;
}
function ensureThatValueRoundTripsAsIdent(e) {
    let n = 0;
    e[0] === o && e[1] === o ? n = 2 : e[0] === o && e[1] ? (n = 2, isIdentStartCodePoint(e[1]) || (n += insertEscapedCodePoint(e, 1, e[1]))) : isIdentStartCodePoint(e[0]) ? n = 1 : (n = 1, n += insertEscapedCodePoint(e, 0, e[0]));
    for(let t = n; t < e.length; t++)isIdentCodePoint(e[t]) || (t += insertEscapedCodePoint(e, t, e[t]));
    return e;
}
function insertEscapedCodePoint(e, n, t) {
    const o = t.toString(16), r = [];
    for (const e of o)r.push(e.codePointAt(0));
    const i = e[n + 1];
    return n === e.length - 1 || i && isHexDigitCodePoint(i) ? (e.splice(n, 1, 92, ...r, 32), 1 + r.length) : (e.splice(n, 1, 92, ...r), r.length);
}
const d = Object.values(c);
function isToken(e) {
    return !!Array.isArray(e) && !(e.length < 4) && !!d.includes(e[0]) && "string" == typeof e[1] && "number" == typeof e[2] && "number" == typeof e[3];
}
function isTokenNumeric(e) {
    if (!e) return !1;
    switch(e[0]){
        case c.Dimension:
        case c.Number:
        case c.Percentage:
            return !0;
        default:
            return !1;
    }
}
function isTokenWhiteSpaceOrComment(e) {
    if (!e) return !1;
    switch(e[0]){
        case c.Whitespace:
        case c.Comment:
            return !0;
        default:
            return !1;
    }
}
function isTokenAtKeyword(e) {
    return !!e && e[0] === c.AtKeyword;
}
function isTokenBadString(e) {
    return !!e && e[0] === c.BadString;
}
function isTokenBadURL(e) {
    return !!e && e[0] === c.BadURL;
}
function isTokenCDC(e) {
    return !!e && e[0] === c.CDC;
}
function isTokenCDO(e) {
    return !!e && e[0] === c.CDO;
}
function isTokenColon(e) {
    return !!e && e[0] === c.Colon;
}
function isTokenComma(e) {
    return !!e && e[0] === c.Comma;
}
function isTokenComment(e) {
    return !!e && e[0] === c.Comment;
}
function isTokenDelim(e) {
    return !!e && e[0] === c.Delim;
}
function isTokenDimension(e) {
    return !!e && e[0] === c.Dimension;
}
function isTokenEOF(e) {
    return !!e && e[0] === c.EOF;
}
function isTokenFunction(e) {
    return !!e && e[0] === c.Function;
}
function isTokenHash(e) {
    return !!e && e[0] === c.Hash;
}
function isTokenIdent(e) {
    return !!e && e[0] === c.Ident;
}
function isTokenNumber(e) {
    return !!e && e[0] === c.Number;
}
function isTokenPercentage(e) {
    return !!e && e[0] === c.Percentage;
}
function isTokenSemicolon(e) {
    return !!e && e[0] === c.Semicolon;
}
function isTokenString(e) {
    return !!e && e[0] === c.String;
}
function isTokenURL(e) {
    return !!e && e[0] === c.URL;
}
function isTokenWhitespace(e) {
    return !!e && e[0] === c.Whitespace;
}
function isTokenOpenParen(e) {
    return !!e && e[0] === c.OpenParen;
}
function isTokenCloseParen(e) {
    return !!e && e[0] === c.CloseParen;
}
function isTokenOpenSquare(e) {
    return !!e && e[0] === c.OpenSquare;
}
function isTokenCloseSquare(e) {
    return !!e && e[0] === c.CloseSquare;
}
function isTokenOpenCurly(e) {
    return !!e && e[0] === c.OpenCurly;
}
function isTokenCloseCurly(e) {
    return !!e && e[0] === c.CloseCurly;
}
function isTokenUnicodeRange(e) {
    return !!e && e[0] === c.UnicodeRange;
}
;
}}),
"[project]/node_modules/fastest-levenshtein/esm/mod.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "closest": (()=>closest),
    "distance": (()=>distance)
});
const peq = new Uint32Array(0x10000);
const myers_32 = (a, b)=>{
    const n = a.length;
    const m = b.length;
    const lst = 1 << n - 1;
    let pv = -1;
    let mv = 0;
    let sc = n;
    let i = n;
    while(i--){
        peq[a.charCodeAt(i)] |= 1 << i;
    }
    for(i = 0; i < m; i++){
        let eq = peq[b.charCodeAt(i)];
        const xv = eq | mv;
        eq |= (eq & pv) + pv ^ pv;
        mv |= ~(eq | pv);
        pv &= eq;
        if (mv & lst) {
            sc++;
        }
        if (pv & lst) {
            sc--;
        }
        mv = mv << 1 | 1;
        pv = pv << 1 | ~(xv | mv);
        mv &= xv;
    }
    i = n;
    while(i--){
        peq[a.charCodeAt(i)] = 0;
    }
    return sc;
};
const myers_x = (b, a)=>{
    const n = a.length;
    const m = b.length;
    const mhc = [];
    const phc = [];
    const hsize = Math.ceil(n / 32);
    const vsize = Math.ceil(m / 32);
    for(let i = 0; i < hsize; i++){
        phc[i] = -1;
        mhc[i] = 0;
    }
    let j = 0;
    for(; j < vsize - 1; j++){
        let mv = 0;
        let pv = -1;
        const start = j * 32;
        const vlen = Math.min(32, m) + start;
        for(let k = start; k < vlen; k++){
            peq[b.charCodeAt(k)] |= 1 << k;
        }
        for(let i = 0; i < n; i++){
            const eq = peq[a.charCodeAt(i)];
            const pb = phc[i / 32 | 0] >>> i & 1;
            const mb = mhc[i / 32 | 0] >>> i & 1;
            const xv = eq | mv;
            const xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
            let ph = mv | ~(xh | pv);
            let mh = pv & xh;
            if (ph >>> 31 ^ pb) {
                phc[i / 32 | 0] ^= 1 << i;
            }
            if (mh >>> 31 ^ mb) {
                mhc[i / 32 | 0] ^= 1 << i;
            }
            ph = ph << 1 | pb;
            mh = mh << 1 | mb;
            pv = mh | ~(xv | ph);
            mv = ph & xv;
        }
        for(let k = start; k < vlen; k++){
            peq[b.charCodeAt(k)] = 0;
        }
    }
    let mv = 0;
    let pv = -1;
    const start = j * 32;
    const vlen = Math.min(32, m - start) + start;
    for(let k = start; k < vlen; k++){
        peq[b.charCodeAt(k)] |= 1 << k;
    }
    let score = m;
    for(let i = 0; i < n; i++){
        const eq = peq[a.charCodeAt(i)];
        const pb = phc[i / 32 | 0] >>> i & 1;
        const mb = mhc[i / 32 | 0] >>> i & 1;
        const xv = eq | mv;
        const xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
        let ph = mv | ~(xh | pv);
        let mh = pv & xh;
        score += ph >>> m - 1 & 1;
        score -= mh >>> m - 1 & 1;
        if (ph >>> 31 ^ pb) {
            phc[i / 32 | 0] ^= 1 << i;
        }
        if (mh >>> 31 ^ mb) {
            mhc[i / 32 | 0] ^= 1 << i;
        }
        ph = ph << 1 | pb;
        mh = mh << 1 | mb;
        pv = mh | ~(xv | ph);
        mv = ph & xv;
    }
    for(let k = start; k < vlen; k++){
        peq[b.charCodeAt(k)] = 0;
    }
    return score;
};
const distance = (a, b)=>{
    if (a.length < b.length) {
        const tmp = b;
        b = a;
        a = tmp;
    }
    if (b.length === 0) {
        return a.length;
    }
    if (a.length <= 32) {
        return myers_32(a, b);
    }
    return myers_x(a, b);
};
const closest = (str, arr)=>{
    let min_distance = Infinity;
    let min_index = 0;
    for(let i = 0; i < arr.length; i++){
        const dist = distance(str, arr[i]);
        if (dist < min_distance) {
            min_distance = dist;
            min_index = i;
        }
    }
    return arr[min_index];
};
;
}}),
"[project]/node_modules/table/node_modules/ansi-regex/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = ({ onlyFirst = false } = {})=>{
    const pattern = [
        '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
    ].join('|');
    return new RegExp(pattern, onlyFirst ? undefined : 'g');
};
}}),
"[project]/node_modules/table/node_modules/strip-ansi/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const ansiRegex = __turbopack_context__.r("[project]/node_modules/table/node_modules/ansi-regex/index.js [app-route] (ecmascript)");
module.exports = (string)=>typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
}}),
"[project]/node_modules/is-fullwidth-code-point/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable yoda */ 'use strict';
const isFullwidthCodePoint = (codePoint)=>{
    if (Number.isNaN(codePoint)) {
        return false;
    }
    // Code points are derived from:
    // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
    if (codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo
    codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
    codePoint === 0x232A || 0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || 0x3250 <= codePoint && codePoint <= 0x4DBF || 0x4E00 <= codePoint && codePoint <= 0xA4C6 || 0xA960 <= codePoint && codePoint <= 0xA97C || 0xAC00 <= codePoint && codePoint <= 0xD7A3 || 0xF900 <= codePoint && codePoint <= 0xFAFF || 0xFE10 <= codePoint && codePoint <= 0xFE19 || 0xFE30 <= codePoint && codePoint <= 0xFE6B || 0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || 0x1B000 <= codePoint && codePoint <= 0x1B001 || 0x1F200 <= codePoint && codePoint <= 0x1F251 || 0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
        return true;
    }
    return false;
};
module.exports = isFullwidthCodePoint;
module.exports.default = isFullwidthCodePoint;
}}),
"[project]/node_modules/table/node_modules/emoji-regex/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = function() {
    // https://mths.be/emoji
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
}}),
"[project]/node_modules/table/node_modules/string-width/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const stripAnsi = __turbopack_context__.r("[project]/node_modules/table/node_modules/strip-ansi/index.js [app-route] (ecmascript)");
const isFullwidthCodePoint = __turbopack_context__.r("[project]/node_modules/is-fullwidth-code-point/index.js [app-route] (ecmascript)");
const emojiRegex = __turbopack_context__.r("[project]/node_modules/table/node_modules/emoji-regex/index.js [app-route] (ecmascript)");
const stringWidth = (string)=>{
    if (typeof string !== 'string' || string.length === 0) {
        return 0;
    }
    string = stripAnsi(string);
    if (string.length === 0) {
        return 0;
    }
    string = string.replace(emojiRegex(), '  ');
    let width = 0;
    for(let i = 0; i < string.length; i++){
        const code = string.codePointAt(i);
        // Ignore control characters
        if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {
            continue;
        }
        // Ignore combining characters
        if (code >= 0x300 && code <= 0x36F) {
            continue;
        }
        // Surrogates
        if (code > 0xFFFF) {
            i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
};
module.exports = stringWidth;
// TODO: remove this in the next major version
module.exports.default = stringWidth;
}}),
"[project]/node_modules/astral-regex/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const regex = '[\uD800-\uDBFF][\uDC00-\uDFFF]';
const astralRegex = (options)=>options && options.exact ? new RegExp(`^${regex}$`) : new RegExp(regex, 'g');
module.exports = astralRegex;
}}),
"[project]/node_modules/color-name/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = {
    "aliceblue": [
        240,
        248,
        255
    ],
    "antiquewhite": [
        250,
        235,
        215
    ],
    "aqua": [
        0,
        255,
        255
    ],
    "aquamarine": [
        127,
        255,
        212
    ],
    "azure": [
        240,
        255,
        255
    ],
    "beige": [
        245,
        245,
        220
    ],
    "bisque": [
        255,
        228,
        196
    ],
    "black": [
        0,
        0,
        0
    ],
    "blanchedalmond": [
        255,
        235,
        205
    ],
    "blue": [
        0,
        0,
        255
    ],
    "blueviolet": [
        138,
        43,
        226
    ],
    "brown": [
        165,
        42,
        42
    ],
    "burlywood": [
        222,
        184,
        135
    ],
    "cadetblue": [
        95,
        158,
        160
    ],
    "chartreuse": [
        127,
        255,
        0
    ],
    "chocolate": [
        210,
        105,
        30
    ],
    "coral": [
        255,
        127,
        80
    ],
    "cornflowerblue": [
        100,
        149,
        237
    ],
    "cornsilk": [
        255,
        248,
        220
    ],
    "crimson": [
        220,
        20,
        60
    ],
    "cyan": [
        0,
        255,
        255
    ],
    "darkblue": [
        0,
        0,
        139
    ],
    "darkcyan": [
        0,
        139,
        139
    ],
    "darkgoldenrod": [
        184,
        134,
        11
    ],
    "darkgray": [
        169,
        169,
        169
    ],
    "darkgreen": [
        0,
        100,
        0
    ],
    "darkgrey": [
        169,
        169,
        169
    ],
    "darkkhaki": [
        189,
        183,
        107
    ],
    "darkmagenta": [
        139,
        0,
        139
    ],
    "darkolivegreen": [
        85,
        107,
        47
    ],
    "darkorange": [
        255,
        140,
        0
    ],
    "darkorchid": [
        153,
        50,
        204
    ],
    "darkred": [
        139,
        0,
        0
    ],
    "darksalmon": [
        233,
        150,
        122
    ],
    "darkseagreen": [
        143,
        188,
        143
    ],
    "darkslateblue": [
        72,
        61,
        139
    ],
    "darkslategray": [
        47,
        79,
        79
    ],
    "darkslategrey": [
        47,
        79,
        79
    ],
    "darkturquoise": [
        0,
        206,
        209
    ],
    "darkviolet": [
        148,
        0,
        211
    ],
    "deeppink": [
        255,
        20,
        147
    ],
    "deepskyblue": [
        0,
        191,
        255
    ],
    "dimgray": [
        105,
        105,
        105
    ],
    "dimgrey": [
        105,
        105,
        105
    ],
    "dodgerblue": [
        30,
        144,
        255
    ],
    "firebrick": [
        178,
        34,
        34
    ],
    "floralwhite": [
        255,
        250,
        240
    ],
    "forestgreen": [
        34,
        139,
        34
    ],
    "fuchsia": [
        255,
        0,
        255
    ],
    "gainsboro": [
        220,
        220,
        220
    ],
    "ghostwhite": [
        248,
        248,
        255
    ],
    "gold": [
        255,
        215,
        0
    ],
    "goldenrod": [
        218,
        165,
        32
    ],
    "gray": [
        128,
        128,
        128
    ],
    "green": [
        0,
        128,
        0
    ],
    "greenyellow": [
        173,
        255,
        47
    ],
    "grey": [
        128,
        128,
        128
    ],
    "honeydew": [
        240,
        255,
        240
    ],
    "hotpink": [
        255,
        105,
        180
    ],
    "indianred": [
        205,
        92,
        92
    ],
    "indigo": [
        75,
        0,
        130
    ],
    "ivory": [
        255,
        255,
        240
    ],
    "khaki": [
        240,
        230,
        140
    ],
    "lavender": [
        230,
        230,
        250
    ],
    "lavenderblush": [
        255,
        240,
        245
    ],
    "lawngreen": [
        124,
        252,
        0
    ],
    "lemonchiffon": [
        255,
        250,
        205
    ],
    "lightblue": [
        173,
        216,
        230
    ],
    "lightcoral": [
        240,
        128,
        128
    ],
    "lightcyan": [
        224,
        255,
        255
    ],
    "lightgoldenrodyellow": [
        250,
        250,
        210
    ],
    "lightgray": [
        211,
        211,
        211
    ],
    "lightgreen": [
        144,
        238,
        144
    ],
    "lightgrey": [
        211,
        211,
        211
    ],
    "lightpink": [
        255,
        182,
        193
    ],
    "lightsalmon": [
        255,
        160,
        122
    ],
    "lightseagreen": [
        32,
        178,
        170
    ],
    "lightskyblue": [
        135,
        206,
        250
    ],
    "lightslategray": [
        119,
        136,
        153
    ],
    "lightslategrey": [
        119,
        136,
        153
    ],
    "lightsteelblue": [
        176,
        196,
        222
    ],
    "lightyellow": [
        255,
        255,
        224
    ],
    "lime": [
        0,
        255,
        0
    ],
    "limegreen": [
        50,
        205,
        50
    ],
    "linen": [
        250,
        240,
        230
    ],
    "magenta": [
        255,
        0,
        255
    ],
    "maroon": [
        128,
        0,
        0
    ],
    "mediumaquamarine": [
        102,
        205,
        170
    ],
    "mediumblue": [
        0,
        0,
        205
    ],
    "mediumorchid": [
        186,
        85,
        211
    ],
    "mediumpurple": [
        147,
        112,
        219
    ],
    "mediumseagreen": [
        60,
        179,
        113
    ],
    "mediumslateblue": [
        123,
        104,
        238
    ],
    "mediumspringgreen": [
        0,
        250,
        154
    ],
    "mediumturquoise": [
        72,
        209,
        204
    ],
    "mediumvioletred": [
        199,
        21,
        133
    ],
    "midnightblue": [
        25,
        25,
        112
    ],
    "mintcream": [
        245,
        255,
        250
    ],
    "mistyrose": [
        255,
        228,
        225
    ],
    "moccasin": [
        255,
        228,
        181
    ],
    "navajowhite": [
        255,
        222,
        173
    ],
    "navy": [
        0,
        0,
        128
    ],
    "oldlace": [
        253,
        245,
        230
    ],
    "olive": [
        128,
        128,
        0
    ],
    "olivedrab": [
        107,
        142,
        35
    ],
    "orange": [
        255,
        165,
        0
    ],
    "orangered": [
        255,
        69,
        0
    ],
    "orchid": [
        218,
        112,
        214
    ],
    "palegoldenrod": [
        238,
        232,
        170
    ],
    "palegreen": [
        152,
        251,
        152
    ],
    "paleturquoise": [
        175,
        238,
        238
    ],
    "palevioletred": [
        219,
        112,
        147
    ],
    "papayawhip": [
        255,
        239,
        213
    ],
    "peachpuff": [
        255,
        218,
        185
    ],
    "peru": [
        205,
        133,
        63
    ],
    "pink": [
        255,
        192,
        203
    ],
    "plum": [
        221,
        160,
        221
    ],
    "powderblue": [
        176,
        224,
        230
    ],
    "purple": [
        128,
        0,
        128
    ],
    "rebeccapurple": [
        102,
        51,
        153
    ],
    "red": [
        255,
        0,
        0
    ],
    "rosybrown": [
        188,
        143,
        143
    ],
    "royalblue": [
        65,
        105,
        225
    ],
    "saddlebrown": [
        139,
        69,
        19
    ],
    "salmon": [
        250,
        128,
        114
    ],
    "sandybrown": [
        244,
        164,
        96
    ],
    "seagreen": [
        46,
        139,
        87
    ],
    "seashell": [
        255,
        245,
        238
    ],
    "sienna": [
        160,
        82,
        45
    ],
    "silver": [
        192,
        192,
        192
    ],
    "skyblue": [
        135,
        206,
        235
    ],
    "slateblue": [
        106,
        90,
        205
    ],
    "slategray": [
        112,
        128,
        144
    ],
    "slategrey": [
        112,
        128,
        144
    ],
    "snow": [
        255,
        250,
        250
    ],
    "springgreen": [
        0,
        255,
        127
    ],
    "steelblue": [
        70,
        130,
        180
    ],
    "tan": [
        210,
        180,
        140
    ],
    "teal": [
        0,
        128,
        128
    ],
    "thistle": [
        216,
        191,
        216
    ],
    "tomato": [
        255,
        99,
        71
    ],
    "turquoise": [
        64,
        224,
        208
    ],
    "violet": [
        238,
        130,
        238
    ],
    "wheat": [
        245,
        222,
        179
    ],
    "white": [
        255,
        255,
        255
    ],
    "whitesmoke": [
        245,
        245,
        245
    ],
    "yellow": [
        255,
        255,
        0
    ],
    "yellowgreen": [
        154,
        205,
        50
    ]
};
}}),
"[project]/node_modules/color-convert/conversions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* MIT license */ /* eslint-disable no-mixed-operators */ const cssKeywords = __turbopack_context__.r("[project]/node_modules/color-name/index.js [app-route] (ecmascript)");
// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)
const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)){
    reverseKeywords[cssKeywords[key]] = key;
}
const convert = {
    rgb: {
        channels: 3,
        labels: 'rgb'
    },
    hsl: {
        channels: 3,
        labels: 'hsl'
    },
    hsv: {
        channels: 3,
        labels: 'hsv'
    },
    hwb: {
        channels: 3,
        labels: 'hwb'
    },
    cmyk: {
        channels: 4,
        labels: 'cmyk'
    },
    xyz: {
        channels: 3,
        labels: 'xyz'
    },
    lab: {
        channels: 3,
        labels: 'lab'
    },
    lch: {
        channels: 3,
        labels: 'lch'
    },
    hex: {
        channels: 1,
        labels: [
            'hex'
        ]
    },
    keyword: {
        channels: 1,
        labels: [
            'keyword'
        ]
    },
    ansi16: {
        channels: 1,
        labels: [
            'ansi16'
        ]
    },
    ansi256: {
        channels: 1,
        labels: [
            'ansi256'
        ]
    },
    hcg: {
        channels: 3,
        labels: [
            'h',
            'c',
            'g'
        ]
    },
    apple: {
        channels: 3,
        labels: [
            'r16',
            'g16',
            'b16'
        ]
    },
    gray: {
        channels: 1,
        labels: [
            'gray'
        ]
    }
};
module.exports = convert;
// Hide .channels and .labels properties
for (const model of Object.keys(convert)){
    if (!('channels' in convert[model])) {
        throw new Error('missing channels property: ' + model);
    }
    if (!('labels' in convert[model])) {
        throw new Error('missing channel labels property: ' + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
        throw new Error('channel and label counts mismatch: ' + model);
    }
    const { channels, labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], 'channels', {
        value: channels
    });
    Object.defineProperty(convert[model], 'labels', {
        value: labels
    });
}
convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
        h = 0;
    } else if (r === max) {
        h = (g - b) / delta;
    } else if (g === max) {
        h = 2 + (b - r) / delta;
    } else if (b === max) {
        h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
        h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
        s = 0;
    } else if (l <= 0.5) {
        s = delta / (max + min);
    } else {
        s = delta / (2 - max - min);
    }
    return [
        h,
        s * 100,
        l * 100
    ];
};
convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
        h = 0;
        s = 0;
    } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
            h = bdif - gdif;
        } else if (g === v) {
            h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
            h += 1;
        } else if (h > 1) {
            h -= 1;
        }
    }
    return [
        h * 360,
        s * 100,
        v * 100
    ];
};
convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [
        h,
        w * 100,
        b * 100
    ];
};
convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [
        c * 100,
        m * 100,
        y * 100,
        k * 100
    ];
};
function comparativeDistance(x, y) {
    /*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/ return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
}
convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
        return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)){
        const value = cssKeywords[keyword];
        // Compute comparative distance
        const distance = comparativeDistance(rgb, value);
        // Check if its less, if so set as closest
        if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
        }
    }
    return currentClosestKeyword;
};
convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
};
convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    // Assume sRGB
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [
        x * 100,
        y * 100,
        z * 100
    ];
};
convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [
        l,
        a,
        b
    ];
};
convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
        val = l * 255;
        return [
            val,
            val,
            val
        ];
    }
    if (l < 0.5) {
        t2 = l * (1 + s);
    } else {
        t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [
        0,
        0,
        0
    ];
    for(let i = 0; i < 3; i++){
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
            t3++;
        }
        if (t3 > 1) {
            t3--;
        }
        if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
            val = t2;
        } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
            val = t1;
        }
        rgb[i] = val * 255;
    }
    return rgb;
};
convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [
        h,
        sv * 100,
        v * 100
    ];
};
convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch(hi){
        case 0:
            return [
                v,
                t,
                p
            ];
        case 1:
            return [
                q,
                v,
                p
            ];
        case 2:
            return [
                p,
                v,
                t
            ];
        case 3:
            return [
                p,
                q,
                v
            ];
        case 4:
            return [
                t,
                p,
                v
            ];
        case 5:
            return [
                v,
                p,
                q
            ];
    }
};
convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [
        h,
        sl * 100,
        l * 100
    ];
};
// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    // Wh + bl cant be > 1
    if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 0x01) !== 0) {
        f = 1 - f;
    }
    const n = wh + f * (v - wh); // Linear interpolation
    let r;
    let g;
    let b;
    /* eslint-disable max-statements-per-line,no-multi-spaces */ switch(i){
        default:
        case 6:
        case 0:
            r = v;
            g = n;
            b = wh;
            break;
        case 1:
            r = n;
            g = v;
            b = wh;
            break;
        case 2:
            r = wh;
            g = v;
            b = n;
            break;
        case 3:
            r = wh;
            g = n;
            b = v;
            break;
        case 4:
            r = n;
            g = wh;
            b = v;
            break;
        case 5:
            r = v;
            g = wh;
            b = n;
            break;
    }
    /* eslint-enable max-statements-per-line,no-multi-spaces */ return [
        r * 255,
        g * 255,
        b * 255
    ];
};
convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570;
    // Assume sRGB
    r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [
        l,
        a,
        b
    ];
};
convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [
        x,
        y,
        z
    ];
};
convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
        h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [
        l,
        c,
        h
    ];
};
convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [
        l,
        a,
        b
    ];
};
convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization
    value = Math.round(value / 50);
    if (value === 0) {
        return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
        ansi += 60;
    }
    return ansi;
};
convert.hsv.ansi16 = function(args) {
    // Optimization here; we already know the value and don't need to get
    // it converted for us.
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};
convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    // We use the extended greyscale palette here, with the exception of
    // black and white. normal palette only has 4 greyscale shades.
    if (r === g && g === b) {
        if (r < 8) {
            return 16;
        }
        if (r > 248) {
            return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
};
convert.ansi16.rgb = function(args) {
    let color = args % 10;
    // Handle greyscale
    if (color === 0 || color === 7) {
        if (args > 50) {
            color += 3.5;
        }
        color = color / 10.5 * 255;
        return [
            color,
            color,
            color
        ];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [
        r,
        g,
        b
    ];
};
convert.ansi256.rgb = function(args) {
    // Handle greyscale
    if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [
            c,
            c,
            c
        ];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [
        r,
        g,
        b
    ];
};
convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
};
convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
        return [
            0,
            0,
            0
        ];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
        colorString = colorString.split('').map((char)=>{
            return char + char;
        }).join('');
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 0xFF;
    const g = integer >> 8 & 0xFF;
    const b = integer & 0xFF;
    return [
        r,
        g,
        b
    ];
};
convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
        grayscale = min / (1 - chroma);
    } else {
        grayscale = 0;
    }
    if (chroma <= 0) {
        hue = 0;
    } else if (max === r) {
        hue = (g - b) / chroma % 6;
    } else if (max === g) {
        hue = 2 + (b - r) / chroma;
    } else {
        hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [
        hue * 360,
        chroma * 100,
        grayscale * 100
    ];
};
convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
    let f = 0;
    if (c < 1.0) {
        f = (l - 0.5 * c) / (1.0 - c);
    }
    return [
        hsl[0],
        c * 100,
        f * 100
    ];
};
convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1.0) {
        f = (v - c) / (1 - c);
    }
    return [
        hsv[0],
        c * 100,
        f * 100
    ];
};
convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0.0) {
        return [
            g * 255,
            g * 255,
            g * 255
        ];
    }
    const pure = [
        0,
        0,
        0
    ];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    /* eslint-disable max-statements-per-line */ switch(Math.floor(hi)){
        case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
        case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
        case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
        case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
        case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
        default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
    }
    /* eslint-enable max-statements-per-line */ mg = (1.0 - c) * g;
    return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
    ];
};
convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    let f = 0;
    if (v > 0.0) {
        f = c / v;
    }
    return [
        hcg[0],
        f * 100,
        v * 100
    ];
};
convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1.0 - c) + 0.5 * c;
    let s = 0;
    if (l > 0.0 && l < 0.5) {
        s = c / (2 * l);
    } else if (l >= 0.5 && l < 1.0) {
        s = c / (2 * (1 - l));
    }
    return [
        hcg[0],
        s * 100,
        l * 100
    ];
};
convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    return [
        hcg[0],
        (v - c) * 100,
        (1 - v) * 100
    ];
};
convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
        g = (v - c) / (1 - c);
    }
    return [
        hwb[0],
        c * 100,
        g * 100
    ];
};
convert.apple.rgb = function(apple) {
    return [
        apple[0] / 65535 * 255,
        apple[1] / 65535 * 255,
        apple[2] / 65535 * 255
    ];
};
convert.rgb.apple = function(rgb) {
    return [
        rgb[0] / 255 * 65535,
        rgb[1] / 255 * 65535,
        rgb[2] / 255 * 65535
    ];
};
convert.gray.rgb = function(args) {
    return [
        args[0] / 100 * 255,
        args[0] / 100 * 255,
        args[0] / 100 * 255
    ];
};
convert.gray.hsl = function(args) {
    return [
        0,
        0,
        args[0]
    ];
};
convert.gray.hsv = convert.gray.hsl;
convert.gray.hwb = function(gray) {
    return [
        0,
        100,
        gray[0]
    ];
};
convert.gray.cmyk = function(gray) {
    return [
        0,
        0,
        0,
        gray[0]
    ];
};
convert.gray.lab = function(gray) {
    return [
        gray[0],
        0,
        0
    ];
};
convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 0xFF;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
};
convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [
        val / 255 * 100
    ];
};
}}),
"[project]/node_modules/color-convert/route.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const conversions = __turbopack_context__.r("[project]/node_modules/color-convert/conversions.js [app-route] (ecmascript)");
/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/ function buildGraph() {
    const graph = {};
    // https://jsperf.com/object-keys-vs-for-in-with-closure/3
    const models = Object.keys(conversions);
    for(let len = models.length, i = 0; i < len; i++){
        graph[models[i]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null
        };
    }
    return graph;
}
// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [
        fromModel
    ]; // Unshift -> queue -> pop
    graph[fromModel].distance = 0;
    while(queue.length){
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for(let len = adjacents.length, i = 0; i < len; i++){
            const adjacent = adjacents[i];
            const node = graph[adjacent];
            if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue.unshift(adjacent);
            }
        }
    }
    return graph;
}
function link(from, to) {
    return function(args) {
        return to(from(args));
    };
}
function wrapConversion(toModel, graph) {
    const path = [
        graph[toModel].parent,
        toModel
    ];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while(graph[cur].parent){
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
}
module.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for(let len = models.length, i = 0; i < len; i++){
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
            continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
};
}}),
"[project]/node_modules/color-convert/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const conversions = __turbopack_context__.r("[project]/node_modules/color-convert/conversions.js [app-route] (ecmascript)");
const route = __turbopack_context__.r("[project]/node_modules/color-convert/route.js [app-route] (ecmascript)");
const convert = {};
const models = Object.keys(conversions);
function wrapRaw(fn) {
    const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === undefined || arg0 === null) {
            return arg0;
        }
        if (arg0.length > 1) {
            args = arg0;
        }
        return fn(args);
    };
    // Preserve .conversion property if there is one
    if ('conversion' in fn) {
        wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
}
function wrapRounded(fn) {
    const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === undefined || arg0 === null) {
            return arg0;
        }
        if (arg0.length > 1) {
            args = arg0;
        }
        const result = fn(args);
        // We're assuming the result is an array here.
        // see notice in conversions.js; don't use box types
        // in conversion functions.
        if (typeof result === 'object') {
            for(let len = result.length, i = 0; i < len; i++){
                result[i] = Math.round(result[i]);
            }
        }
        return result;
    };
    // Preserve .conversion property if there is one
    if ('conversion' in fn) {
        wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
}
models.forEach((fromModel)=>{
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {
        value: conversions[fromModel].channels
    });
    Object.defineProperty(convert[fromModel], 'labels', {
        value: conversions[fromModel].labels
    });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel)=>{
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
    });
});
module.exports = convert;
}}),
"[project]/node_modules/slice-ansi/node_modules/ansi-styles/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const wrapAnsi16 = (fn, offset)=>(...args)=>{
        const code = fn(...args);
        return `\u001B[${code + offset}m`;
    };
const wrapAnsi256 = (fn, offset)=>(...args)=>{
        const code = fn(...args);
        return `\u001B[${38 + offset};5;${code}m`;
    };
const wrapAnsi16m = (fn, offset)=>(...args)=>{
        const rgb = fn(...args);
        return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
const ansi2ansi = (n)=>n;
const rgb2rgb = (r, g, b)=>[
        r,
        g,
        b
    ];
const setLazyProperty = (object, property, get)=>{
    Object.defineProperty(object, property, {
        get: ()=>{
            const value = get();
            Object.defineProperty(object, property, {
                value,
                enumerable: true,
                configurable: true
            });
            return value;
        },
        enumerable: true,
        configurable: true
    });
};
/** @type {typeof import('color-convert')} */ let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground)=>{
    if (colorConvert === undefined) {
        colorConvert = __turbopack_context__.r("[project]/node_modules/color-convert/index.js [app-route] (ecmascript)");
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)){
        const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
        if (sourceSpace === targetSpace) {
            styles[name] = wrap(identity, offset);
        } else if (typeof suite === 'object') {
            styles[name] = wrap(suite[targetSpace], offset);
        }
    }
    return styles;
};
function assembleStyles() {
    const codes = new Map();
    const styles = {
        modifier: {
            reset: [
                0,
                0
            ],
            // 21 isn't widely supported and 22 does the same thing
            bold: [
                1,
                22
            ],
            dim: [
                2,
                22
            ],
            italic: [
                3,
                23
            ],
            underline: [
                4,
                24
            ],
            inverse: [
                7,
                27
            ],
            hidden: [
                8,
                28
            ],
            strikethrough: [
                9,
                29
            ]
        },
        color: {
            black: [
                30,
                39
            ],
            red: [
                31,
                39
            ],
            green: [
                32,
                39
            ],
            yellow: [
                33,
                39
            ],
            blue: [
                34,
                39
            ],
            magenta: [
                35,
                39
            ],
            cyan: [
                36,
                39
            ],
            white: [
                37,
                39
            ],
            // Bright color
            blackBright: [
                90,
                39
            ],
            redBright: [
                91,
                39
            ],
            greenBright: [
                92,
                39
            ],
            yellowBright: [
                93,
                39
            ],
            blueBright: [
                94,
                39
            ],
            magentaBright: [
                95,
                39
            ],
            cyanBright: [
                96,
                39
            ],
            whiteBright: [
                97,
                39
            ]
        },
        bgColor: {
            bgBlack: [
                40,
                49
            ],
            bgRed: [
                41,
                49
            ],
            bgGreen: [
                42,
                49
            ],
            bgYellow: [
                43,
                49
            ],
            bgBlue: [
                44,
                49
            ],
            bgMagenta: [
                45,
                49
            ],
            bgCyan: [
                46,
                49
            ],
            bgWhite: [
                47,
                49
            ],
            // Bright color
            bgBlackBright: [
                100,
                49
            ],
            bgRedBright: [
                101,
                49
            ],
            bgGreenBright: [
                102,
                49
            ],
            bgYellowBright: [
                103,
                49
            ],
            bgBlueBright: [
                104,
                49
            ],
            bgMagentaBright: [
                105,
                49
            ],
            bgCyanBright: [
                106,
                49
            ],
            bgWhiteBright: [
                107,
                49
            ]
        }
    };
    // Alias bright black as gray (and grey)
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)){
        for (const [styleName, style] of Object.entries(group)){
            styles[styleName] = {
                open: `\u001B[${style[0]}m`,
                close: `\u001B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
        });
    }
    Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false
    });
    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    setLazyProperty(styles.color, 'ansi', ()=>makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
    setLazyProperty(styles.color, 'ansi256', ()=>makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
    setLazyProperty(styles.color, 'ansi16m', ()=>makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
    setLazyProperty(styles.bgColor, 'ansi', ()=>makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
    setLazyProperty(styles.bgColor, 'ansi256', ()=>makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
    setLazyProperty(styles.bgColor, 'ansi16m', ()=>makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));
    return styles;
}
// Make the export immutable
Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles
});
}}),
"[project]/node_modules/slice-ansi/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const isFullwidthCodePoint = __turbopack_context__.r("[project]/node_modules/is-fullwidth-code-point/index.js [app-route] (ecmascript)");
const astralRegex = __turbopack_context__.r("[project]/node_modules/astral-regex/index.js [app-route] (ecmascript)");
const ansiStyles = __turbopack_context__.r("[project]/node_modules/slice-ansi/node_modules/ansi-styles/index.js [app-route] (ecmascript)");
const ESCAPES = [
    '\u001B',
    '\u009B'
];
const wrapAnsi = (code)=>`${ESCAPES[0]}[${code}m`;
const checkAnsi = (ansiCodes, isEscapes, endAnsiCode)=>{
    let output = [];
    ansiCodes = [
        ...ansiCodes
    ];
    for (let ansiCode of ansiCodes){
        const ansiCodeOrigin = ansiCode;
        if (ansiCode.includes(';')) {
            ansiCode = ansiCode.split(';')[0][0] + '0';
        }
        const item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));
        if (item) {
            const indexEscape = ansiCodes.indexOf(item.toString());
            if (indexEscape === -1) {
                output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));
            } else {
                ansiCodes.splice(indexEscape, 1);
            }
        } else if (isEscapes) {
            output.push(wrapAnsi(0));
            break;
        } else {
            output.push(wrapAnsi(ansiCodeOrigin));
        }
    }
    if (isEscapes) {
        output = output.filter((element, index)=>output.indexOf(element) === index);
        if (endAnsiCode !== undefined) {
            const fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));
            output = output.reduce((current, next)=>next === fistEscapeCode ? [
                    next,
                    ...current
                ] : [
                    ...current,
                    next
                ], []);
        }
    }
    return output.join('');
};
module.exports = (string, begin, end)=>{
    const characters = [
        ...string
    ];
    const ansiCodes = [];
    let stringEnd = typeof end === 'number' ? end : characters.length;
    let isInsideEscape = false;
    let ansiCode;
    let visible = 0;
    let output = '';
    for (const [index, character] of characters.entries()){
        let leftEscape = false;
        if (ESCAPES.includes(character)) {
            const code = /\d[^m]*/.exec(string.slice(index, index + 18));
            ansiCode = code && code.length > 0 ? code[0] : undefined;
            if (visible < stringEnd) {
                isInsideEscape = true;
                if (ansiCode !== undefined) {
                    ansiCodes.push(ansiCode);
                }
            }
        } else if (isInsideEscape && character === 'm') {
            isInsideEscape = false;
            leftEscape = true;
        }
        if (!isInsideEscape && !leftEscape) {
            visible++;
        }
        if (!astralRegex({
            exact: true
        }).test(character) && isFullwidthCodePoint(character.codePointAt())) {
            visible++;
            if (typeof end !== 'number') {
                stringEnd++;
            }
        }
        if (visible > begin && visible <= stringEnd) {
            output += character;
        } else if (visible === begin && !isInsideEscape && ansiCode !== undefined) {
            output = checkAnsi(ansiCodes);
        } else if (visible >= stringEnd) {
            output += checkAnsi(ansiCodes, true, ansiCode);
            break;
        }
    }
    return output;
};
}}),
"[project]/node_modules/fast-deep-equal/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
// do not edit .js files directly - edit src/index.jst
module.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;
            return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            var key = keys[i];
            if (!equal(a[key], b[key])) return false;
        }
        return true;
    }
    // true if both NaN, false otherwise
    return a !== a && b !== b;
};
}}),
"[project]/node_modules/ajv/dist/runtime/equal.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
// https://github.com/ajv-validator/ajv/issues/889
const equal = __turbopack_context__.r("[project]/node_modules/fast-deep-equal/index.js [app-route] (ecmascript)");
equal.code = 'require("ajv/dist/runtime/equal").default';
exports.default = equal; //# sourceMappingURL=equal.js.map
}}),
"[project]/node_modules/lodash.truncate/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as default options for `_.truncate`. */ var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;
/** `Object#toString` result references. */ var regexpTag = '[object RegExp]', symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */ var reTrim = /^\s+|\s+$/g;
/** Used to match `RegExp` flags from their coerced string values. */ var reFlags = /\w*$/;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Used to compose unicode character classes. */ var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23', rsComboSymbolsRange = '\\u20d0-\\u20f0', rsVarRange = '\\ufe0e\\ufe0f';
/** Used to compose unicode capture groups. */ var rsAstral = '[' + rsAstralRange + ']', rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsZWJ = '\\u200d';
/** Used to compose unicode regexes. */ var reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [
    rsNonAstral,
    rsRegional,
    rsSurrPair
].join('|') + ')' + rsOptVar + reOptMod + ')*', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = '(?:' + [
    rsNonAstral + rsCombo + '?',
    rsCombo,
    rsRegional,
    rsSurrPair,
    rsAstral
].join('|') + ')';
/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */ var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */ var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/** Detect free variable `exports`. */ var freeExports = ("TURBOPACK compile-time value", "object") == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && ("TURBOPACK compile-time value", "object") == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */ var nodeUtil = function() {
    try {
        return freeProcess && freeProcess.binding('util');
    } catch (e) {}
}();
/* Node.js helper references. */ var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */ var asciiSize = baseProperty('length');
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */ function asciiToArray(string) {
    return string.split('');
}
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */ function baseProperty(key) {
    return function(object) {
        return object == null ? undefined : object[key];
    };
}
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */ function hasUnicode(string) {
    return reHasUnicode.test(string);
}
/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */ function stringSize(string) {
    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
}
/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */ function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}
/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */ function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while(reUnicode.test(string)){
        result++;
    }
    return result;
}
/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */ function unicodeToArray(string) {
    return string.match(reUnicode) || [];
}
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Built-in value references. */ var Symbol = root.Symbol;
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */ function baseIsRegExp(value) {
    return isObject(value) && objectToString.call(value) == regexpTag;
}
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */ function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) {
        start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
        end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while(++index < length){
        result[index] = array[index + start];
    }
    return result;
}
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */ function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
        return value;
    }
    if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */ function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */ var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */ function toFinite(value) {
    if (!value) {
        return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
}
/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */ function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == 'number') {
        return value;
    }
    if (isSymbol(value)) {
        return NAN;
    }
    if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') {
        return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */ function toString(value) {
    return value == null ? '' : baseToString(value);
}
/**
 * Truncates `string` if it's longer than the given maximum string length.
 * The last characters of the truncated string are replaced with the omission
 * string which defaults to "...".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to truncate.
 * @param {Object} [options={}] The options object.
 * @param {number} [options.length=30] The maximum string length.
 * @param {string} [options.omission='...'] The string to indicate text is omitted.
 * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
 * @returns {string} Returns the truncated string.
 * @example
 *
 * _.truncate('hi-diddly-ho there, neighborino');
 * // => 'hi-diddly-ho there, neighbo...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': ' '
 * });
 * // => 'hi-diddly-ho there,...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': /,? +/
 * });
 * // => 'hi-diddly-ho there...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'omission': ' [...]'
 * });
 * // => 'hi-diddly-ho there, neig [...]'
 */ function truncate(string, options) {
    var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
    if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
    }
    string = toString(string);
    var strLength = string.length;
    if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
    }
    if (length >= strLength) {
        return string;
    }
    var end = length - stringSize(omission);
    if (end < 1) {
        return omission;
    }
    var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);
    if (separator === undefined) {
        return result + omission;
    }
    if (strSymbols) {
        end += result.length - end;
    }
    if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
            var match, substring = result;
            if (!separator.global) {
                separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
            }
            separator.lastIndex = 0;
            while(match = separator.exec(substring)){
                var newEnd = match.index;
            }
            result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
    } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
            result = result.slice(0, index);
        }
    }
    return result + omission;
}
module.exports = truncate;
}}),
"[project]/node_modules/fast-glob/out/utils/array.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.splitWhen = exports.flatten = void 0;
function flatten(items) {
    return items.reduce((collection, item)=>[].concat(collection, item), []);
}
exports.flatten = flatten;
function splitWhen(items, predicate) {
    const result = [
        []
    ];
    let groupIndex = 0;
    for (const item of items){
        if (predicate(item)) {
            groupIndex++;
            result[groupIndex] = [];
        } else {
            result[groupIndex].push(item);
        }
    }
    return result;
}
exports.splitWhen = splitWhen;
}}),
"[project]/node_modules/fast-glob/out/utils/errno.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isEnoentCodeError = void 0;
function isEnoentCodeError(error) {
    return error.code === 'ENOENT';
}
exports.isEnoentCodeError = isEnoentCodeError;
}}),
"[project]/node_modules/fast-glob/out/utils/fs.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createDirentFromStats = void 0;
class DirentFromStats {
    constructor(name, stats){
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;
}}),
"[project]/node_modules/fast-glob/out/utils/path.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.convertPosixPathToPattern = exports.convertWindowsPathToPattern = exports.convertPathToPattern = exports.escapePosixPath = exports.escapeWindowsPath = exports.escape = exports.removeLeadingDotSegment = exports.makeAbsolute = exports.unixify = void 0;
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const IS_WINDOWS_PLATFORM = os.platform() === 'win32';
const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\
/**
 * All non-escaped special characters.
 * Posix: ()*?[]{|}, !+@ before (, ! at the beginning, \\ before non-special characters.
 * Windows: (){}[], !+@ before (, ! at the beginning.
 */ const POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
const WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g;
/**
 * The device path (\\.\ or \\?\).
 * https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#dos-device-paths
 */ const DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
/**
 * All backslashes except those escaping special characters.
 * Windows: !()+@{}
 * https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions
 */ const WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
/**
 * Designed to work only with simple paths: `dir\\file`.
 */ function unixify(filepath) {
    return filepath.replace(/\\/g, '/');
}
exports.unixify = unixify;
function makeAbsolute(cwd, filepath) {
    return path.resolve(cwd, filepath);
}
exports.makeAbsolute = makeAbsolute;
function removeLeadingDotSegment(entry) {
    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
    if (entry.charAt(0) === '.') {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === '/' || secondCharactery === '\\') {
            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
    }
    return entry;
}
exports.removeLeadingDotSegment = removeLeadingDotSegment;
exports.escape = ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : escapePosixPath;
function escapeWindowsPath(pattern) {
    return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
}
exports.escapeWindowsPath = escapeWindowsPath;
function escapePosixPath(pattern) {
    return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
}
exports.escapePosixPath = escapePosixPath;
exports.convertPathToPattern = ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : convertPosixPathToPattern;
function convertWindowsPathToPattern(filepath) {
    return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, '//$1').replace(WINDOWS_BACKSLASHES_RE, '/');
}
exports.convertWindowsPathToPattern = convertWindowsPathToPattern;
function convertPosixPathToPattern(filepath) {
    return escapePosixPath(filepath);
}
exports.convertPosixPathToPattern = convertPosixPathToPattern;
}}),
"[project]/node_modules/fast-glob/out/utils/pattern.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAbsolute = exports.partitionAbsoluteAndRelative = exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const globParent = __turbopack_context__.r("[project]/node_modules/fast-glob/node_modules/glob-parent/index.js [app-route] (ecmascript)");
const micromatch = __turbopack_context__.r("[project]/node_modules/micromatch/index.js [app-route] (ecmascript)");
const GLOBSTAR = '**';
const ESCAPE_SYMBOL = '\\';
const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
const BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
/**
 * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.
 * The latter is due to the presence of the device path at the beginning of the UNC path.
 */ const DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
}
exports.isStaticPattern = isStaticPattern;
function isDynamicPattern(pattern, options = {}) {
    /**
     * A special case with an empty string is necessary for matching patterns that start with a forward slash.
     * An empty string cannot be a dynamic pattern.
     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.
     */ if (pattern === '') {
        return false;
    }
    /**
     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
     * filepath directly (without read directory).
     */ if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
    }
    return false;
}
exports.isDynamicPattern = isDynamicPattern;
function hasBraceExpansion(pattern) {
    const openingBraceIndex = pattern.indexOf('{');
    if (openingBraceIndex === -1) {
        return false;
    }
    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);
    if (closingBraceIndex === -1) {
        return false;
    }
    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
}
function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
}
exports.convertToPositivePattern = convertToPositivePattern;
function convertToNegativePattern(pattern) {
    return '!' + pattern;
}
exports.convertToNegativePattern = convertToNegativePattern;
function isNegativePattern(pattern) {
    return pattern.startsWith('!') && pattern[1] !== '(';
}
exports.isNegativePattern = isNegativePattern;
function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
}
exports.isPositivePattern = isPositivePattern;
function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
}
exports.getNegativePatterns = getNegativePatterns;
function getPositivePatterns(patterns) {
    return patterns.filter(isPositivePattern);
}
exports.getPositivePatterns = getPositivePatterns;
/**
 * Returns patterns that can be applied inside the current directory.
 *
 * @example
 * // ['./*', '*', 'a/*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */ function getPatternsInsideCurrentDirectory(patterns) {
    return patterns.filter((pattern)=>!isPatternRelatedToParentDirectory(pattern));
}
exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
/**
 * Returns patterns to be expanded relative to (outside) the current directory.
 *
 * @example
 * // ['../*', './../*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */ function getPatternsOutsideCurrentDirectory(patterns) {
    return patterns.filter(isPatternRelatedToParentDirectory);
}
exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
function isPatternRelatedToParentDirectory(pattern) {
    return pattern.startsWith('..') || pattern.startsWith('./..');
}
exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
function getBaseDirectory(pattern) {
    return globParent(pattern, {
        flipBackslashes: false
    });
}
exports.getBaseDirectory = getBaseDirectory;
function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
}
exports.hasGlobStar = hasGlobStar;
function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith('/' + GLOBSTAR);
}
exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
function isAffectDepthOfReadingPattern(pattern) {
    const basename = path.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
}
exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern)=>{
        return collection.concat(expandBraceExpansion(pattern));
    }, []);
}
exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
function expandBraceExpansion(pattern) {
    const patterns = micromatch.braces(pattern, {
        expand: true,
        nodupes: true,
        keepEscaping: true
    });
    /**
     * Sort the patterns by length so that the same depth patterns are processed side by side.
     * `a/{b,}/{c,}/*` – `['a///*', 'a/b//*', 'a//c/*', 'a/b/c/*']`
     */ patterns.sort((a, b)=>a.length - b.length);
    /**
     * Micromatch can return an empty string in the case of patterns like `{a,}`.
     */ return patterns.filter((pattern)=>pattern !== '');
}
exports.expandBraceExpansion = expandBraceExpansion;
function getPatternParts(pattern, options) {
    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {
        parts: true
    }));
    /**
     * The scan method returns an empty array in some cases.
     * See micromatch/picomatch#58 for more details.
     */ if (parts.length === 0) {
        parts = [
            pattern
        ];
    }
    /**
     * The scan method does not return an empty part for the pattern with a forward slash.
     * This is another part of micromatch/picomatch#58.
     */ if (parts[0].startsWith('/')) {
        parts[0] = parts[0].slice(1);
        parts.unshift('');
    }
    return parts;
}
exports.getPatternParts = getPatternParts;
function makeRe(pattern, options) {
    return micromatch.makeRe(pattern, options);
}
exports.makeRe = makeRe;
function convertPatternsToRe(patterns, options) {
    return patterns.map((pattern)=>makeRe(pattern, options));
}
exports.convertPatternsToRe = convertPatternsToRe;
function matchAny(entry, patternsRe) {
    return patternsRe.some((patternRe)=>patternRe.test(entry));
}
exports.matchAny = matchAny;
/**
 * This package only works with forward slashes as a path separator.
 * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.
 */ function removeDuplicateSlashes(pattern) {
    return pattern.replace(DOUBLE_SLASH_RE, '/');
}
exports.removeDuplicateSlashes = removeDuplicateSlashes;
function partitionAbsoluteAndRelative(patterns) {
    const absolute = [];
    const relative = [];
    for (const pattern of patterns){
        if (isAbsolute(pattern)) {
            absolute.push(pattern);
        } else {
            relative.push(pattern);
        }
    }
    return [
        absolute,
        relative
    ];
}
exports.partitionAbsoluteAndRelative = partitionAbsoluteAndRelative;
function isAbsolute(pattern) {
    return path.isAbsolute(pattern);
}
exports.isAbsolute = isAbsolute;
}}),
"[project]/node_modules/fast-glob/out/utils/stream.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.merge = void 0;
const merge2 = __turbopack_context__.r("[project]/node_modules/merge2/index.js [app-route] (ecmascript)");
function merge(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream)=>{
        stream.once('error', (error)=>mergedStream.emit('error', error));
    });
    mergedStream.once('close', ()=>propagateCloseEventToSources(streams));
    mergedStream.once('end', ()=>propagateCloseEventToSources(streams));
    return mergedStream;
}
exports.merge = merge;
function propagateCloseEventToSources(streams) {
    streams.forEach((stream)=>stream.emit('close'));
}
}}),
"[project]/node_modules/fast-glob/out/utils/string.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isEmpty = exports.isString = void 0;
function isString(input) {
    return typeof input === 'string';
}
exports.isString = isString;
function isEmpty(input) {
    return input === '';
}
exports.isEmpty = isEmpty;
}}),
"[project]/node_modules/fast-glob/out/utils/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
const array = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/array.js [app-route] (ecmascript)");
exports.array = array;
const errno = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/errno.js [app-route] (ecmascript)");
exports.errno = errno;
const fs = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/fs.js [app-route] (ecmascript)");
exports.fs = fs;
const path = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/path.js [app-route] (ecmascript)");
exports.path = path;
const pattern = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/pattern.js [app-route] (ecmascript)");
exports.pattern = pattern;
const stream = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/stream.js [app-route] (ecmascript)");
exports.stream = stream;
const string = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/string.js [app-route] (ecmascript)");
exports.string = string;
}}),
"[project]/node_modules/fast-glob/out/managers/tasks.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
const utils = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/index.js [app-route] (ecmascript)");
function generate(input, settings) {
    const patterns = processPatterns(input, settings);
    const ignore = processPatterns(settings.ignore, settings);
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);
    const staticPatterns = positivePatterns.filter((pattern)=>utils.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter((pattern)=>utils.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);
    return staticTasks.concat(dynamicTasks);
}
exports.generate = generate;
function processPatterns(input, settings) {
    let patterns = input;
    /**
     * The original pattern like `{,*,**,a/*}` can lead to problems checking the depth when matching entry
     * and some problems with the micromatch package (see fast-glob issues: #365, #394).
     *
     * To solve this problem, we expand all patterns containing brace expansion. This can lead to a slight slowdown
     * in matching in the case of a large set of patterns after expansion.
     */ if (settings.braceExpansion) {
        patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);
    }
    /**
     * If the `baseNameMatch` option is enabled, we must add globstar to patterns, so that they can be used
     * at any nesting level.
     *
     * We do this here, because otherwise we have to complicate the filtering logic. For example, we need to change
     * the pattern in the filter before creating a regular expression. There is no need to change the patterns
     * in the application. Only on the input.
     */ if (settings.baseNameMatch) {
        patterns = patterns.map((pattern)=>pattern.includes('/') ? pattern : `**/${pattern}`);
    }
    /**
     * This method also removes duplicate slashes that may have been in the pattern or formed as a result of expansion.
     */ return patterns.map((pattern)=>utils.pattern.removeDuplicateSlashes(pattern));
}
/**
 * Returns tasks grouped by basic pattern directories.
 *
 * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.
 * This is necessary because directory traversal starts at the base directory and goes deeper.
 */ function convertPatternsToTasks(positive, negative, dynamic) {
    const tasks = [];
    const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
    const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
    /*
     * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory
     * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.
     */ if ('.' in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));
    } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
    }
    return tasks;
}
exports.convertPatternsToTasks = convertPatternsToTasks;
function getPositivePatterns(patterns) {
    return utils.pattern.getPositivePatterns(patterns);
}
exports.getPositivePatterns = getPositivePatterns;
function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils.pattern.convertToPositivePattern);
    return positive;
}
exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern)=>{
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
            collection[base].push(pattern);
        } else {
            collection[base] = [
                pattern
            ];
        }
        return collection;
    }, group);
}
exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map((base)=>{
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
}
exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
    };
}
exports.convertPatternGroupToTask = convertPatternGroupToTask;
}}),
"[project]/node_modules/fast-glob/out/readers/reader.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const fsStat = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.stat/out/index.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/index.js [app-route] (ecmascript)");
class Reader {
    constructor(_settings){
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
    }
    _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern) {
        const entry = {
            name: pattern,
            path: pattern,
            dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
            entry.stats = stats;
        }
        return entry;
    }
    _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }
}
exports.default = Reader;
}}),
"[project]/node_modules/fast-glob/out/readers/stream.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const fsStat = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.stat/out/index.js [app-route] (ecmascript)");
const fsWalk = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/index.js [app-route] (ecmascript)");
const reader_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/readers/reader.js [app-route] (ecmascript)");
class ReaderStream extends reader_1.default {
    constructor(){
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
    }
    dynamic(root, options) {
        return this._walkStream(root, options);
    }
    static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({
            objectMode: true
        });
        stream._write = (index, _enc, done)=>{
            return this._getEntry(filepaths[index], patterns[index], options).then((entry)=>{
                if (entry !== null && options.entryFilter(entry)) {
                    stream.push(entry);
                }
                if (index === filepaths.length - 1) {
                    stream.end();
                }
                done();
            }).catch(done);
        };
        for(let i = 0; i < filepaths.length; i++){
            stream.write(i);
        }
        return stream;
    }
    _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats)=>this._makeEntry(stats, pattern)).catch((error)=>{
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        });
    }
    _getStat(filepath) {
        return new Promise((resolve, reject)=>{
            this._stat(filepath, this._fsStatSettings, (error, stats)=>{
                return error === null ? resolve(stats) : reject(error);
            });
        });
    }
}
exports.default = ReaderStream;
}}),
"[project]/node_modules/fast-glob/out/readers/async.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const fsWalk = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/index.js [app-route] (ecmascript)");
const reader_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/readers/reader.js [app-route] (ecmascript)");
const stream_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/readers/stream.js [app-route] (ecmascript)");
class ReaderAsync extends reader_1.default {
    constructor(){
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
    }
    dynamic(root, options) {
        return new Promise((resolve, reject)=>{
            this._walkAsync(root, options, (error, entries)=>{
                if (error === null) {
                    resolve(entries);
                } else {
                    reject(error);
                }
            });
        });
    }
    async static(patterns, options) {
        const entries = [];
        const stream = this._readerStream.static(patterns, options);
        // After #235, replace it with an asynchronous iterator.
        return new Promise((resolve, reject)=>{
            stream.once('error', reject);
            stream.on('data', (entry)=>entries.push(entry));
            stream.once('end', ()=>resolve(entries));
        });
    }
}
exports.default = ReaderAsync;
}}),
"[project]/node_modules/fast-glob/out/providers/matchers/matcher.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const utils = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/index.js [app-route] (ecmascript)");
class Matcher {
    constructor(_patterns, _settings, _micromatchOptions){
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
    }
    _fillStorage() {
        for (const pattern of this._patterns){
            const segments = this._getPatternSegments(pattern);
            const sections = this._splitSegmentsIntoSections(segments);
            this._storage.push({
                complete: sections.length <= 1,
                pattern,
                segments,
                sections
            });
        }
    }
    _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part)=>{
            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
            if (!dynamic) {
                return {
                    dynamic: false,
                    pattern: part
                };
            }
            return {
                dynamic: true,
                pattern: part,
                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
            };
        });
    }
    _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment)=>segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
    }
}
exports.default = Matcher;
}}),
"[project]/node_modules/fast-glob/out/providers/matchers/partial.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const matcher_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/providers/matchers/matcher.js [app-route] (ecmascript)");
class PartialMatcher extends matcher_1.default {
    match(filepath) {
        const parts = filepath.split('/');
        const levels = parts.length;
        const patterns = this._storage.filter((info)=>!info.complete || info.segments.length > levels);
        for (const pattern of patterns){
            const section = pattern.sections[0];
            /**
             * In this case, the pattern has a globstar and we must read all directories unconditionally,
             * but only if the level has reached the end of the first group.
             *
             * fixtures/{a,b}/**
             *  ^ true/false  ^ always true
            */ if (!pattern.complete && levels > section.length) {
                return true;
            }
            const match = parts.every((part, index)=>{
                const segment = pattern.segments[index];
                if (segment.dynamic && segment.patternRe.test(part)) {
                    return true;
                }
                if (!segment.dynamic && segment.pattern === part) {
                    return true;
                }
                return false;
            });
            if (match) {
                return true;
            }
        }
        return false;
    }
}
exports.default = PartialMatcher;
}}),
"[project]/node_modules/fast-glob/out/providers/filters/deep.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const utils = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/index.js [app-route] (ecmascript)");
const partial_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/providers/matchers/partial.js [app-route] (ecmascript)");
class DeepFilter {
    constructor(_settings, _micromatchOptions){
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry)=>this._filter(basePath, entry, matcher, negativeRe);
    }
    _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
            return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
            return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
            return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(basePath, entryPath) {
        /**
         * Avoid unnecessary depth calculations when it doesn't matter.
         */ if (this._settings.deep === Infinity) {
            return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
    }
    _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split('/').length;
        if (basePath === '') {
            return entryPathDepth;
        }
        const basePathDepth = basePath.split('/').length;
        return entryPathDepth - basePathDepth;
    }
    _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
    }
}
exports.default = DeepFilter;
}}),
"[project]/node_modules/fast-glob/out/providers/filters/entry.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const utils = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/index.js [app-route] (ecmascript)");
class EntryFilter {
    constructor(_settings, _micromatchOptions){
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
    }
    getFilter(positive, negative) {
        const [absoluteNegative, relativeNegative] = utils.pattern.partitionAbsoluteAndRelative(negative);
        const patterns = {
            positive: {
                all: utils.pattern.convertPatternsToRe(positive, this._micromatchOptions)
            },
            negative: {
                absolute: utils.pattern.convertPatternsToRe(absoluteNegative, Object.assign(Object.assign({}, this._micromatchOptions), {
                    dot: true
                })),
                relative: utils.pattern.convertPatternsToRe(relativeNegative, Object.assign(Object.assign({}, this._micromatchOptions), {
                    dot: true
                }))
            }
        };
        return (entry)=>this._filter(entry, patterns);
    }
    _filter(entry, patterns) {
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath)) {
            return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
            return false;
        }
        const isMatched = this._isMatchToPatternsSet(filepath, patterns, entry.dirent.isDirectory());
        if (this._settings.unique && isMatched) {
            this._createIndexRecord(filepath);
        }
        return isMatched;
    }
    _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
    }
    _createIndexRecord(filepath) {
        this.index.set(filepath, undefined);
    }
    _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isMatchToPatternsSet(filepath, patterns, isDirectory) {
        const isMatched = this._isMatchToPatterns(filepath, patterns.positive.all, isDirectory);
        if (!isMatched) {
            return false;
        }
        const isMatchedByRelativeNegative = this._isMatchToPatterns(filepath, patterns.negative.relative, isDirectory);
        if (isMatchedByRelativeNegative) {
            return false;
        }
        const isMatchedByAbsoluteNegative = this._isMatchToAbsoluteNegative(filepath, patterns.negative.absolute, isDirectory);
        if (isMatchedByAbsoluteNegative) {
            return false;
        }
        return true;
    }
    _isMatchToAbsoluteNegative(filepath, patternsRe, isDirectory) {
        if (patternsRe.length === 0) {
            return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, filepath);
        return this._isMatchToPatterns(fullpath, patternsRe, isDirectory);
    }
    _isMatchToPatterns(filepath, patternsRe, isDirectory) {
        if (patternsRe.length === 0) {
            return false;
        }
        // Trying to match files and directories by patterns.
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        // A pattern with a trailling slash can be used for directory matching.
        // To apply such pattern, we need to add a tralling slash to the path.
        if (!isMatched && isDirectory) {
            return utils.pattern.matchAny(filepath + '/', patternsRe);
        }
        return isMatched;
    }
}
exports.default = EntryFilter;
}}),
"[project]/node_modules/fast-glob/out/providers/filters/error.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const utils = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/index.js [app-route] (ecmascript)");
class ErrorFilter {
    constructor(_settings){
        this._settings = _settings;
    }
    getFilter() {
        return (error)=>this._isNonFatalError(error);
    }
    _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }
}
exports.default = ErrorFilter;
}}),
"[project]/node_modules/fast-glob/out/providers/transformers/entry.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const utils = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/index.js [app-route] (ecmascript)");
class EntryTransformer {
    constructor(_settings){
        this._settings = _settings;
    }
    getTransformer() {
        return (entry)=>this._transform(entry);
    }
    _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
            filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
            filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
            filepath += '/';
        }
        if (!this._settings.objectMode) {
            return filepath;
        }
        return Object.assign(Object.assign({}, entry), {
            path: filepath
        });
    }
}
exports.default = EntryTransformer;
}}),
"[project]/node_modules/fast-glob/out/providers/provider.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const deep_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/providers/filters/deep.js [app-route] (ecmascript)");
const entry_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/providers/filters/entry.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/providers/filters/error.js [app-route] (ecmascript)");
const entry_2 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/providers/transformers/entry.js [app-route] (ecmascript)");
class Provider {
    constructor(_settings){
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
        const basePath = task.base === '.' ? '' : task.base;
        return {
            basePath,
            pathSegmentSeparator: '/',
            concurrency: this._settings.concurrency,
            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
            errorFilter: this.errorFilter.getFilter(),
            followSymbolicLinks: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            stats: this._settings.stats,
            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
            transform: this.entryTransformer.getTransformer()
        };
    }
    _getMicromatchOptions() {
        return {
            dot: this._settings.dot,
            matchBase: this._settings.baseNameMatch,
            nobrace: !this._settings.braceExpansion,
            nocase: !this._settings.caseSensitiveMatch,
            noext: !this._settings.extglob,
            noglobstar: !this._settings.globstar,
            posix: true,
            strictSlashes: false
        };
    }
}
exports.default = Provider;
}}),
"[project]/node_modules/fast-glob/out/providers/async.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const async_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/readers/async.js [app-route] (ecmascript)");
const provider_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/providers/provider.js [app-route] (ecmascript)");
class ProviderAsync extends provider_1.default {
    constructor(){
        super(...arguments);
        this._reader = new async_1.default(this._settings);
    }
    async read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = await this.api(root, task, options);
        return entries.map((entry)=>options.transform(entry));
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderAsync;
}}),
"[project]/node_modules/fast-glob/out/providers/stream.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const stream_2 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/readers/stream.js [app-route] (ecmascript)");
const provider_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/providers/provider.js [app-route] (ecmascript)");
class ProviderStream extends provider_1.default {
    constructor(){
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({
            objectMode: true,
            read: ()=>{}
        });
        source.once('error', (error)=>destination.emit('error', error)).on('data', (entry)=>destination.emit('data', options.transform(entry))).once('end', ()=>destination.emit('end'));
        destination.once('close', ()=>source.destroy());
        return destination;
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderStream;
}}),
"[project]/node_modules/fast-glob/out/readers/sync.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const fsStat = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.stat/out/index.js [app-route] (ecmascript)");
const fsWalk = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/index.js [app-route] (ecmascript)");
const reader_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/readers/reader.js [app-route] (ecmascript)");
class ReaderSync extends reader_1.default {
    constructor(){
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
        return this._walkSync(root, options);
    }
    static(patterns, options) {
        const entries = [];
        for (const pattern of patterns){
            const filepath = this._getFullEntryPath(pattern);
            const entry = this._getEntry(filepath, pattern, options);
            if (entry === null || !options.entryFilter(entry)) {
                continue;
            }
            entries.push(entry);
        }
        return entries;
    }
    _getEntry(filepath, pattern, options) {
        try {
            const stats = this._getStat(filepath);
            return this._makeEntry(stats, pattern);
        } catch (error) {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        }
    }
    _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
    }
}
exports.default = ReaderSync;
}}),
"[project]/node_modules/fast-glob/out/providers/sync.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const sync_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/readers/sync.js [app-route] (ecmascript)");
const provider_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/providers/provider.js [app-route] (ecmascript)");
class ProviderSync extends provider_1.default {
    constructor(){
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderSync;
}}),
"[project]/node_modules/fast-glob/out/settings.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
/**
 * The `os.cpus` method can return zero. We expect the number of cores to be greater than zero.
 * https://github.com/nodejs/node/blob/7faeddf23a98c53896f8b574a6e66589e8fb1eb8/lib/os.js#L106-L107
 */ const CPU_COUNT = Math.max(os.cpus().length, 1);
exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    lstatSync: fs.lstatSync,
    stat: fs.stat,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
class Settings {
    constructor(_options = {}){
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
            this.onlyFiles = false;
        }
        if (this.stats) {
            this.objectMode = true;
        }
        // Remove the cast to the array in the next major (#404).
        this.ignore = [].concat(this.ignore);
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
    _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
}
exports.default = Settings;
}}),
"[project]/node_modules/fast-glob/out/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const taskManager = __turbopack_context__.r("[project]/node_modules/fast-glob/out/managers/tasks.js [app-route] (ecmascript)");
const async_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/providers/async.js [app-route] (ecmascript)");
const stream_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/providers/stream.js [app-route] (ecmascript)");
const sync_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/providers/sync.js [app-route] (ecmascript)");
const settings_1 = __turbopack_context__.r("[project]/node_modules/fast-glob/out/settings.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/fast-glob/out/utils/index.js [app-route] (ecmascript)");
async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils.array.flatten(result);
}
// https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare
(function(FastGlob) {
    FastGlob.glob = FastGlob;
    FastGlob.globSync = sync;
    FastGlob.globStream = stream;
    FastGlob.async = FastGlob;
    function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
    }
    FastGlob.sync = sync;
    function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        /**
         * The stream returned by the provider cannot work with an asynchronous iterator.
         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
         * This affects performance (+25%). I don't see best solution right now.
         */ return utils.stream.merge(works);
    }
    FastGlob.stream = stream;
    function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
    }
    FastGlob.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
    }
    FastGlob.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
    }
    FastGlob.escapePath = escapePath;
    function convertPathToPattern(source) {
        assertPatternsInput(source);
        return utils.path.convertPathToPattern(source);
    }
    FastGlob.convertPathToPattern = convertPathToPattern;
    let posix;
    (function(posix) {
        function escapePath(source) {
            assertPatternsInput(source);
            return utils.path.escapePosixPath(source);
        }
        posix.escapePath = escapePath;
        function convertPathToPattern(source) {
            assertPatternsInput(source);
            return utils.path.convertPosixPathToPattern(source);
        }
        posix.convertPathToPattern = convertPathToPattern;
    })(posix = FastGlob.posix || (FastGlob.posix = {}));
    let win32;
    (function(win32) {
        function escapePath(source) {
            assertPatternsInput(source);
            return utils.path.escapeWindowsPath(source);
        }
        win32.escapePath = escapePath;
        function convertPathToPattern(source) {
            assertPatternsInput(source);
            return utils.path.convertWindowsPathToPattern(source);
        }
        win32.convertPathToPattern = convertPathToPattern;
    })(win32 = FastGlob.win32 || (FastGlob.win32 = {}));
})(FastGlob || (FastGlob = {}));
function getWorks(source, _Provider, options) {
    const patterns = [].concat(source);
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
}
function assertPatternsInput(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item)=>utils.string.isString(item) && !utils.string.isEmpty(item));
    if (!isValidSource) {
        throw new TypeError('Patterns must be a string (non empty) or an array of strings');
    }
}
module.exports = FastGlob;
}}),
"[project]/node_modules/is-extglob/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */ module.exports = function isExtglob(str) {
    if (typeof str !== 'string' || str === '') {
        return false;
    }
    var match;
    while(match = /(\\).|([@?!+*]\(.*\))/g.exec(str)){
        if (match[2]) return true;
        str = str.slice(match.index + match[0].length);
    }
    return false;
};
}}),
"[project]/node_modules/is-glob/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ var isExtglob = __turbopack_context__.r("[project]/node_modules/is-extglob/index.js [app-route] (ecmascript)");
var chars = {
    '{': '}',
    '(': ')',
    '[': ']'
};
var strictCheck = function(str) {
    if (str[0] === '!') {
        return true;
    }
    var index = 0;
    var pipeIndex = -2;
    var closeSquareIndex = -2;
    var closeCurlyIndex = -2;
    var closeParenIndex = -2;
    var backSlashIndex = -2;
    while(index < str.length){
        if (str[index] === '*') {
            return true;
        }
        if (str[index + 1] === '?' && /[\].+)]/.test(str[index])) {
            return true;
        }
        if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {
            if (closeSquareIndex < index) {
                closeSquareIndex = str.indexOf(']', index);
            }
            if (closeSquareIndex > index) {
                if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                    return true;
                }
                backSlashIndex = str.indexOf('\\', index);
                if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                    return true;
                }
            }
        }
        if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {
            closeCurlyIndex = str.indexOf('}', index);
            if (closeCurlyIndex > index) {
                backSlashIndex = str.indexOf('\\', index);
                if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
                    return true;
                }
            }
        }
        if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {
            closeParenIndex = str.indexOf(')', index);
            if (closeParenIndex > index) {
                backSlashIndex = str.indexOf('\\', index);
                if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                    return true;
                }
            }
        }
        if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {
            if (pipeIndex < index) {
                pipeIndex = str.indexOf('|', index);
            }
            if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {
                closeParenIndex = str.indexOf(')', pipeIndex);
                if (closeParenIndex > pipeIndex) {
                    backSlashIndex = str.indexOf('\\', pipeIndex);
                    if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                        return true;
                    }
                }
            }
        }
        if (str[index] === '\\') {
            var open = str[index + 1];
            index += 2;
            var close = chars[open];
            if (close) {
                var n = str.indexOf(close, index);
                if (n !== -1) {
                    index = n + 1;
                }
            }
            if (str[index] === '!') {
                return true;
            }
        } else {
            index++;
        }
    }
    return false;
};
var relaxedCheck = function(str) {
    if (str[0] === '!') {
        return true;
    }
    var index = 0;
    while(index < str.length){
        if (/[*?{}()[\]]/.test(str[index])) {
            return true;
        }
        if (str[index] === '\\') {
            var open = str[index + 1];
            index += 2;
            var close = chars[open];
            if (close) {
                var n = str.indexOf(close, index);
                if (n !== -1) {
                    index = n + 1;
                }
            }
            if (str[index] === '!') {
                return true;
            }
        } else {
            index++;
        }
    }
    return false;
};
module.exports = function isGlob(str, options) {
    if (typeof str !== 'string' || str === '') {
        return false;
    }
    if (isExtglob(str)) {
        return true;
    }
    var check = strictCheck;
    // optionally relax check
    if (options && options.strict === false) {
        check = relaxedCheck;
    }
    return check(str);
};
}}),
"[project]/node_modules/fast-glob/node_modules/glob-parent/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var isGlob = __turbopack_context__.r("[project]/node_modules/is-glob/index.js [app-route] (ecmascript)");
var pathPosixDirname = __turbopack_context__.r("[externals]/path [external] (path, cjs)").posix.dirname;
var isWin32 = __turbopack_context__.r("[externals]/os [external] (os, cjs)").platform() === 'win32';
var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 * @returns {string}
 */ module.exports = function globParent(str, opts) {
    var options = Object.assign({
        flipBackslashes: true
    }, opts);
    // flip windows path separators
    if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        "TURBOPACK unreachable";
    }
    // special case for strings ending in enclosure containing path separator
    if (enclosure.test(str)) {
        str += slash;
    }
    // preserves full path in case of trailing path separator
    str += 'a';
    // remove path parts that are globby
    do {
        str = pathPosixDirname(str);
    }while (isGlob(str) || globby.test(str))
    // remove escape chars and return result
    return str.replace(escaped, '$1');
};
}}),
"[project]/node_modules/merge2/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/*
 * merge2
 * https://github.com/teambition/merge2
 *
 * Copyright (c) 2014-2020 Teambition
 * Licensed under the MIT license.
 */ const Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const PassThrough = Stream.PassThrough;
const slice = Array.prototype.slice;
module.exports = merge2;
function merge2() {
    const streamsQueue = [];
    const args = slice.call(arguments);
    let merging = false;
    let options = args[args.length - 1];
    if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
    } else {
        options = {};
    }
    const doEnd = options.end !== false;
    const doPipeError = options.pipeError === true;
    if (options.objectMode == null) {
        options.objectMode = true;
    }
    if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
    }
    const mergedStream = PassThrough(options);
    function addStream() {
        for(let i = 0, len = arguments.length; i < len; i++){
            streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
    }
    function mergeStream() {
        if (merging) {
            return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
            process.nextTick(endStream);
            return;
        }
        if (!Array.isArray(streams)) {
            streams = [
                streams
            ];
        }
        let pipesCount = streams.length + 1;
        function next() {
            if (--pipesCount > 0) {
                return;
            }
            merging = false;
            mergeStream();
        }
        function pipe(stream) {
            function onend() {
                stream.removeListener('merge2UnpipeEnd', onend);
                stream.removeListener('end', onend);
                if (doPipeError) {
                    stream.removeListener('error', onerror);
                }
                next();
            }
            function onerror(err) {
                mergedStream.emit('error', err);
            }
            // skip ended stream
            if (stream._readableState.endEmitted) {
                return next();
            }
            stream.on('merge2UnpipeEnd', onend);
            stream.on('end', onend);
            if (doPipeError) {
                stream.on('error', onerror);
            }
            stream.pipe(mergedStream, {
                end: false
            });
            // compatible for old stream
            stream.resume();
        }
        for(let i = 0; i < streams.length; i++){
            pipe(streams[i]);
        }
        next();
    }
    function endStream() {
        merging = false;
        // emit 'queueDrain' when all streams merged.
        mergedStream.emit('queueDrain');
        if (doEnd) {
            mergedStream.end();
        }
    }
    mergedStream.setMaxListeners(0);
    mergedStream.add = addStream;
    mergedStream.on('unpipe', function(stream) {
        stream.emit('merge2UnpipeEnd');
    });
    if (args.length) {
        addStream.apply(null, args);
    }
    return mergedStream;
}
// check and pause streams for pipe.
function pauseStreams(streams, options) {
    if (!Array.isArray(streams)) {
        // Backwards-compat with old-style streams
        if (!streams._readableState && streams.pipe) {
            streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
            throw new Error('Only readable stream can be merged.');
        }
        streams.pause();
    } else {
        for(let i = 0, len = streams.length; i < len; i++){
            streams[i] = pauseStreams(streams[i], options);
        }
    }
    return streams;
}
}}),
"[project]/node_modules/@nodelib/fs.stat/out/providers/async.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.read = void 0;
function read(path, settings, callback) {
    settings.fs.lstat(path, (lstatError, lstat)=>{
        if (lstatError !== null) {
            callFailureCallback(callback, lstatError);
            return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
            callSuccessCallback(callback, lstat);
            return;
        }
        settings.fs.stat(path, (statError, stat)=>{
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    callFailureCallback(callback, statError);
                    return;
                }
                callSuccessCallback(callback, lstat);
                return;
            }
            if (settings.markSymbolicLink) {
                stat.isSymbolicLink = ()=>true;
            }
            callSuccessCallback(callback, stat);
        });
    });
}
exports.read = read;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}
}}),
"[project]/node_modules/@nodelib/fs.stat/out/providers/sync.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.read = void 0;
function read(path, settings) {
    const lstat = settings.fs.lstatSync(path);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
    }
    try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
            stat.isSymbolicLink = ()=>true;
        }
        return stat;
    } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
            return lstat;
        }
        throw error;
    }
}
exports.read = read;
}}),
"[project]/node_modules/@nodelib/fs.stat/out/adapters/fs.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;
}}),
"[project]/node_modules/@nodelib/fs.stat/out/settings.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const fs = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.stat/out/adapters/fs.js [app-route] (ecmascript)");
class Settings {
    constructor(_options = {}){
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
exports.default = Settings;
}}),
"[project]/node_modules/@nodelib/fs.stat/out/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.statSync = exports.stat = exports.Settings = void 0;
const async = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.stat/out/providers/async.js [app-route] (ecmascript)");
const sync = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.stat/out/providers/sync.js [app-route] (ecmascript)");
const settings_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.stat/out/settings.js [app-route] (ecmascript)");
exports.Settings = settings_1.default;
function stat(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.stat = stat;
function statSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.statSync = statSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}
}}),
"[project]/node_modules/queue-microtask/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ let promise;
module.exports = typeof queueMicrotask === 'function' ? queueMicrotask.bind(("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : global) : (cb)=>(promise || (promise = Promise.resolve())).then(cb).catch((err)=>setTimeout(()=>{
            throw err;
        }, 0));
}}),
"[project]/node_modules/run-parallel/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ module.exports = runParallel;
const queueMicrotask = __turbopack_context__.r("[project]/node_modules/queue-microtask/index.js [app-route] (ecmascript)");
function runParallel(tasks, cb) {
    let results, pending, keys;
    let isSync = true;
    if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
    } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
    }
    function done(err) {
        function end() {
            if (cb) cb(err, results);
            cb = null;
        }
        if (isSync) queueMicrotask(end);
        else end();
    }
    function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
            done(err);
        }
    }
    if (!pending) {
        // empty
        done(null);
    } else if (keys) {
        // object
        keys.forEach(function(key) {
            tasks[key](function(err, result) {
                each(key, err, result);
            });
        });
    } else {
        // array
        tasks.forEach(function(task, i) {
            task(function(err, result) {
                each(i, err, result);
            });
        });
    }
    isSync = false;
}
}}),
"[project]/node_modules/@nodelib/fs.scandir/out/constants.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
const NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');
if (NODE_PROCESS_VERSION_PARTS[0] === undefined || NODE_PROCESS_VERSION_PARTS[1] === undefined) {
    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
}
const MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
const MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
const SUPPORTED_MAJOR_VERSION = 10;
const SUPPORTED_MINOR_VERSION = 10;
const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
const IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
/**
 * IS `true` for Node.js 10.10 and greater.
 */ exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
}}),
"[project]/node_modules/@nodelib/fs.scandir/out/utils/fs.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createDirentFromStats = void 0;
class DirentFromStats {
    constructor(name, stats){
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;
}}),
"[project]/node_modules/@nodelib/fs.scandir/out/utils/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fs = void 0;
const fs = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/utils/fs.js [app-route] (ecmascript)");
exports.fs = fs;
}}),
"[project]/node_modules/@nodelib/fs.scandir/out/providers/common.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.joinPathSegments = void 0;
function joinPathSegments(a, b, separator) {
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */ if (a.endsWith(separator)) {
        return a + b;
    }
    return a + separator + b;
}
exports.joinPathSegments = joinPathSegments;
}}),
"[project]/node_modules/@nodelib/fs.scandir/out/providers/async.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
const fsStat = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.stat/out/index.js [app-route] (ecmascript)");
const rpl = __turbopack_context__.r("[project]/node_modules/run-parallel/index.js [app-route] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/constants.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/utils/index.js [app-route] (ecmascript)");
const common = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/providers/common.js [app-route] (ecmascript)");
function read(directory, settings, callback) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
    }
    readdir(directory, settings, callback);
}
exports.read = read;
function readdirWithFileTypes(directory, settings, callback) {
    settings.fs.readdir(directory, {
        withFileTypes: true
    }, (readdirError, dirents)=>{
        if (readdirError !== null) {
            callFailureCallback(callback, readdirError);
            return;
        }
        const entries = dirents.map((dirent)=>({
                dirent,
                name: dirent.name,
                path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
            }));
        if (!settings.followSymbolicLinks) {
            callSuccessCallback(callback, entries);
            return;
        }
        const tasks = entries.map((entry)=>makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries)=>{
            if (rplError !== null) {
                callFailureCallback(callback, rplError);
                return;
            }
            callSuccessCallback(callback, rplEntries);
        });
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function makeRplTaskEntry(entry, settings) {
    return (done)=>{
        if (!entry.dirent.isSymbolicLink()) {
            done(null, entry);
            return;
        }
        settings.fs.stat(entry.path, (statError, stats)=>{
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    done(statError);
                    return;
                }
                done(null, entry);
                return;
            }
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            done(null, entry);
        });
    };
}
function readdir(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names)=>{
        if (readdirError !== null) {
            callFailureCallback(callback, readdirError);
            return;
        }
        const tasks = names.map((name)=>{
            const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
            return (done)=>{
                fsStat.stat(path, settings.fsStatSettings, (error, stats)=>{
                    if (error !== null) {
                        done(error);
                        return;
                    }
                    const entry = {
                        name,
                        path,
                        dirent: utils.fs.createDirentFromStats(name, stats)
                    };
                    if (settings.stats) {
                        entry.stats = stats;
                    }
                    done(null, entry);
                });
            };
        });
        rpl(tasks, (rplError, entries)=>{
            if (rplError !== null) {
                callFailureCallback(callback, rplError);
                return;
            }
            callSuccessCallback(callback, entries);
        });
    });
}
exports.readdir = readdir;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}
}}),
"[project]/node_modules/@nodelib/fs.scandir/out/providers/sync.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
const fsStat = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.stat/out/index.js [app-route] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/constants.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/utils/index.js [app-route] (ecmascript)");
const common = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/providers/common.js [app-route] (ecmascript)");
function read(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
    }
    return readdir(directory, settings);
}
exports.read = read;
function readdirWithFileTypes(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, {
        withFileTypes: true
    });
    return dirents.map((dirent)=>{
        const entry = {
            dirent,
            name: dirent.name,
            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
            try {
                const stats = settings.fs.statSync(entry.path);
                entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            } catch (error) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    throw error;
                }
            }
        }
        return entry;
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function readdir(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name)=>{
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
            name,
            path: entryPath,
            dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
            entry.stats = stats;
        }
        return entry;
    });
}
exports.readdir = readdir;
}}),
"[project]/node_modules/@nodelib/fs.scandir/out/adapters/fs.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;
}}),
"[project]/node_modules/@nodelib/fs.scandir/out/settings.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const fsStat = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.stat/out/index.js [app-route] (ecmascript)");
const fs = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/adapters/fs.js [app-route] (ecmascript)");
class Settings {
    constructor(_options = {}){
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this.followSymbolicLinks,
            fs: this.fs,
            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
exports.default = Settings;
}}),
"[project]/node_modules/@nodelib/fs.scandir/out/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Settings = exports.scandirSync = exports.scandir = void 0;
const async = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/providers/async.js [app-route] (ecmascript)");
const sync = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/providers/sync.js [app-route] (ecmascript)");
const settings_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/settings.js [app-route] (ecmascript)");
exports.Settings = settings_1.default;
function scandir(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.scandir = scandir;
function scandirSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.scandirSync = scandirSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}
}}),
"[project]/node_modules/reusify/reusify.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
function reusify(Constructor) {
    var head = new Constructor();
    var tail = head;
    function get() {
        var current = head;
        if (current.next) {
            head = current.next;
        } else {
            head = new Constructor();
            tail = head;
        }
        current.next = null;
        return current;
    }
    function release(obj) {
        tail.next = obj;
        tail = obj;
    }
    return {
        get: get,
        release: release
    };
}
module.exports = reusify;
}}),
"[project]/node_modules/fastq/queue.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/* eslint-disable no-var */ var reusify = __turbopack_context__.r("[project]/node_modules/reusify/reusify.js [app-route] (ecmascript)");
function fastqueue(context, worker, _concurrency) {
    if (typeof context === 'function') {
        _concurrency = worker;
        worker = context;
        context = null;
    }
    if (!(_concurrency >= 1)) {
        throw new Error('fastqueue concurrency must be equal to or greater than 1');
    }
    var cache = reusify(Task);
    var queueHead = null;
    var queueTail = null;
    var _running = 0;
    var errorHandler = null;
    var self = {
        push: push,
        drain: noop,
        saturated: noop,
        pause: pause,
        paused: false,
        get concurrency () {
            return _concurrency;
        },
        set concurrency (value){
            if (!(value >= 1)) {
                throw new Error('fastqueue concurrency must be equal to or greater than 1');
            }
            _concurrency = value;
            if (self.paused) return;
            for(; queueHead && _running < _concurrency;){
                _running++;
                release();
            }
        },
        running: running,
        resume: resume,
        idle: idle,
        length: length,
        getQueue: getQueue,
        unshift: unshift,
        empty: noop,
        kill: kill,
        killAndDrain: killAndDrain,
        error: error
    };
    return self;
    "TURBOPACK unreachable";
    function running() {
        return _running;
    }
    function pause() {
        self.paused = true;
    }
    function length() {
        var current = queueHead;
        var counter = 0;
        while(current){
            current = current.next;
            counter++;
        }
        return counter;
    }
    function getQueue() {
        var current = queueHead;
        var tasks = [];
        while(current){
            tasks.push(current.value);
            current = current.next;
        }
        return tasks;
    }
    function resume() {
        if (!self.paused) return;
        self.paused = false;
        if (queueHead === null) {
            _running++;
            release();
            return;
        }
        for(; queueHead && _running < _concurrency;){
            _running++;
            release();
        }
    }
    function idle() {
        return _running === 0 && self.length() === 0;
    }
    function push(value1, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value1;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running >= _concurrency || self.paused) {
            if (queueTail) {
                queueTail.next = current;
                queueTail = current;
            } else {
                queueHead = current;
                queueTail = current;
                self.saturated();
            }
        } else {
            _running++;
            worker.call(context, current.value, current.worked);
        }
    }
    function unshift(value1, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value1;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running >= _concurrency || self.paused) {
            if (queueHead) {
                current.next = queueHead;
                queueHead = current;
            } else {
                queueHead = current;
                queueTail = current;
                self.saturated();
            }
        } else {
            _running++;
            worker.call(context, current.value, current.worked);
        }
    }
    function release(holder) {
        if (holder) {
            cache.release(holder);
        }
        var next = queueHead;
        if (next && _running <= _concurrency) {
            if (!self.paused) {
                if (queueTail === queueHead) {
                    queueTail = null;
                }
                queueHead = next.next;
                next.next = null;
                worker.call(context, next.value, next.worked);
                if (queueTail === null) {
                    self.empty();
                }
            } else {
                _running--;
            }
        } else if (--_running === 0) {
            self.drain();
        }
    }
    function kill() {
        queueHead = null;
        queueTail = null;
        self.drain = noop;
    }
    function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self.drain();
        self.drain = noop;
    }
    function error(handler) {
        errorHandler = handler;
    }
}
function noop() {}
function Task() {
    this.value = null;
    this.callback = noop;
    this.next = null;
    this.release = noop;
    this.context = null;
    this.errorHandler = null;
    var self = this;
    this.worked = function worked(err, result) {
        var callback = self.callback;
        var errorHandler = self.errorHandler;
        var val = self.value;
        self.value = null;
        self.callback = noop;
        if (self.errorHandler) {
            errorHandler(err, val);
        }
        callback.call(self.context, err, result);
        self.release(self);
    };
}
function queueAsPromised(context, worker, _concurrency) {
    if (typeof context === 'function') {
        _concurrency = worker;
        worker = context;
        context = null;
    }
    function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
            cb(null, res);
        }, cb);
    }
    var queue = fastqueue(context, asyncWrapper, _concurrency);
    var pushCb = queue.push;
    var unshiftCb = queue.unshift;
    queue.push = push;
    queue.unshift = unshift;
    queue.drained = drained;
    return queue;
    "TURBOPACK unreachable";
    function push(value1) {
        var p = new Promise(function(resolve, reject) {
            pushCb(value1, function(err, result) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(result);
            });
        });
        // Let's fork the promise chain to
        // make the error bubble up to the user but
        // not lead to a unhandledRejection
        p.catch(noop);
        return p;
    }
    function unshift(value1) {
        var p = new Promise(function(resolve, reject) {
            unshiftCb(value1, function(err, result) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(result);
            });
        });
        // Let's fork the promise chain to
        // make the error bubble up to the user but
        // not lead to a unhandledRejection
        p.catch(noop);
        return p;
    }
    function drained() {
        var p = new Promise(function(resolve) {
            process.nextTick(function() {
                if (queue.idle()) {
                    resolve();
                } else {
                    var previousDrain = queue.drain;
                    queue.drain = function() {
                        if (typeof previousDrain === 'function') previousDrain();
                        resolve();
                        queue.drain = previousDrain;
                    };
                }
            });
        });
        return p;
    }
}
module.exports = fastqueue;
module.exports.promise = queueAsPromised;
}}),
"[project]/node_modules/@nodelib/fs.walk/out/readers/common.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
function isFatalError(settings, error) {
    if (settings.errorFilter === null) {
        return true;
    }
    return !settings.errorFilter(error);
}
exports.isFatalError = isFatalError;
function isAppliedFilter(filter, value) {
    return filter === null || filter(value);
}
exports.isAppliedFilter = isAppliedFilter;
function replacePathSegmentSeparator(filepath, separator) {
    return filepath.split(/[/\\]/).join(separator);
}
exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
function joinPathSegments(a, b, separator) {
    if (a === '') {
        return b;
    }
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */ if (a.endsWith(separator)) {
        return a + b;
    }
    return a + separator + b;
}
exports.joinPathSegments = joinPathSegments;
}}),
"[project]/node_modules/@nodelib/fs.walk/out/readers/reader.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const common = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/readers/common.js [app-route] (ecmascript)");
class Reader {
    constructor(_root, _settings){
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
}
exports.default = Reader;
}}),
"[project]/node_modules/@nodelib/fs.walk/out/readers/async.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const fsScandir = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/index.js [app-route] (ecmascript)");
const fastq = __turbopack_context__.r("[project]/node_modules/fastq/queue.js [app-route] (ecmascript)");
const common = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/readers/common.js [app-route] (ecmascript)");
const reader_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/readers/reader.js [app-route] (ecmascript)");
class AsyncReader extends reader_1.default {
    constructor(_root, _settings){
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = ()=>{
            if (!this._isFatalError) {
                this._emitter.emit('end');
            }
        };
    }
    read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(()=>{
            this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
    }
    get isDestroyed() {
        return this._isDestroyed;
    }
    destroy() {
        if (this._isDestroyed) {
            throw new Error('The reader is already destroyed');
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
    }
    onEntry(callback) {
        this._emitter.on('entry', callback);
    }
    onError(callback) {
        this._emitter.once('error', callback);
    }
    onEnd(callback) {
        this._emitter.once('end', callback);
    }
    _pushToQueue(directory, base) {
        const queueItem = {
            directory,
            base
        };
        this._queue.push(queueItem, (error)=>{
            if (error !== null) {
                this._handleError(error);
            }
        });
    }
    _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries)=>{
            if (error !== null) {
                done(error, undefined);
                return;
            }
            for (const entry of entries){
                this._handleEntry(entry, item.base);
            }
            done(null, undefined);
        });
    }
    _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
            return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit('error', error);
    }
    _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
            return;
        }
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
        }
    }
    _emitEntry(entry) {
        this._emitter.emit('entry', entry);
    }
}
exports.default = AsyncReader;
}}),
"[project]/node_modules/@nodelib/fs.walk/out/providers/async.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const async_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/readers/async.js [app-route] (ecmascript)");
class AsyncProvider {
    constructor(_root, _settings){
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
    }
    read(callback) {
        this._reader.onError((error)=>{
            callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry)=>{
            this._storage.push(entry);
        });
        this._reader.onEnd(()=>{
            callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
    }
}
exports.default = AsyncProvider;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, entries) {
    callback(null, entries);
}
}}),
"[project]/node_modules/@nodelib/fs.walk/out/providers/stream.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const async_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/readers/async.js [app-route] (ecmascript)");
class StreamProvider {
    constructor(_root, _settings){
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
            objectMode: true,
            read: ()=>{},
            destroy: ()=>{
                if (!this._reader.isDestroyed) {
                    this._reader.destroy();
                }
            }
        });
    }
    read() {
        this._reader.onError((error)=>{
            this._stream.emit('error', error);
        });
        this._reader.onEntry((entry)=>{
            this._stream.push(entry);
        });
        this._reader.onEnd(()=>{
            this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
    }
}
exports.default = StreamProvider;
}}),
"[project]/node_modules/@nodelib/fs.walk/out/readers/sync.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const fsScandir = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/index.js [app-route] (ecmascript)");
const common = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/readers/common.js [app-route] (ecmascript)");
const reader_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/readers/reader.js [app-route] (ecmascript)");
class SyncReader extends reader_1.default {
    constructor(){
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = new Set();
    }
    read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
    }
    _pushToQueue(directory, base) {
        this._queue.add({
            directory,
            base
        });
    }
    _handleQueue() {
        for (const item of this._queue.values()){
            this._handleDirectory(item.directory, item.base);
        }
    }
    _handleDirectory(directory, base) {
        try {
            const entries = this._scandir(directory, this._settings.fsScandirSettings);
            for (const entry of entries){
                this._handleEntry(entry, base);
            }
        } catch (error) {
            this._handleError(error);
        }
    }
    _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
            return;
        }
        throw error;
    }
    _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
        }
    }
    _pushToStorage(entry) {
        this._storage.push(entry);
    }
}
exports.default = SyncReader;
}}),
"[project]/node_modules/@nodelib/fs.walk/out/providers/sync.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const sync_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/readers/sync.js [app-route] (ecmascript)");
class SyncProvider {
    constructor(_root, _settings){
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
    }
    read() {
        return this._reader.read();
    }
}
exports.default = SyncProvider;
}}),
"[project]/node_modules/@nodelib/fs.walk/out/settings.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const fsScandir = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.scandir/out/index.js [app-route] (ecmascript)");
class Settings {
    constructor(_options = {}){
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, undefined);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
            followSymbolicLinks: this._options.followSymbolicLinks,
            fs: this._options.fs,
            pathSegmentSeparator: this._options.pathSegmentSeparator,
            stats: this._options.stats,
            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
exports.default = Settings;
}}),
"[project]/node_modules/@nodelib/fs.walk/out/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
const async_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/providers/async.js [app-route] (ecmascript)");
const stream_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/providers/stream.js [app-route] (ecmascript)");
const sync_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/providers/sync.js [app-route] (ecmascript)");
const settings_1 = __turbopack_context__.r("[project]/node_modules/@nodelib/fs.walk/out/settings.js [app-route] (ecmascript)");
exports.Settings = settings_1.default;
function walk(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
    }
    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
exports.walk = walk;
function walkSync(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1.default(directory, settings);
    return provider.read();
}
exports.walkSync = walkSync;
function walkStream(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1.default(directory, settings);
    return provider.read();
}
exports.walkStream = walkStream;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}
}}),
"[project]/node_modules/array-union/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = (...arguments_)=>{
    return [
        ...new Set([].concat(...arguments_))
    ];
};
}}),
"[project]/node_modules/path-type/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
async function isType(fsStatType, statsMethodName, filePath) {
    if (typeof filePath !== 'string') {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
    }
    try {
        const stats = await promisify(fs[fsStatType])(filePath);
        return stats[statsMethodName]();
    } catch (error) {
        if (error.code === 'ENOENT') {
            return false;
        }
        throw error;
    }
}
function isTypeSync(fsStatType, statsMethodName, filePath) {
    if (typeof filePath !== 'string') {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
    }
    try {
        return fs[fsStatType](filePath)[statsMethodName]();
    } catch (error) {
        if (error.code === 'ENOENT') {
            return false;
        }
        throw error;
    }
}
exports.isFile = isType.bind(null, 'stat', 'isFile');
exports.isDirectory = isType.bind(null, 'stat', 'isDirectory');
exports.isSymlink = isType.bind(null, 'lstat', 'isSymbolicLink');
exports.isFileSync = isTypeSync.bind(null, 'statSync', 'isFile');
exports.isDirectorySync = isTypeSync.bind(null, 'statSync', 'isDirectory');
exports.isSymlinkSync = isTypeSync.bind(null, 'lstatSync', 'isSymbolicLink');
}}),
"[project]/node_modules/dir-glob/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const pathType = __turbopack_context__.r("[project]/node_modules/path-type/index.js [app-route] (ecmascript)");
const getExtensions = (extensions)=>extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0];
const getPath = (filepath, cwd)=>{
    const pth = filepath[0] === '!' ? filepath.slice(1) : filepath;
    return path.isAbsolute(pth) ? pth : path.join(cwd, pth);
};
const addExtensions = (file, extensions)=>{
    if (path.extname(file)) {
        return `**/${file}`;
    }
    return `**/${file}.${getExtensions(extensions)}`;
};
const getGlob = (directory, options)=>{
    if (options.files && !Array.isArray(options.files)) {
        throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
    }
    if (options.extensions && !Array.isArray(options.extensions)) {
        throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
    }
    if (options.files && options.extensions) {
        return options.files.map((x)=>path.posix.join(directory, addExtensions(x, options.extensions)));
    }
    if (options.files) {
        return options.files.map((x)=>path.posix.join(directory, `**/${x}`));
    }
    if (options.extensions) {
        return [
            path.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)
        ];
    }
    return [
        path.posix.join(directory, '**')
    ];
};
module.exports = async (input, options)=>{
    options = {
        cwd: process.cwd(),
        ...options
    };
    if (typeof options.cwd !== 'string') {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
    }
    const globs = await Promise.all([].concat(input).map(async (x)=>{
        const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
        return isDirectory ? getGlob(x, options) : x;
    }));
    return [].concat.apply([], globs); // eslint-disable-line prefer-spread
};
module.exports.sync = (input, options)=>{
    options = {
        cwd: process.cwd(),
        ...options
    };
    if (typeof options.cwd !== 'string') {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
    }
    const globs = [].concat(input).map((x)=>pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
    return [].concat.apply([], globs); // eslint-disable-line prefer-spread
};
}}),
"[project]/node_modules/globby/node_modules/slash/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = (path)=>{
    const isExtendedLengthPath = /^\\\\\?\\/.test(path);
    const hasNonAscii = /[^\u0000-\u0080]+/.test(path); // eslint-disable-line no-control-regex
    if (isExtendedLengthPath || hasNonAscii) {
        return path;
    }
    return path.replace(/\\/g, '/');
};
}}),
"[project]/node_modules/globby/gitignore.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const fastGlob = __turbopack_context__.r("[project]/node_modules/fast-glob/out/index.js [app-route] (ecmascript)");
const gitIgnore = __turbopack_context__.r("[project]/node_modules/globby/node_modules/ignore/index.js [app-route] (ecmascript)");
const slash = __turbopack_context__.r("[project]/node_modules/globby/node_modules/slash/index.js [app-route] (ecmascript)");
const DEFAULT_IGNORE = [
    '**/node_modules/**',
    '**/flow-typed/**',
    '**/coverage/**',
    '**/.git'
];
const readFileP = promisify(fs.readFile);
const mapGitIgnorePatternTo = (base)=>(ignore)=>{
        if (ignore.startsWith('!')) {
            return '!' + path.posix.join(base, ignore.slice(1));
        }
        return path.posix.join(base, ignore);
    };
const parseGitIgnore = (content, options)=>{
    const base = slash(path.relative(options.cwd, path.dirname(options.fileName)));
    return content.split(/\r?\n/).filter(Boolean).filter((line)=>!line.startsWith('#')).map(mapGitIgnorePatternTo(base));
};
const reduceIgnore = (files)=>{
    const ignores = gitIgnore();
    for (const file of files){
        ignores.add(parseGitIgnore(file.content, {
            cwd: file.cwd,
            fileName: file.filePath
        }));
    }
    return ignores;
};
const ensureAbsolutePathForCwd = (cwd, p)=>{
    cwd = slash(cwd);
    if (path.isAbsolute(p)) {
        if (slash(p).startsWith(cwd)) {
            return p;
        }
        throw new Error(`Path ${p} is not in cwd ${cwd}`);
    }
    return path.join(cwd, p);
};
const getIsIgnoredPredecate = (ignores, cwd)=>{
    return (p)=>ignores.ignores(slash(path.relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))));
};
const getFile = async (file, cwd)=>{
    const filePath = path.join(cwd, file);
    const content = await readFileP(filePath, 'utf8');
    return {
        cwd,
        filePath,
        content
    };
};
const getFileSync = (file, cwd)=>{
    const filePath = path.join(cwd, file);
    const content = fs.readFileSync(filePath, 'utf8');
    return {
        cwd,
        filePath,
        content
    };
};
const normalizeOptions = ({ ignore = [], cwd = slash(process.cwd()) } = {})=>{
    return {
        ignore,
        cwd
    };
};
module.exports = async (options)=>{
    options = normalizeOptions(options);
    const paths = await fastGlob('**/.gitignore', {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
    });
    const files = await Promise.all(paths.map((file)=>getFile(file, options.cwd)));
    const ignores = reduceIgnore(files);
    return getIsIgnoredPredecate(ignores, options.cwd);
};
module.exports.sync = (options)=>{
    options = normalizeOptions(options);
    const paths = fastGlob.sync('**/.gitignore', {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
    });
    const files = paths.map((file)=>getFileSync(file, options.cwd));
    const ignores = reduceIgnore(files);
    return getIsIgnoredPredecate(ignores, options.cwd);
};
}}),
"[project]/node_modules/globby/stream-utils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const { Transform } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
class ObjectTransform extends Transform {
    constructor(){
        super({
            objectMode: true
        });
    }
}
class FilterStream extends ObjectTransform {
    constructor(filter){
        super();
        this._filter = filter;
    }
    _transform(data, encoding, callback) {
        if (this._filter(data)) {
            this.push(data);
        }
        callback();
    }
}
class UniqueStream extends ObjectTransform {
    constructor(){
        super();
        this._pushed = new Set();
    }
    _transform(data, encoding, callback) {
        if (!this._pushed.has(data)) {
            this.push(data);
            this._pushed.add(data);
        }
        callback();
    }
}
module.exports = {
    FilterStream,
    UniqueStream
};
}}),
"[project]/node_modules/globby/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const arrayUnion = __turbopack_context__.r("[project]/node_modules/array-union/index.js [app-route] (ecmascript)");
const merge2 = __turbopack_context__.r("[project]/node_modules/merge2/index.js [app-route] (ecmascript)");
const fastGlob = __turbopack_context__.r("[project]/node_modules/fast-glob/out/index.js [app-route] (ecmascript)");
const dirGlob = __turbopack_context__.r("[project]/node_modules/dir-glob/index.js [app-route] (ecmascript)");
const gitignore = __turbopack_context__.r("[project]/node_modules/globby/gitignore.js [app-route] (ecmascript)");
const { FilterStream, UniqueStream } = __turbopack_context__.r("[project]/node_modules/globby/stream-utils.js [app-route] (ecmascript)");
const DEFAULT_FILTER = ()=>false;
const isNegative = (pattern)=>pattern[0] === '!';
const assertPatternsInput = (patterns)=>{
    if (!patterns.every((pattern)=>typeof pattern === 'string')) {
        throw new TypeError('Patterns must be a string or an array of strings');
    }
};
const checkCwdOption = (options = {})=>{
    if (!options.cwd) {
        return;
    }
    let stat;
    try {
        stat = fs.statSync(options.cwd);
    } catch  {
        return;
    }
    if (!stat.isDirectory()) {
        throw new Error('The `cwd` option must be a path to a directory');
    }
};
const getPathString = (p)=>p.stats instanceof fs.Stats ? p.path : p;
const generateGlobTasks = (patterns, taskOptions)=>{
    patterns = arrayUnion([].concat(patterns));
    assertPatternsInput(patterns);
    checkCwdOption(taskOptions);
    const globTasks = [];
    taskOptions = {
        ignore: [],
        expandDirectories: true,
        ...taskOptions
    };
    for (const [index, pattern] of patterns.entries()){
        if (isNegative(pattern)) {
            continue;
        }
        const ignore = patterns.slice(index).filter((pattern)=>isNegative(pattern)).map((pattern)=>pattern.slice(1));
        const options = {
            ...taskOptions,
            ignore: taskOptions.ignore.concat(ignore)
        };
        globTasks.push({
            pattern,
            options
        });
    }
    return globTasks;
};
const globDirs = (task, fn)=>{
    let options = {};
    if (task.options.cwd) {
        options.cwd = task.options.cwd;
    }
    if (Array.isArray(task.options.expandDirectories)) {
        options = {
            ...options,
            files: task.options.expandDirectories
        };
    } else if (typeof task.options.expandDirectories === 'object') {
        options = {
            ...options,
            ...task.options.expandDirectories
        };
    }
    return fn(task.pattern, options);
};
const getPattern = (task, fn)=>task.options.expandDirectories ? globDirs(task, fn) : [
        task.pattern
    ];
const getFilterSync = (options)=>{
    return options && options.gitignore ? gitignore.sync({
        cwd: options.cwd,
        ignore: options.ignore
    }) : DEFAULT_FILTER;
};
const globToTask = (task)=>(glob)=>{
        const { options } = task;
        if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
            options.ignore = dirGlob.sync(options.ignore);
        }
        return {
            pattern: glob,
            options
        };
    };
module.exports = async (patterns, options)=>{
    const globTasks = generateGlobTasks(patterns, options);
    const getFilter = async ()=>{
        return options && options.gitignore ? gitignore({
            cwd: options.cwd,
            ignore: options.ignore
        }) : DEFAULT_FILTER;
    };
    const getTasks = async ()=>{
        const tasks = await Promise.all(globTasks.map(async (task)=>{
            const globs = await getPattern(task, dirGlob);
            return Promise.all(globs.map(globToTask(task)));
        }));
        return arrayUnion(...tasks);
    };
    const [filter, tasks] = await Promise.all([
        getFilter(),
        getTasks()
    ]);
    const paths = await Promise.all(tasks.map((task)=>fastGlob(task.pattern, task.options)));
    return arrayUnion(...paths).filter((path_)=>!filter(getPathString(path_)));
};
module.exports.sync = (patterns, options)=>{
    const globTasks = generateGlobTasks(patterns, options);
    const tasks = [];
    for (const task of globTasks){
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks.push(...newTask);
    }
    const filter = getFilterSync(options);
    let matches = [];
    for (const task of tasks){
        matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));
    }
    return matches.filter((path_)=>!filter(path_));
};
module.exports.stream = (patterns, options)=>{
    const globTasks = generateGlobTasks(patterns, options);
    const tasks = [];
    for (const task of globTasks){
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks.push(...newTask);
    }
    const filter = getFilterSync(options);
    const filterStream = new FilterStream((p)=>!filter(p));
    const uniqueStream = new UniqueStream();
    return merge2(tasks.map((task)=>fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
};
module.exports.generateGlobTasks = generateGlobTasks;
module.exports.hasMagic = (patterns, options)=>[].concat(patterns).some((pattern)=>fastGlob.isDynamicPattern(pattern, options));
module.exports.gitignore = gitignore;
}}),
"[project]/node_modules/signal-exit/dist/cjs/signals.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.signals = void 0;
/**
 * This is not the set of all possible signals.
 *
 * It IS, however, the set of all signals that trigger
 * an exit on either Linux or BSD systems.  Linux is a
 * superset of the signal names supported on BSD, and
 * the unknown signals just fail to register, so we can
 * catch that easily enough.
 *
 * Windows signals are a different set, since there are
 * signals that terminate Windows processes, but don't
 * terminate (or don't even exist) on Posix systems.
 *
 * Don't bother with SIGKILL.  It's uncatchable, which
 * means that we can't fire any callbacks anyway.
 *
 * If a user does happen to register a handler on a non-
 * fatal signal like SIGWINCH or something, and then
 * exit, it'll end up firing `process.emit('exit')`, so
 * the handler will be fired anyway.
 *
 * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
 * artificially, inherently leave the process in a
 * state from which it is not safe to try and enter JS
 * listeners.
 */ exports.signals = [];
exports.signals.push('SIGHUP', 'SIGINT', 'SIGTERM');
if ("TURBOPACK compile-time truthy", 1) {
    exports.signals.push('SIGALRM', 'SIGABRT', 'SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT');
}
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} //# sourceMappingURL=signals.js.map
}}),
"[project]/node_modules/signal-exit/dist/cjs/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unload = exports.load = exports.onExit = exports.signals = void 0;
// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
const signals_js_1 = __turbopack_context__.r("[project]/node_modules/signal-exit/dist/cjs/signals.js [app-route] (ecmascript)");
Object.defineProperty(exports, "signals", {
    enumerable: true,
    get: function() {
        return signals_js_1.signals;
    }
});
const processOk = (process)=>!!process && typeof process === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';
const kExitEmitter = Symbol.for('signal-exit emitter');
const global = globalThis;
const ObjectDefineProperty = Object.defineProperty.bind(Object);
// teeny special purpose ee
class Emitter {
    emitted = {
        afterExit: false,
        exit: false
    };
    listeners = {
        afterExit: [],
        exit: []
    };
    count = 0;
    id = Math.random();
    constructor(){
        if (global[kExitEmitter]) {
            return global[kExitEmitter];
        }
        ObjectDefineProperty(global, kExitEmitter, {
            value: this,
            writable: false,
            enumerable: false,
            configurable: false
        });
    }
    on(ev, fn) {
        this.listeners[ev].push(fn);
    }
    removeListener(ev, fn) {
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        /* c8 ignore start */ if (i === -1) {
            return;
        }
        /* c8 ignore stop */ if (i === 0 && list.length === 1) {
            list.length = 0;
        } else {
            list.splice(i, 1);
        }
    }
    emit(ev, code, signal) {
        if (this.emitted[ev]) {
            return false;
        }
        this.emitted[ev] = true;
        let ret = false;
        for (const fn of this.listeners[ev]){
            ret = fn(code, signal) === true || ret;
        }
        if (ev === 'exit') {
            ret = this.emit('afterExit', code, signal) || ret;
        }
        return ret;
    }
}
class SignalExitBase {
}
const signalExitWrap = (handler)=>{
    return {
        onExit (cb, opts) {
            return handler.onExit(cb, opts);
        },
        load () {
            return handler.load();
        },
        unload () {
            return handler.unload();
        }
    };
};
class SignalExitFallback extends SignalExitBase {
    onExit() {
        return ()=>{};
    }
    load() {}
    unload() {}
}
class SignalExit extends SignalExitBase {
    // "SIGHUP" throws an `ENOSYS` error on Windows,
    // so use a supported signal instead
    /* c8 ignore start */ #hupSig = process.platform === 'win32' ? 'SIGINT' : 'SIGHUP';
    /* c8 ignore stop */ #emitter = new Emitter();
    #process;
    #originalProcessEmit;
    #originalProcessReallyExit;
    #sigListeners = {};
    #loaded = false;
    constructor(process){
        super();
        this.#process = process;
        // { <signal>: <listener fn>, ... }
        this.#sigListeners = {};
        for (const sig of signals_js_1.signals){
            this.#sigListeners[sig] = ()=>{
                // If there are no other listeners, an exit is coming!
                // Simplest way: remove us and then re-send the signal.
                // We know that this will kill the process, so we can
                // safely emit now.
                const listeners = this.#process.listeners(sig);
                let { count } = this.#emitter;
                // This is a workaround for the fact that signal-exit v3 and signal
                // exit v4 are not aware of each other, and each will attempt to let
                // the other handle it, so neither of them do. To correct this, we
                // detect if we're the only handler *except* for previous versions
                // of signal-exit, and increment by the count of listeners it has
                // created.
                /* c8 ignore start */ const p = process;
                if (typeof p.__signal_exit_emitter__ === 'object' && typeof p.__signal_exit_emitter__.count === 'number') {
                    count += p.__signal_exit_emitter__.count;
                }
                /* c8 ignore stop */ if (listeners.length === count) {
                    this.unload();
                    const ret = this.#emitter.emit('exit', null, sig);
                    /* c8 ignore start */ const s = sig === 'SIGHUP' ? this.#hupSig : sig;
                    if (!ret) process.kill(process.pid, s);
                /* c8 ignore stop */ }
            };
        }
        this.#originalProcessReallyExit = process.reallyExit;
        this.#originalProcessEmit = process.emit;
    }
    onExit(cb, opts) {
        /* c8 ignore start */ if (!processOk(this.#process)) {
            return ()=>{};
        }
        /* c8 ignore stop */ if (this.#loaded === false) {
            this.load();
        }
        const ev = opts?.alwaysLast ? 'afterExit' : 'exit';
        this.#emitter.on(ev, cb);
        return ()=>{
            this.#emitter.removeListener(ev, cb);
            if (this.#emitter.listeners['exit'].length === 0 && this.#emitter.listeners['afterExit'].length === 0) {
                this.unload();
            }
        };
    }
    load() {
        if (this.#loaded) {
            return;
        }
        this.#loaded = true;
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        this.#emitter.count += 1;
        for (const sig of signals_js_1.signals){
            try {
                const fn = this.#sigListeners[sig];
                if (fn) this.#process.on(sig, fn);
            } catch (_) {}
        }
        this.#process.emit = (ev, ...a)=>{
            return this.#processEmit(ev, ...a);
        };
        this.#process.reallyExit = (code)=>{
            return this.#processReallyExit(code);
        };
    }
    unload() {
        if (!this.#loaded) {
            return;
        }
        this.#loaded = false;
        signals_js_1.signals.forEach((sig)=>{
            const listener = this.#sigListeners[sig];
            /* c8 ignore start */ if (!listener) {
                throw new Error('Listener not defined for signal: ' + sig);
            }
            /* c8 ignore stop */ try {
                this.#process.removeListener(sig, listener);
            /* c8 ignore start */ } catch (_) {}
        /* c8 ignore stop */ });
        this.#process.emit = this.#originalProcessEmit;
        this.#process.reallyExit = this.#originalProcessReallyExit;
        this.#emitter.count -= 1;
    }
    #processReallyExit(code) {
        /* c8 ignore start */ if (!processOk(this.#process)) {
            return 0;
        }
        this.#process.exitCode = code || 0;
        /* c8 ignore stop */ this.#emitter.emit('exit', this.#process.exitCode, null);
        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
    }
    #processEmit(ev, ...args) {
        const og = this.#originalProcessEmit;
        if (ev === 'exit' && processOk(this.#process)) {
            if (typeof args[0] === 'number') {
                this.#process.exitCode = args[0];
            /* c8 ignore start */ }
            /* c8 ignore start */ const ret = og.call(this.#process, ev, ...args);
            /* c8 ignore start */ this.#emitter.emit('exit', this.#process.exitCode, null);
            /* c8 ignore stop */ return ret;
        } else {
            return og.call(this.#process, ev, ...args);
        }
    }
}
const process = globalThis.process;
// wrap so that we call the method on the actual handler, without
// exporting it directly.
_a = signalExitWrap(processOk(process) ? new SignalExit(process) : new SignalExitFallback()), /**
 * Called when the process is exiting, whether via signal, explicit
 * exit, or running out of stuff to do.
 *
 * If the global process object is not suitable for instrumentation,
 * then this will be a no-op.
 *
 * Returns a function that may be used to unload signal-exit.
 */ exports.onExit = _a.onExit, /**
 * Load the listeners.  Likely you never need to call this, unless
 * doing a rather deep integration with signal-exit functionality.
 * Mostly exposed for the benefit of testing.
 *
 * @internal
 */ exports.load = _a.load, /**
 * Unload the listeners.  Likely you never need to call this, unless
 * doing a rather deep integration with signal-exit functionality.
 * Mostly exposed for the benefit of testing.
 *
 * @internal
 */ exports.unload = _a.unload; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/stylelint/node_modules/write-file-atomic/lib/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = writeFile;
module.exports.sync = writeFileSync;
module.exports._getTmpname = getTmpname // for testing
;
module.exports._cleanupOnExit = cleanupOnExit;
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const MurmurHash3 = __turbopack_context__.r("[project]/node_modules/imurmurhash/imurmurhash.js [app-route] (ecmascript)");
const { onExit } = __turbopack_context__.r("[project]/node_modules/signal-exit/dist/cjs/index.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const activeFiles = {};
// if we run inside of a worker_thread, `process.pid` is not unique
/* istanbul ignore next */ const threadId = function getId() {
    try {
        const workerThreads = __turbopack_context__.r("[externals]/worker_threads [external] (worker_threads, cjs)");
        /// if we are in main thread, this is set to `0`
        return workerThreads.threadId;
    } catch (e) {
        // worker_threads are not available, fallback to 0
        return 0;
    }
}();
let invocations = 0;
function getTmpname(filename) {
    return filename + '.' + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
}
function cleanupOnExit(tmpfile) {
    return ()=>{
        try {
            fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile);
        } catch  {
        // ignore errors
        }
    };
}
function serializeActiveFile(absoluteName) {
    return new Promise((resolve)=>{
        // make a queue if it doesn't already exist
        if (!activeFiles[absoluteName]) {
            activeFiles[absoluteName] = [];
        }
        activeFiles[absoluteName].push(resolve) // add this job to the queue
        ;
        if (activeFiles[absoluteName].length === 1) {
            resolve();
        } // kick off the first one
    });
}
// https://github.com/isaacs/node-graceful-fs/blob/master/polyfills.js#L315-L342
function isChownErrOk(err) {
    if (err.code === 'ENOSYS') {
        return true;
    }
    const nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
        if (err.code === 'EINVAL' || err.code === 'EPERM') {
            return true;
        }
    }
    return false;
}
async function writeFileAsync(filename, data, options = {}) {
    if (typeof options === 'string') {
        options = {
            encoding: options
        };
    }
    let fd;
    let tmpfile;
    /* istanbul ignore next -- The closure only gets called when onExit triggers */ const removeOnExitHandler = onExit(cleanupOnExit(()=>tmpfile));
    const absoluteName = path.resolve(filename);
    try {
        await serializeActiveFile(absoluteName);
        const truename = await promisify(fs.realpath)(filename).catch(()=>filename);
        tmpfile = getTmpname(truename);
        if (!options.mode || !options.chown) {
            // Either mode or chown is not explicitly set
            // Default behavior is to copy it from original file
            const stats = await promisify(fs.stat)(truename).catch(()=>{});
            if (stats) {
                if (options.mode == null) {
                    options.mode = stats.mode;
                }
                if (options.chown == null && process.getuid) {
                    options.chown = {
                        uid: stats.uid,
                        gid: stats.gid
                    };
                }
            }
        }
        fd = await promisify(fs.open)(tmpfile, 'w', options.mode);
        if (options.tmpfileCreated) {
            await options.tmpfileCreated(tmpfile);
        }
        if (ArrayBuffer.isView(data)) {
            await promisify(fs.write)(fd, data, 0, data.length, 0);
        } else if (data != null) {
            await promisify(fs.write)(fd, String(data), 0, String(options.encoding || 'utf8'));
        }
        if (options.fsync !== false) {
            await promisify(fs.fsync)(fd);
        }
        await promisify(fs.close)(fd);
        fd = null;
        if (options.chown) {
            await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid).catch((err)=>{
                if (!isChownErrOk(err)) {
                    throw err;
                }
            });
        }
        if (options.mode) {
            await promisify(fs.chmod)(tmpfile, options.mode).catch((err)=>{
                if (!isChownErrOk(err)) {
                    throw err;
                }
            });
        }
        await promisify(fs.rename)(tmpfile, truename);
    } finally{
        if (fd) {
            await promisify(fs.close)(fd).catch(/* istanbul ignore next */ ()=>{});
        }
        removeOnExitHandler();
        await promisify(fs.unlink)(tmpfile).catch(()=>{});
        activeFiles[absoluteName].shift() // remove the element added by serializeSameFile
        ;
        if (activeFiles[absoluteName].length > 0) {
            activeFiles[absoluteName][0]() // start next job if one is pending
            ;
        } else {
            delete activeFiles[absoluteName];
        }
    }
}
async function writeFile(filename, data, options, callback) {
    if (options instanceof Function) {
        callback = options;
        options = {};
    }
    const promise = writeFileAsync(filename, data, options);
    if (callback) {
        try {
            const result = await promise;
            return callback(result);
        } catch (err) {
            return callback(err);
        }
    }
    return promise;
}
function writeFileSync(filename, data, options) {
    if (typeof options === 'string') {
        options = {
            encoding: options
        };
    } else if (!options) {
        options = {};
    }
    try {
        filename = fs.realpathSync(filename);
    } catch (ex) {
    // it's ok, it'll happen on a not yet existing file
    }
    const tmpfile = getTmpname(filename);
    if (!options.mode || !options.chown) {
        // Either mode or chown is not explicitly set
        // Default behavior is to copy it from original file
        try {
            const stats = fs.statSync(filename);
            options = Object.assign({}, options);
            if (!options.mode) {
                options.mode = stats.mode;
            }
            if (!options.chown && process.getuid) {
                options.chown = {
                    uid: stats.uid,
                    gid: stats.gid
                };
            }
        } catch (ex) {
        // ignore stat errors
        }
    }
    let fd;
    const cleanup = cleanupOnExit(tmpfile);
    const removeOnExitHandler = onExit(cleanup);
    let threw = true;
    try {
        fd = fs.openSync(tmpfile, 'w', options.mode || 0o666);
        if (options.tmpfileCreated) {
            options.tmpfileCreated(tmpfile);
        }
        if (ArrayBuffer.isView(data)) {
            fs.writeSync(fd, data, 0, data.length, 0);
        } else if (data != null) {
            fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'));
        }
        if (options.fsync !== false) {
            fs.fsyncSync(fd);
        }
        fs.closeSync(fd);
        fd = null;
        if (options.chown) {
            try {
                fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);
            } catch (err) {
                if (!isChownErrOk(err)) {
                    throw err;
                }
            }
        }
        if (options.mode) {
            try {
                fs.chmodSync(tmpfile, options.mode);
            } catch (err) {
                if (!isChownErrOk(err)) {
                    throw err;
                }
            }
        }
        fs.renameSync(tmpfile, filename);
        threw = false;
    } finally{
        if (fd) {
            try {
                fs.closeSync(fd);
            } catch (ex) {
            // ignore close errors at this stage, error may have closed fd already.
            }
        }
        removeOnExitHandler();
        if (threw) {
            cleanup();
        }
    }
}
}}),

};

//# sourceMappingURL=node_modules_bed15356._.js.map