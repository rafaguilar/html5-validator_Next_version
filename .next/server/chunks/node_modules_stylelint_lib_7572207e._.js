module.exports = {

"[project]/node_modules/stylelint/lib/utils/addEmptyLineBefore.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Add one or two empty line(s) before a node. Mutates the node.
 *
 * @template {import('postcss').Node} T
 * @param {T} node
 * @param {string} newline
 * @returns {T}
 */ __turbopack_context__.s({
    "default": (()=>addEmptyLineBefore)
});
function addEmptyLineBefore(node, newline) {
    const { raws } = node;
    if (typeof raws.before !== 'string') {
        return node;
    }
    raws.before = !/\r?\n/.test(raws.before) ? newline.repeat(2) + raws.before : raws.before.replace(/(\r?\n)/, `${newline}$1`);
    return node;
}
}}),
"[project]/node_modules/stylelint/lib/utils/removeEmptyLinesBefore.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Remove empty lines before a node. Mutates the node.
 *
 * @template {import('postcss').Node} T
 * @param {T} node
 * @param {string} newline
 * @returns {T}
 */ __turbopack_context__.s({
    "default": (()=>removeEmptyLinesBefore)
});
function removeEmptyLinesBefore(node, newline) {
    node.raws.before = node.raws.before ? node.raws.before.replace(/(\r?\n\s*\n)+/g, newline) : '';
    return node;
}
}}),
"[project]/node_modules/stylelint/lib/utils/fixEmptyLinesBefore.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>fixEmptyLinesBefore)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$addEmptyLineBefore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/addEmptyLineBefore.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/validateTypes.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$removeEmptyLinesBefore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/removeEmptyLinesBefore.mjs [app-route] (ecmascript)");
;
;
;
function fixEmptyLinesBefore({ node, newline, action }) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(newline);
    switch(action){
        case 'add':
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$addEmptyLineBefore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(node, newline);
            break;
        case 'remove':
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$removeEmptyLinesBefore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(node, newline);
            break;
        default:
            throw new TypeError(`Unknown action ${action}`);
    }
}
}}),
"[project]/node_modules/stylelint/lib/utils/hasEmptyLine.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>hasEmptyLine)
});
const HAS_EMPTY_LINE = /\n[\r\t ]*\n/;
function hasEmptyLine(string) {
    if (string === '' || string === undefined) return false;
    return HAS_EMPTY_LINE.test(string);
}
}}),
"[project]/node_modules/stylelint/lib/utils/getNextNonSharedLineCommentNode.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/** @typedef {import('postcss').Node} Node */ /**
 * @param {Node | void} node
 */ __turbopack_context__.s({
    "default": (()=>getNextNonSharedLineCommentNode)
});
function getNodeLine(node) {
    return node && node.source && node.source.start && node.source.start.line;
}
function getNextNonSharedLineCommentNode(node) {
    if (node === undefined) {
        return undefined;
    }
    /** @type {Node | void} */ const nextNode = node.next();
    if (!nextNode || nextNode.type !== 'comment') {
        return nextNode;
    }
    if (getNodeLine(node) === getNodeLine(nextNode) || getNodeLine(nextNode) === getNodeLine(nextNode.next())) {
        return getNextNonSharedLineCommentNode(nextNode);
    }
    return nextNode;
}
}}),
"[project]/node_modules/stylelint/lib/utils/getPreviousNonSharedLineCommentNode.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/** @typedef {import('postcss').Node} Node */ /**
 * @param {Node} node
 */ __turbopack_context__.s({
    "default": (()=>getPreviousNonSharedLineCommentNode)
});
function getNodeLine(node) {
    return node.source && node.source.start && node.source.start.line;
}
function getPreviousNonSharedLineCommentNode(node) {
    if (node === undefined) {
        return undefined;
    }
    const previousNode = node.prev();
    if (!previousNode || previousNode.type !== 'comment') {
        return previousNode;
    }
    if (getNodeLine(node) === getNodeLine(previousNode)) {
        return getPreviousNonSharedLineCommentNode(previousNode);
    }
    const previousNode2 = previousNode.prev();
    if (previousNode2 && getNodeLine(previousNode) === getNodeLine(previousNode2)) {
        return getPreviousNonSharedLineCommentNode(previousNode);
    }
    return previousNode;
}
}}),
"[project]/node_modules/stylelint/lib/utils/isSharedLineComment.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>isSharedLineComment)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/typeGuards.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getNextNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/getNextNonSharedLineCommentNode.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getPreviousNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/getPreviousNonSharedLineCommentNode.mjs [app-route] (ecmascript)");
;
;
;
/** @typedef {import('postcss').Node} PostcssNode */ /**
 * @param {PostcssNode | void} a
 * @param {PostcssNode | void} b
 */ function nodesShareLines(a, b) {
    const endLine = a && a.source && a.source.end && a.source.end.line;
    const startLine = b && b.source && b.source.start && b.source.start.line;
    return endLine === startLine;
}
function isSharedLineComment(node) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isComment"])(node)) {
        return false;
    }
    const previousNonSharedLineCommentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getPreviousNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(node);
    if (nodesShareLines(previousNonSharedLineCommentNode, node)) {
        return true;
    }
    const nextNonSharedLineCommentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getNextNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(node);
    if (nextNonSharedLineCommentNode && nodesShareLines(node, nextNonSharedLineCommentNode)) {
        return true;
    }
    const parentNode = node.parent;
    // It's a first child and located on the same line as block start
    if (parentNode !== undefined && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRoot"])(parentNode) && parentNode.index(node) === 0 && node.raws.before !== undefined && !node.raws.before.includes('\n')) {
        return true;
    }
    return false;
}
}}),
"[project]/node_modules/stylelint/lib/utils/isAfterComment.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>isAfterComment)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isSharedLineComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isSharedLineComment.mjs [app-route] (ecmascript)");
;
function isAfterComment(node) {
    const previousNode = node.prev();
    if (!previousNode || previousNode.type !== 'comment') {
        return false;
    }
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isSharedLineComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(previousNode);
}
}}),
"[project]/node_modules/stylelint/lib/utils/isFirstNested.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>isFirstNested)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/typeGuards.mjs [app-route] (ecmascript)");
;
function isFirstNested(statement) {
    const parentNode = statement.parent;
    if (parentNode === undefined) {
        return false;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRoot"])(parentNode) && !isInDocument(parentNode)) {
        return false;
    }
    if (statement === parentNode.first) {
        return true;
    }
    /*
	 * Search for the statement in the parent's nodes, ignoring comment
	 * nodes on the same line as the parent's opening brace.
	 */ const parentNodes = parentNode.nodes;
    if (!parentNodes) {
        return false;
    }
    const firstNode = parentNodes[0];
    if (!firstNode) {
        return false;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isComment"])(firstNode) || typeof firstNode.raws.before === 'string' && firstNode.raws.before.includes('\n')) {
        return false;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hasSource"])(firstNode) || !firstNode.source.start) {
        return false;
    }
    const openingBraceLine = firstNode.source.start.line;
    if (!firstNode.source.end || openingBraceLine !== firstNode.source.end.line) {
        return false;
    }
    for (const [index, node] of parentNodes.entries()){
        if (index === 0) {
            continue;
        }
        if (node === statement) {
            return true;
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isComment"])(node) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hasSource"])(node) && node.source.end && node.source.end.line !== openingBraceLine) {
            return false;
        }
    }
    /* istanbul ignore next: Should always return in the loop */ return false;
}
/**
 * @param {import('postcss').Node} node
 * @returns {boolean}
 */ function isInDocument({ parent }) {
    return Boolean(parent && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isDocument"])(parent));
}
}}),
"[project]/node_modules/stylelint/lib/utils/isFirstNodeOfRoot.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>isFirstNodeOfRoot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/typeGuards.mjs [app-route] (ecmascript)");
;
function isFirstNodeOfRoot(node) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRoot"])(node)) return false;
    const parentNode = node.parent;
    if (!parentNode) {
        return false;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRoot"])(parentNode) && node === parentNode.first;
}
}}),
"[project]/node_modules/stylelint/lib/rules/comment-empty-line-before/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/validateTypes.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$fixEmptyLinesBefore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/fixEmptyLinesBefore.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$hasEmptyLine$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/hasEmptyLine.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isAfterComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isAfterComment.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$configurationComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/configurationComment.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isFirstNested$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isFirstNested.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isFirstNodeOfRoot$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isFirstNodeOfRoot.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isSharedLineComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isSharedLineComment.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isStandardSyntaxComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isStandardSyntaxComment.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/optionsMatches.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$report$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/report.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$ruleMessages$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/ruleMessages.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateOptions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/validateOptions.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
const ruleName = 'comment-empty-line-before';
const messages = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$ruleMessages$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(ruleName, {
    expected: 'Expected empty line before comment',
    rejected: 'Unexpected empty line before comment'
});
const meta = {
    url: 'https://stylelint.io/user-guide/rules/comment-empty-line-before',
    fixable: true
};
/** @type {import('stylelint').CoreRules[ruleName]} */ const rule = (primary, secondaryOptions, context)=>{
    return (root, result)=>{
        const validOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateOptions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(result, ruleName, {
            actual: primary,
            possible: [
                'always',
                'never'
            ]
        }, {
            actual: secondaryOptions,
            possible: {
                except: [
                    'first-nested'
                ],
                ignore: [
                    'stylelint-commands',
                    'after-comment'
                ],
                ignoreComments: [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isString"],
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRegExp"]
                ]
            },
            optional: true
        });
        if (!validOptions) {
            return;
        }
        root.walkComments((comment)=>{
            // Ignore the first node
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isFirstNodeOfRoot$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(comment)) {
                return;
            }
            // Optionally ignore stylelint commands
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$configurationComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isConfigurationComment"])(comment, context.configurationComment) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'ignore', 'stylelint-commands')) {
                return;
            }
            // Optionally ignore newlines between comments
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'ignore', 'after-comment') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isAfterComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(comment)) {
                return;
            }
            // Ignore comments matching the ignoreComments option.
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'ignoreComments', comment.text)) {
                return;
            }
            // Ignore shared-line comments
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isSharedLineComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(comment)) {
                return;
            }
            // Ignore non-standard comments
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isStandardSyntaxComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(comment)) {
                return;
            }
            const expectEmptyLineBefore = (()=>{
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'except', 'first-nested') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isFirstNested$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(comment)) {
                    return false;
                }
                return primary === 'always';
            })();
            const before = comment.raws.before || '';
            const hasEmptyLineBefore = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$hasEmptyLine$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(before);
            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
                return;
            }
            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;
            const action = expectEmptyLineBefore ? 'add' : 'remove';
            // Fix
            const fix = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$fixEmptyLinesBefore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
                    node: comment,
                    newline: context.newline,
                    action
                });
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$report$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
                message,
                node: comment,
                result,
                ruleName,
                fix: {
                    apply: fix,
                    node: comment.parent
                }
            });
        });
    };
};
rule.ruleName = ruleName;
rule.messages = messages;
rule.meta = meta;
const __TURBOPACK__default__export__ = rule;
}}),

};

//# sourceMappingURL=node_modules_stylelint_lib_7572207e._.js.map