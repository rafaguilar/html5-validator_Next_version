module.exports = {

"[project]/node_modules/table/dist/src/getBorderCharacters.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* eslint-disable sort-keys-fix/sort-keys-fix */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getBorderCharacters = void 0;
const getBorderCharacters = (name)=>{
    if (name === 'honeywell') {
        return {
            topBody: '═',
            topJoin: '╤',
            topLeft: '╔',
            topRight: '╗',
            bottomBody: '═',
            bottomJoin: '╧',
            bottomLeft: '╚',
            bottomRight: '╝',
            bodyLeft: '║',
            bodyRight: '║',
            bodyJoin: '│',
            headerJoin: '┬',
            joinBody: '─',
            joinLeft: '╟',
            joinRight: '╢',
            joinJoin: '┼',
            joinMiddleDown: '┬',
            joinMiddleUp: '┴',
            joinMiddleLeft: '┤',
            joinMiddleRight: '├'
        };
    }
    if (name === 'norc') {
        return {
            topBody: '─',
            topJoin: '┬',
            topLeft: '┌',
            topRight: '┐',
            bottomBody: '─',
            bottomJoin: '┴',
            bottomLeft: '└',
            bottomRight: '┘',
            bodyLeft: '│',
            bodyRight: '│',
            bodyJoin: '│',
            headerJoin: '┬',
            joinBody: '─',
            joinLeft: '├',
            joinRight: '┤',
            joinJoin: '┼',
            joinMiddleDown: '┬',
            joinMiddleUp: '┴',
            joinMiddleLeft: '┤',
            joinMiddleRight: '├'
        };
    }
    if (name === 'ramac') {
        return {
            topBody: '-',
            topJoin: '+',
            topLeft: '+',
            topRight: '+',
            bottomBody: '-',
            bottomJoin: '+',
            bottomLeft: '+',
            bottomRight: '+',
            bodyLeft: '|',
            bodyRight: '|',
            bodyJoin: '|',
            headerJoin: '+',
            joinBody: '-',
            joinLeft: '|',
            joinRight: '|',
            joinJoin: '|',
            joinMiddleDown: '+',
            joinMiddleUp: '+',
            joinMiddleLeft: '+',
            joinMiddleRight: '+'
        };
    }
    if (name === 'void') {
        return {
            topBody: '',
            topJoin: '',
            topLeft: '',
            topRight: '',
            bottomBody: '',
            bottomJoin: '',
            bottomLeft: '',
            bottomRight: '',
            bodyLeft: '',
            bodyRight: '',
            bodyJoin: '',
            headerJoin: '',
            joinBody: '',
            joinLeft: '',
            joinRight: '',
            joinJoin: '',
            joinMiddleDown: '',
            joinMiddleUp: '',
            joinMiddleLeft: '',
            joinMiddleRight: ''
        };
    }
    throw new Error('Unknown border template "' + name + '".');
};
exports.getBorderCharacters = getBorderCharacters; //# sourceMappingURL=getBorderCharacters.js.map
}}),
"[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isCellInRange = exports.areCellEqual = exports.calculateRangeCoordinate = exports.flatten = exports.extractTruncates = exports.sumArray = exports.sequence = exports.distributeUnevenly = exports.countSpaceSequence = exports.groupBySizes = exports.makeBorderConfig = exports.splitAnsi = exports.normalizeString = void 0;
const slice_ansi_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/slice-ansi/index.js [app-route] (ecmascript)"));
const string_width_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/table/node_modules/string-width/index.js [app-route] (ecmascript)"));
const strip_ansi_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/table/node_modules/strip-ansi/index.js [app-route] (ecmascript)"));
const getBorderCharacters_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/getBorderCharacters.js [app-route] (ecmascript)");
/**
 * Converts Windows-style newline to Unix-style
 *
 * @internal
 */ const normalizeString = (input)=>{
    return input.replace(/\r\n/g, '\n');
};
exports.normalizeString = normalizeString;
/**
 * Splits ansi string by newlines
 *
 * @internal
 */ const splitAnsi = (input)=>{
    const lengths = (0, strip_ansi_1.default)(input).split('\n').map(string_width_1.default);
    const result = [];
    let startIndex = 0;
    lengths.forEach((length)=>{
        result.push(length === 0 ? '' : (0, slice_ansi_1.default)(input, startIndex, startIndex + length));
        // Plus 1 for the newline character itself
        startIndex += length + 1;
    });
    return result;
};
exports.splitAnsi = splitAnsi;
/**
 * Merges user provided border characters with the default border ("honeywell") characters.
 *
 * @internal
 */ const makeBorderConfig = (border)=>{
    return {
        ...(0, getBorderCharacters_1.getBorderCharacters)('honeywell'),
        ...border
    };
};
exports.makeBorderConfig = makeBorderConfig;
/**
 * Groups the array into sub-arrays by sizes.
 *
 * @internal
 * @example
 * groupBySizes(['a', 'b', 'c', 'd', 'e'], [2, 1, 2]) = [ ['a', 'b'], ['c'], ['d', 'e'] ]
 */ const groupBySizes = (array, sizes)=>{
    let startIndex = 0;
    return sizes.map((size)=>{
        const group = array.slice(startIndex, startIndex + size);
        startIndex += size;
        return group;
    });
};
exports.groupBySizes = groupBySizes;
/**
 * Counts the number of continuous spaces in a string
 *
 * @internal
 * @example
 * countGroupSpaces('a  bc  de f') = 3
 */ const countSpaceSequence = (input)=>{
    var _a, _b;
    return (_b = (_a = input.match(/\s+/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
};
exports.countSpaceSequence = countSpaceSequence;
/**
 * Creates the non-increasing number array given sum and length
 * whose the difference between maximum and minimum is not greater than 1
 *
 * @internal
 * @example
 * distributeUnevenly(6, 3) = [2, 2, 2]
 * distributeUnevenly(8, 3) = [3, 3, 2]
 */ const distributeUnevenly = (sum, length)=>{
    const result = Array.from({
        length
    }).fill(Math.floor(sum / length));
    return result.map((element, index)=>{
        return element + (index < sum % length ? 1 : 0);
    });
};
exports.distributeUnevenly = distributeUnevenly;
const sequence = (start, end)=>{
    return Array.from({
        length: end - start + 1
    }, (_, index)=>{
        return index + start;
    });
};
exports.sequence = sequence;
const sumArray = (array)=>{
    return array.reduce((accumulator, element)=>{
        return accumulator + element;
    }, 0);
};
exports.sumArray = sumArray;
const extractTruncates = (config)=>{
    return config.columns.map(({ truncate })=>{
        return truncate;
    });
};
exports.extractTruncates = extractTruncates;
const flatten = (array)=>{
    return [].concat(...array);
};
exports.flatten = flatten;
const calculateRangeCoordinate = (spanningCellConfig)=>{
    const { row, col, colSpan = 1, rowSpan = 1 } = spanningCellConfig;
    return {
        bottomRight: {
            col: col + colSpan - 1,
            row: row + rowSpan - 1
        },
        topLeft: {
            col,
            row
        }
    };
};
exports.calculateRangeCoordinate = calculateRangeCoordinate;
const areCellEqual = (cell1, cell2)=>{
    return cell1.row === cell2.row && cell1.col === cell2.col;
};
exports.areCellEqual = areCellEqual;
const isCellInRange = (cell, { topLeft, bottomRight })=>{
    return topLeft.row <= cell.row && cell.row <= bottomRight.row && topLeft.col <= cell.col && cell.col <= bottomRight.col;
};
exports.isCellInRange = isCellInRange; //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/table/dist/src/alignString.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.alignString = void 0;
const string_width_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/table/node_modules/string-width/index.js [app-route] (ecmascript)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const alignLeft = (subject, width)=>{
    return subject + ' '.repeat(width);
};
const alignRight = (subject, width)=>{
    return ' '.repeat(width) + subject;
};
const alignCenter = (subject, width)=>{
    return ' '.repeat(Math.floor(width / 2)) + subject + ' '.repeat(Math.ceil(width / 2));
};
const alignJustify = (subject, width)=>{
    const spaceSequenceCount = (0, utils_1.countSpaceSequence)(subject);
    if (spaceSequenceCount === 0) {
        return alignLeft(subject, width);
    }
    const addingSpaces = (0, utils_1.distributeUnevenly)(width, spaceSequenceCount);
    if (Math.max(...addingSpaces) > 3) {
        return alignLeft(subject, width);
    }
    let spaceSequenceIndex = 0;
    return subject.replace(/\s+/g, (groupSpace)=>{
        return groupSpace + ' '.repeat(addingSpaces[spaceSequenceIndex++]);
    });
};
/**
 * Pads a string to the left and/or right to position the subject
 * text in a desired alignment within a container.
 */ const alignString = (subject, containerWidth, alignment)=>{
    const subjectWidth = (0, string_width_1.default)(subject);
    if (subjectWidth === containerWidth) {
        return subject;
    }
    if (subjectWidth > containerWidth) {
        throw new Error('Subject parameter value width cannot be greater than the container width.');
    }
    if (subjectWidth === 0) {
        return ' '.repeat(containerWidth);
    }
    const availableWidth = containerWidth - subjectWidth;
    if (alignment === 'left') {
        return alignLeft(subject, availableWidth);
    }
    if (alignment === 'right') {
        return alignRight(subject, availableWidth);
    }
    if (alignment === 'justify') {
        return alignJustify(subject, availableWidth);
    }
    return alignCenter(subject, availableWidth);
};
exports.alignString = alignString; //# sourceMappingURL=alignString.js.map
}}),
"[project]/node_modules/table/dist/src/alignTableData.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.alignTableData = void 0;
const alignString_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/alignString.js [app-route] (ecmascript)");
const alignTableData = (rows, config)=>{
    return rows.map((row, rowIndex)=>{
        return row.map((cell, cellIndex)=>{
            var _a;
            const { width, alignment } = config.columns[cellIndex];
            const containingRange = (_a = config.spanningCellManager) === null || _a === void 0 ? void 0 : _a.getContainingRange({
                col: cellIndex,
                row: rowIndex
            }, {
                mapped: true
            });
            if (containingRange) {
                return cell;
            }
            return (0, alignString_1.alignString)(cell, width, alignment);
        });
    });
};
exports.alignTableData = alignTableData; //# sourceMappingURL=alignTableData.js.map
}}),
"[project]/node_modules/table/dist/src/wrapString.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapString = void 0;
const slice_ansi_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/slice-ansi/index.js [app-route] (ecmascript)"));
const string_width_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/table/node_modules/string-width/index.js [app-route] (ecmascript)"));
/**
 * Creates an array of strings split into groups the length of size.
 * This function works with strings that contain ASCII characters.
 *
 * wrapText is different from would-be "chunk" implementation
 * in that whitespace characters that occur on a chunk size limit are trimmed.
 *
 */ const wrapString = (subject, size)=>{
    let subjectSlice = subject;
    const chunks = [];
    do {
        chunks.push((0, slice_ansi_1.default)(subjectSlice, 0, size));
        subjectSlice = (0, slice_ansi_1.default)(subjectSlice, size).trim();
    }while ((0, string_width_1.default)(subjectSlice))
    return chunks;
};
exports.wrapString = wrapString; //# sourceMappingURL=wrapString.js.map
}}),
"[project]/node_modules/table/dist/src/wrapWord.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapWord = void 0;
const slice_ansi_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/slice-ansi/index.js [app-route] (ecmascript)"));
const strip_ansi_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/table/node_modules/strip-ansi/index.js [app-route] (ecmascript)"));
const calculateStringLengths = (input, size)=>{
    let subject = (0, strip_ansi_1.default)(input);
    const chunks = [];
    // https://regex101.com/r/gY5kZ1/1
    const re = new RegExp('(^.{1,' + String(Math.max(size, 1)) + '}(\\s+|$))|(^.{1,' + String(Math.max(size - 1, 1)) + '}(\\\\|/|_|\\.|,|;|-))');
    do {
        let chunk;
        const match = re.exec(subject);
        if (match) {
            chunk = match[0];
            subject = subject.slice(chunk.length);
            const trimmedLength = chunk.trim().length;
            const offset = chunk.length - trimmedLength;
            chunks.push([
                trimmedLength,
                offset
            ]);
        } else {
            chunk = subject.slice(0, size);
            subject = subject.slice(size);
            chunks.push([
                chunk.length,
                0
            ]);
        }
    }while (subject.length)
    return chunks;
};
const wrapWord = (input, size)=>{
    const result = [];
    let startIndex = 0;
    calculateStringLengths(input, size).forEach(([length, offset])=>{
        result.push((0, slice_ansi_1.default)(input, startIndex, startIndex + length));
        startIndex += length + offset;
    });
    return result;
};
exports.wrapWord = wrapWord; //# sourceMappingURL=wrapWord.js.map
}}),
"[project]/node_modules/table/dist/src/wrapCell.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapCell = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const wrapString_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/wrapString.js [app-route] (ecmascript)");
const wrapWord_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/wrapWord.js [app-route] (ecmascript)");
/**
 * Wrap a single cell value into a list of lines
 *
 * Always wraps on newlines, for the remainder uses either word or string wrapping
 * depending on user configuration.
 *
 */ const wrapCell = (cellValue, cellWidth, useWrapWord)=>{
    // First split on literal newlines
    const cellLines = (0, utils_1.splitAnsi)(cellValue);
    // Then iterate over the list and word-wrap every remaining line if necessary.
    for(let lineNr = 0; lineNr < cellLines.length;){
        let lineChunks;
        if (useWrapWord) {
            lineChunks = (0, wrapWord_1.wrapWord)(cellLines[lineNr], cellWidth);
        } else {
            lineChunks = (0, wrapString_1.wrapString)(cellLines[lineNr], cellWidth);
        }
        // Replace our original array element with whatever the wrapping returned
        cellLines.splice(lineNr, 1, ...lineChunks);
        lineNr += lineChunks.length;
    }
    return cellLines;
};
exports.wrapCell = wrapCell; //# sourceMappingURL=wrapCell.js.map
}}),
"[project]/node_modules/table/dist/src/calculateCellHeight.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.calculateCellHeight = void 0;
const wrapCell_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/wrapCell.js [app-route] (ecmascript)");
/**
 * Calculates height of cell content in regard to its width and word wrapping.
 */ const calculateCellHeight = (value, columnWidth, useWrapWord = false)=>{
    return (0, wrapCell_1.wrapCell)(value, columnWidth, useWrapWord).length;
};
exports.calculateCellHeight = calculateCellHeight; //# sourceMappingURL=calculateCellHeight.js.map
}}),
"[project]/node_modules/table/dist/src/calculateRowHeights.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.calculateRowHeights = void 0;
const calculateCellHeight_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/calculateCellHeight.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
/**
 * Produces an array of values that describe the largest value length (height) in every row.
 */ const calculateRowHeights = (rows, config)=>{
    const rowHeights = [];
    for (const [rowIndex, row] of rows.entries()){
        let rowHeight = 1;
        row.forEach((cell, cellIndex)=>{
            var _a;
            const containingRange = (_a = config.spanningCellManager) === null || _a === void 0 ? void 0 : _a.getContainingRange({
                col: cellIndex,
                row: rowIndex
            });
            if (!containingRange) {
                const cellHeight = (0, calculateCellHeight_1.calculateCellHeight)(cell, config.columns[cellIndex].width, config.columns[cellIndex].wrapWord);
                rowHeight = Math.max(rowHeight, cellHeight);
                return;
            }
            const { topLeft, bottomRight, height } = containingRange;
            // bottom-most cell of a range needs to contain all remain lines of spanning cells
            if (rowIndex === bottomRight.row) {
                const totalOccupiedSpanningCellHeight = (0, utils_1.sumArray)(rowHeights.slice(topLeft.row));
                const totalHorizontalBorderHeight = bottomRight.row - topLeft.row;
                const totalHiddenHorizontalBorderHeight = (0, utils_1.sequence)(topLeft.row + 1, bottomRight.row).filter((horizontalBorderIndex)=>{
                    var _a;
                    /* istanbul ignore next */ return !((_a = config.drawHorizontalLine) === null || _a === void 0 ? void 0 : _a.call(config, horizontalBorderIndex, rows.length));
                }).length;
                const cellHeight = height - totalOccupiedSpanningCellHeight - totalHorizontalBorderHeight + totalHiddenHorizontalBorderHeight;
                rowHeight = Math.max(rowHeight, cellHeight);
            }
        // otherwise, just depend on other sibling cell heights in the row
        });
        rowHeights.push(rowHeight);
    }
    return rowHeights;
};
exports.calculateRowHeights = calculateRowHeights; //# sourceMappingURL=calculateRowHeights.js.map
}}),
"[project]/node_modules/table/dist/src/drawContent.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.drawContent = void 0;
const drawContent = (parameters)=>{
    const { contents, separatorGetter, drawSeparator, spanningCellManager, rowIndex, elementType } = parameters;
    const contentSize = contents.length;
    const result = [];
    if (drawSeparator(0, contentSize)) {
        result.push(separatorGetter(0, contentSize));
    }
    contents.forEach((content, contentIndex)=>{
        if (!elementType || elementType === 'border' || elementType === 'row') {
            result.push(content);
        }
        if (elementType === 'cell' && rowIndex === undefined) {
            result.push(content);
        }
        if (elementType === 'cell' && rowIndex !== undefined) {
            /* istanbul ignore next */ const containingRange = spanningCellManager === null || spanningCellManager === void 0 ? void 0 : spanningCellManager.getContainingRange({
                col: contentIndex,
                row: rowIndex
            });
            // when drawing content row, just add a cell when it is a normal cell
            // or belongs to first column of spanning cell
            if (!containingRange || contentIndex === containingRange.topLeft.col) {
                result.push(content);
            }
        }
        // Only append the middle separator if the content is not the last
        if (contentIndex + 1 < contentSize && drawSeparator(contentIndex + 1, contentSize)) {
            const separator = separatorGetter(contentIndex + 1, contentSize);
            if (elementType === 'cell' && rowIndex !== undefined) {
                const currentCell = {
                    col: contentIndex + 1,
                    row: rowIndex
                };
                /* istanbul ignore next */ const containingRange = spanningCellManager === null || spanningCellManager === void 0 ? void 0 : spanningCellManager.getContainingRange(currentCell);
                if (!containingRange || containingRange.topLeft.col === currentCell.col) {
                    result.push(separator);
                }
            } else {
                result.push(separator);
            }
        }
    });
    if (drawSeparator(contentSize, contentSize)) {
        result.push(separatorGetter(contentSize, contentSize));
    }
    return result.join('');
};
exports.drawContent = drawContent; //# sourceMappingURL=drawContent.js.map
}}),
"[project]/node_modules/table/dist/src/drawBorder.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createTableBorderGetter = exports.drawBorderBottom = exports.drawBorderJoin = exports.drawBorderTop = exports.drawBorder = exports.createSeparatorGetter = exports.drawBorderSegments = void 0;
const drawContent_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/drawContent.js [app-route] (ecmascript)");
const drawBorderSegments = (columnWidths, parameters)=>{
    const { separator, horizontalBorderIndex, spanningCellManager } = parameters;
    return columnWidths.map((columnWidth, columnIndex)=>{
        const normalSegment = separator.body.repeat(columnWidth);
        if (horizontalBorderIndex === undefined) {
            return normalSegment;
        }
        /* istanbul ignore next */ const range = spanningCellManager === null || spanningCellManager === void 0 ? void 0 : spanningCellManager.getContainingRange({
            col: columnIndex,
            row: horizontalBorderIndex
        });
        if (!range) {
            return normalSegment;
        }
        const { topLeft } = range;
        // draw border segments as usual for top border of spanning cell
        if (horizontalBorderIndex === topLeft.row) {
            return normalSegment;
        }
        // if for first column/row of spanning cell, just skip
        if (columnIndex !== topLeft.col) {
            return '';
        }
        return range.extractBorderContent(horizontalBorderIndex);
    });
};
exports.drawBorderSegments = drawBorderSegments;
const createSeparatorGetter = (dependencies)=>{
    const { separator, spanningCellManager, horizontalBorderIndex, rowCount } = dependencies;
    // eslint-disable-next-line complexity
    return (verticalBorderIndex, columnCount)=>{
        const inSameRange = spanningCellManager === null || spanningCellManager === void 0 ? void 0 : spanningCellManager.inSameRange;
        if (horizontalBorderIndex !== undefined && inSameRange) {
            const topCell = {
                col: verticalBorderIndex,
                row: horizontalBorderIndex - 1
            };
            const leftCell = {
                col: verticalBorderIndex - 1,
                row: horizontalBorderIndex
            };
            const oppositeCell = {
                col: verticalBorderIndex - 1,
                row: horizontalBorderIndex - 1
            };
            const currentCell = {
                col: verticalBorderIndex,
                row: horizontalBorderIndex
            };
            const pairs = [
                [
                    oppositeCell,
                    topCell
                ],
                [
                    topCell,
                    currentCell
                ],
                [
                    currentCell,
                    leftCell
                ],
                [
                    leftCell,
                    oppositeCell
                ]
            ];
            // left side of horizontal border
            if (verticalBorderIndex === 0) {
                if (inSameRange(currentCell, topCell) && separator.bodyJoinOuter) {
                    return separator.bodyJoinOuter;
                }
                return separator.left;
            }
            // right side of horizontal border
            if (verticalBorderIndex === columnCount) {
                if (inSameRange(oppositeCell, leftCell) && separator.bodyJoinOuter) {
                    return separator.bodyJoinOuter;
                }
                return separator.right;
            }
            // top horizontal border
            if (horizontalBorderIndex === 0) {
                if (inSameRange(currentCell, leftCell)) {
                    return separator.body;
                }
                return separator.join;
            }
            // bottom horizontal border
            if (horizontalBorderIndex === rowCount) {
                if (inSameRange(topCell, oppositeCell)) {
                    return separator.body;
                }
                return separator.join;
            }
            const sameRangeCount = pairs.map((pair)=>{
                return inSameRange(...pair);
            }).filter(Boolean).length;
            // four cells are belongs to different spanning cells
            if (sameRangeCount === 0) {
                return separator.join;
            }
            // belong to one spanning cell
            if (sameRangeCount === 4) {
                return '';
            }
            // belongs to two spanning cell
            if (sameRangeCount === 2) {
                if (inSameRange(...pairs[1]) && inSameRange(...pairs[3]) && separator.bodyJoinInner) {
                    return separator.bodyJoinInner;
                }
                return separator.body;
            }
            /* istanbul ignore next */ if (sameRangeCount === 1) {
                if (!separator.joinRight || !separator.joinLeft || !separator.joinUp || !separator.joinDown) {
                    throw new Error(`Can not get border separator for position [${horizontalBorderIndex}, ${verticalBorderIndex}]`);
                }
                if (inSameRange(...pairs[0])) {
                    return separator.joinDown;
                }
                if (inSameRange(...pairs[1])) {
                    return separator.joinLeft;
                }
                if (inSameRange(...pairs[2])) {
                    return separator.joinUp;
                }
                return separator.joinRight;
            }
            /* istanbul ignore next */ throw new Error('Invalid case');
        }
        if (verticalBorderIndex === 0) {
            return separator.left;
        }
        if (verticalBorderIndex === columnCount) {
            return separator.right;
        }
        return separator.join;
    };
};
exports.createSeparatorGetter = createSeparatorGetter;
const drawBorder = (columnWidths, parameters)=>{
    const borderSegments = (0, exports.drawBorderSegments)(columnWidths, parameters);
    const { drawVerticalLine, horizontalBorderIndex, spanningCellManager } = parameters;
    return (0, drawContent_1.drawContent)({
        contents: borderSegments,
        drawSeparator: drawVerticalLine,
        elementType: 'border',
        rowIndex: horizontalBorderIndex,
        separatorGetter: (0, exports.createSeparatorGetter)(parameters),
        spanningCellManager
    }) + '\n';
};
exports.drawBorder = drawBorder;
const drawBorderTop = (columnWidths, parameters)=>{
    const { border } = parameters;
    const result = (0, exports.drawBorder)(columnWidths, {
        ...parameters,
        separator: {
            body: border.topBody,
            join: border.topJoin,
            left: border.topLeft,
            right: border.topRight
        }
    });
    if (result === '\n') {
        return '';
    }
    return result;
};
exports.drawBorderTop = drawBorderTop;
const drawBorderJoin = (columnWidths, parameters)=>{
    const { border } = parameters;
    return (0, exports.drawBorder)(columnWidths, {
        ...parameters,
        separator: {
            body: border.joinBody,
            bodyJoinInner: border.bodyJoin,
            bodyJoinOuter: border.bodyLeft,
            join: border.joinJoin,
            joinDown: border.joinMiddleDown,
            joinLeft: border.joinMiddleLeft,
            joinRight: border.joinMiddleRight,
            joinUp: border.joinMiddleUp,
            left: border.joinLeft,
            right: border.joinRight
        }
    });
};
exports.drawBorderJoin = drawBorderJoin;
const drawBorderBottom = (columnWidths, parameters)=>{
    const { border } = parameters;
    return (0, exports.drawBorder)(columnWidths, {
        ...parameters,
        separator: {
            body: border.bottomBody,
            join: border.bottomJoin,
            left: border.bottomLeft,
            right: border.bottomRight
        }
    });
};
exports.drawBorderBottom = drawBorderBottom;
const createTableBorderGetter = (columnWidths, parameters)=>{
    return (index, size)=>{
        const drawBorderParameters = {
            ...parameters,
            horizontalBorderIndex: index
        };
        if (index === 0) {
            return (0, exports.drawBorderTop)(columnWidths, drawBorderParameters);
        } else if (index === size) {
            return (0, exports.drawBorderBottom)(columnWidths, drawBorderParameters);
        }
        return (0, exports.drawBorderJoin)(columnWidths, drawBorderParameters);
    };
};
exports.createTableBorderGetter = createTableBorderGetter; //# sourceMappingURL=drawBorder.js.map
}}),
"[project]/node_modules/table/dist/src/drawRow.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.drawRow = void 0;
const drawContent_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/drawContent.js [app-route] (ecmascript)");
const drawRow = (row, config)=>{
    const { border, drawVerticalLine, rowIndex, spanningCellManager } = config;
    return (0, drawContent_1.drawContent)({
        contents: row,
        drawSeparator: drawVerticalLine,
        elementType: 'cell',
        rowIndex,
        separatorGetter: (index, columnCount)=>{
            if (index === 0) {
                return border.bodyLeft;
            }
            if (index === columnCount) {
                return border.bodyRight;
            }
            return border.bodyJoin;
        },
        spanningCellManager
    }) + '\n';
};
exports.drawRow = drawRow; //# sourceMappingURL=drawRow.js.map
}}),
"[project]/node_modules/table/dist/src/generated/validators.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
exports["config.json"] = validate43;
const schema13 = {
    "$id": "config.json",
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "properties": {
        "border": {
            "$ref": "shared.json#/definitions/borders"
        },
        "header": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "alignment": {
                    "$ref": "shared.json#/definitions/alignment"
                },
                "wrapWord": {
                    "type": "boolean"
                },
                "truncate": {
                    "type": "integer"
                },
                "paddingLeft": {
                    "type": "integer"
                },
                "paddingRight": {
                    "type": "integer"
                }
            },
            "required": [
                "content"
            ],
            "additionalProperties": false
        },
        "columns": {
            "$ref": "shared.json#/definitions/columns"
        },
        "columnDefault": {
            "$ref": "shared.json#/definitions/column"
        },
        "drawVerticalLine": {
            "typeof": "function"
        },
        "drawHorizontalLine": {
            "typeof": "function"
        },
        "singleLine": {
            "typeof": "boolean"
        },
        "spanningCells": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "col": {
                        "type": "integer",
                        "minimum": 0
                    },
                    "row": {
                        "type": "integer",
                        "minimum": 0
                    },
                    "colSpan": {
                        "type": "integer",
                        "minimum": 1
                    },
                    "rowSpan": {
                        "type": "integer",
                        "minimum": 1
                    },
                    "alignment": {
                        "$ref": "shared.json#/definitions/alignment"
                    },
                    "verticalAlignment": {
                        "$ref": "shared.json#/definitions/verticalAlignment"
                    },
                    "wrapWord": {
                        "type": "boolean"
                    },
                    "truncate": {
                        "type": "integer"
                    },
                    "paddingLeft": {
                        "type": "integer"
                    },
                    "paddingRight": {
                        "type": "integer"
                    }
                },
                "required": [
                    "row",
                    "col"
                ],
                "additionalProperties": false
            }
        }
    },
    "additionalProperties": false
};
const schema15 = {
    "type": "object",
    "properties": {
        "topBody": {
            "$ref": "#/definitions/border"
        },
        "topJoin": {
            "$ref": "#/definitions/border"
        },
        "topLeft": {
            "$ref": "#/definitions/border"
        },
        "topRight": {
            "$ref": "#/definitions/border"
        },
        "bottomBody": {
            "$ref": "#/definitions/border"
        },
        "bottomJoin": {
            "$ref": "#/definitions/border"
        },
        "bottomLeft": {
            "$ref": "#/definitions/border"
        },
        "bottomRight": {
            "$ref": "#/definitions/border"
        },
        "bodyLeft": {
            "$ref": "#/definitions/border"
        },
        "bodyRight": {
            "$ref": "#/definitions/border"
        },
        "bodyJoin": {
            "$ref": "#/definitions/border"
        },
        "headerJoin": {
            "$ref": "#/definitions/border"
        },
        "joinBody": {
            "$ref": "#/definitions/border"
        },
        "joinLeft": {
            "$ref": "#/definitions/border"
        },
        "joinRight": {
            "$ref": "#/definitions/border"
        },
        "joinJoin": {
            "$ref": "#/definitions/border"
        },
        "joinMiddleUp": {
            "$ref": "#/definitions/border"
        },
        "joinMiddleDown": {
            "$ref": "#/definitions/border"
        },
        "joinMiddleLeft": {
            "$ref": "#/definitions/border"
        },
        "joinMiddleRight": {
            "$ref": "#/definitions/border"
        }
    },
    "additionalProperties": false
};
const func8 = Object.prototype.hasOwnProperty;
const schema16 = {
    "type": "string"
};
function validate46(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (typeof data !== "string") {
        const err0 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {
                type: "string"
            },
            message: "must be string"
        };
        if (vErrors === null) {
            vErrors = [
                err0
            ];
        } else {
            vErrors.push(err0);
        }
        errors++;
    }
    validate46.errors = vErrors;
    return errors === 0;
}
function validate45(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (data && typeof data == "object" && !Array.isArray(data)) {
        for(const key0 in data){
            if (!func8.call(schema15.properties, key0)) {
                const err0 = {
                    instancePath,
                    schemaPath: "#/additionalProperties",
                    keyword: "additionalProperties",
                    params: {
                        additionalProperty: key0
                    },
                    message: "must NOT have additional properties"
                };
                if (vErrors === null) {
                    vErrors = [
                        err0
                    ];
                } else {
                    vErrors.push(err0);
                }
                errors++;
            }
        }
        if (data.topBody !== undefined) {
            if (!validate46(data.topBody, {
                instancePath: instancePath + "/topBody",
                parentData: data,
                parentDataProperty: "topBody",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.topJoin !== undefined) {
            if (!validate46(data.topJoin, {
                instancePath: instancePath + "/topJoin",
                parentData: data,
                parentDataProperty: "topJoin",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.topLeft !== undefined) {
            if (!validate46(data.topLeft, {
                instancePath: instancePath + "/topLeft",
                parentData: data,
                parentDataProperty: "topLeft",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.topRight !== undefined) {
            if (!validate46(data.topRight, {
                instancePath: instancePath + "/topRight",
                parentData: data,
                parentDataProperty: "topRight",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bottomBody !== undefined) {
            if (!validate46(data.bottomBody, {
                instancePath: instancePath + "/bottomBody",
                parentData: data,
                parentDataProperty: "bottomBody",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bottomJoin !== undefined) {
            if (!validate46(data.bottomJoin, {
                instancePath: instancePath + "/bottomJoin",
                parentData: data,
                parentDataProperty: "bottomJoin",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bottomLeft !== undefined) {
            if (!validate46(data.bottomLeft, {
                instancePath: instancePath + "/bottomLeft",
                parentData: data,
                parentDataProperty: "bottomLeft",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bottomRight !== undefined) {
            if (!validate46(data.bottomRight, {
                instancePath: instancePath + "/bottomRight",
                parentData: data,
                parentDataProperty: "bottomRight",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bodyLeft !== undefined) {
            if (!validate46(data.bodyLeft, {
                instancePath: instancePath + "/bodyLeft",
                parentData: data,
                parentDataProperty: "bodyLeft",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bodyRight !== undefined) {
            if (!validate46(data.bodyRight, {
                instancePath: instancePath + "/bodyRight",
                parentData: data,
                parentDataProperty: "bodyRight",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bodyJoin !== undefined) {
            if (!validate46(data.bodyJoin, {
                instancePath: instancePath + "/bodyJoin",
                parentData: data,
                parentDataProperty: "bodyJoin",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.headerJoin !== undefined) {
            if (!validate46(data.headerJoin, {
                instancePath: instancePath + "/headerJoin",
                parentData: data,
                parentDataProperty: "headerJoin",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinBody !== undefined) {
            if (!validate46(data.joinBody, {
                instancePath: instancePath + "/joinBody",
                parentData: data,
                parentDataProperty: "joinBody",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinLeft !== undefined) {
            if (!validate46(data.joinLeft, {
                instancePath: instancePath + "/joinLeft",
                parentData: data,
                parentDataProperty: "joinLeft",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinRight !== undefined) {
            if (!validate46(data.joinRight, {
                instancePath: instancePath + "/joinRight",
                parentData: data,
                parentDataProperty: "joinRight",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinJoin !== undefined) {
            if (!validate46(data.joinJoin, {
                instancePath: instancePath + "/joinJoin",
                parentData: data,
                parentDataProperty: "joinJoin",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinMiddleUp !== undefined) {
            if (!validate46(data.joinMiddleUp, {
                instancePath: instancePath + "/joinMiddleUp",
                parentData: data,
                parentDataProperty: "joinMiddleUp",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinMiddleDown !== undefined) {
            if (!validate46(data.joinMiddleDown, {
                instancePath: instancePath + "/joinMiddleDown",
                parentData: data,
                parentDataProperty: "joinMiddleDown",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinMiddleLeft !== undefined) {
            if (!validate46(data.joinMiddleLeft, {
                instancePath: instancePath + "/joinMiddleLeft",
                parentData: data,
                parentDataProperty: "joinMiddleLeft",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinMiddleRight !== undefined) {
            if (!validate46(data.joinMiddleRight, {
                instancePath: instancePath + "/joinMiddleRight",
                parentData: data,
                parentDataProperty: "joinMiddleRight",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
    } else {
        const err1 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {
                type: "object"
            },
            message: "must be object"
        };
        if (vErrors === null) {
            vErrors = [
                err1
            ];
        } else {
            vErrors.push(err1);
        }
        errors++;
    }
    validate45.errors = vErrors;
    return errors === 0;
}
const schema17 = {
    "type": "string",
    "enum": [
        "left",
        "right",
        "center",
        "justify"
    ]
};
const func0 = __turbopack_context__.r("[project]/node_modules/ajv/dist/runtime/equal.js [app-route] (ecmascript)").default;
function validate68(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (typeof data !== "string") {
        const err0 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {
                type: "string"
            },
            message: "must be string"
        };
        if (vErrors === null) {
            vErrors = [
                err0
            ];
        } else {
            vErrors.push(err0);
        }
        errors++;
    }
    if (!(data === "left" || data === "right" || data === "center" || data === "justify")) {
        const err1 = {
            instancePath,
            schemaPath: "#/enum",
            keyword: "enum",
            params: {
                allowedValues: schema17.enum
            },
            message: "must be equal to one of the allowed values"
        };
        if (vErrors === null) {
            vErrors = [
                err1
            ];
        } else {
            vErrors.push(err1);
        }
        errors++;
    }
    validate68.errors = vErrors;
    return errors === 0;
}
const schema18 = {
    "oneOf": [
        {
            "type": "object",
            "patternProperties": {
                "^[0-9]+$": {
                    "$ref": "#/definitions/column"
                }
            },
            "additionalProperties": false
        },
        {
            "type": "array",
            "items": {
                "$ref": "#/definitions/column"
            }
        }
    ]
};
const pattern0 = new RegExp("^[0-9]+$", "u");
const schema19 = {
    "type": "object",
    "properties": {
        "alignment": {
            "$ref": "#/definitions/alignment"
        },
        "verticalAlignment": {
            "$ref": "#/definitions/verticalAlignment"
        },
        "width": {
            "type": "integer",
            "minimum": 1
        },
        "wrapWord": {
            "type": "boolean"
        },
        "truncate": {
            "type": "integer"
        },
        "paddingLeft": {
            "type": "integer"
        },
        "paddingRight": {
            "type": "integer"
        }
    },
    "additionalProperties": false
};
function validate72(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (typeof data !== "string") {
        const err0 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {
                type: "string"
            },
            message: "must be string"
        };
        if (vErrors === null) {
            vErrors = [
                err0
            ];
        } else {
            vErrors.push(err0);
        }
        errors++;
    }
    if (!(data === "left" || data === "right" || data === "center" || data === "justify")) {
        const err1 = {
            instancePath,
            schemaPath: "#/enum",
            keyword: "enum",
            params: {
                allowedValues: schema17.enum
            },
            message: "must be equal to one of the allowed values"
        };
        if (vErrors === null) {
            vErrors = [
                err1
            ];
        } else {
            vErrors.push(err1);
        }
        errors++;
    }
    validate72.errors = vErrors;
    return errors === 0;
}
const schema21 = {
    "type": "string",
    "enum": [
        "top",
        "middle",
        "bottom"
    ]
};
function validate74(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (typeof data !== "string") {
        const err0 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {
                type: "string"
            },
            message: "must be string"
        };
        if (vErrors === null) {
            vErrors = [
                err0
            ];
        } else {
            vErrors.push(err0);
        }
        errors++;
    }
    if (!(data === "top" || data === "middle" || data === "bottom")) {
        const err1 = {
            instancePath,
            schemaPath: "#/enum",
            keyword: "enum",
            params: {
                allowedValues: schema21.enum
            },
            message: "must be equal to one of the allowed values"
        };
        if (vErrors === null) {
            vErrors = [
                err1
            ];
        } else {
            vErrors.push(err1);
        }
        errors++;
    }
    validate74.errors = vErrors;
    return errors === 0;
}
function validate71(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (data && typeof data == "object" && !Array.isArray(data)) {
        for(const key0 in data){
            if (!(key0 === "alignment" || key0 === "verticalAlignment" || key0 === "width" || key0 === "wrapWord" || key0 === "truncate" || key0 === "paddingLeft" || key0 === "paddingRight")) {
                const err0 = {
                    instancePath,
                    schemaPath: "#/additionalProperties",
                    keyword: "additionalProperties",
                    params: {
                        additionalProperty: key0
                    },
                    message: "must NOT have additional properties"
                };
                if (vErrors === null) {
                    vErrors = [
                        err0
                    ];
                } else {
                    vErrors.push(err0);
                }
                errors++;
            }
        }
        if (data.alignment !== undefined) {
            if (!validate72(data.alignment, {
                instancePath: instancePath + "/alignment",
                parentData: data,
                parentDataProperty: "alignment",
                rootData
            })) {
                vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
                errors = vErrors.length;
            }
        }
        if (data.verticalAlignment !== undefined) {
            if (!validate74(data.verticalAlignment, {
                instancePath: instancePath + "/verticalAlignment",
                parentData: data,
                parentDataProperty: "verticalAlignment",
                rootData
            })) {
                vErrors = vErrors === null ? validate74.errors : vErrors.concat(validate74.errors);
                errors = vErrors.length;
            }
        }
        if (data.width !== undefined) {
            let data2 = data.width;
            if (!(typeof data2 == "number" && !(data2 % 1) && !isNaN(data2) && isFinite(data2))) {
                const err1 = {
                    instancePath: instancePath + "/width",
                    schemaPath: "#/properties/width/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err1
                    ];
                } else {
                    vErrors.push(err1);
                }
                errors++;
            }
            if (typeof data2 == "number" && isFinite(data2)) {
                if (data2 < 1 || isNaN(data2)) {
                    const err2 = {
                        instancePath: instancePath + "/width",
                        schemaPath: "#/properties/width/minimum",
                        keyword: "minimum",
                        params: {
                            comparison: ">=",
                            limit: 1
                        },
                        message: "must be >= 1"
                    };
                    if (vErrors === null) {
                        vErrors = [
                            err2
                        ];
                    } else {
                        vErrors.push(err2);
                    }
                    errors++;
                }
            }
        }
        if (data.wrapWord !== undefined) {
            if (typeof data.wrapWord !== "boolean") {
                const err3 = {
                    instancePath: instancePath + "/wrapWord",
                    schemaPath: "#/properties/wrapWord/type",
                    keyword: "type",
                    params: {
                        type: "boolean"
                    },
                    message: "must be boolean"
                };
                if (vErrors === null) {
                    vErrors = [
                        err3
                    ];
                } else {
                    vErrors.push(err3);
                }
                errors++;
            }
        }
        if (data.truncate !== undefined) {
            let data4 = data.truncate;
            if (!(typeof data4 == "number" && !(data4 % 1) && !isNaN(data4) && isFinite(data4))) {
                const err4 = {
                    instancePath: instancePath + "/truncate",
                    schemaPath: "#/properties/truncate/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err4
                    ];
                } else {
                    vErrors.push(err4);
                }
                errors++;
            }
        }
        if (data.paddingLeft !== undefined) {
            let data5 = data.paddingLeft;
            if (!(typeof data5 == "number" && !(data5 % 1) && !isNaN(data5) && isFinite(data5))) {
                const err5 = {
                    instancePath: instancePath + "/paddingLeft",
                    schemaPath: "#/properties/paddingLeft/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err5
                    ];
                } else {
                    vErrors.push(err5);
                }
                errors++;
            }
        }
        if (data.paddingRight !== undefined) {
            let data6 = data.paddingRight;
            if (!(typeof data6 == "number" && !(data6 % 1) && !isNaN(data6) && isFinite(data6))) {
                const err6 = {
                    instancePath: instancePath + "/paddingRight",
                    schemaPath: "#/properties/paddingRight/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err6
                    ];
                } else {
                    vErrors.push(err6);
                }
                errors++;
            }
        }
    } else {
        const err7 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {
                type: "object"
            },
            message: "must be object"
        };
        if (vErrors === null) {
            vErrors = [
                err7
            ];
        } else {
            vErrors.push(err7);
        }
        errors++;
    }
    validate71.errors = vErrors;
    return errors === 0;
}
function validate70(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    const _errs0 = errors;
    let valid0 = false;
    let passing0 = null;
    const _errs1 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
        for(const key0 in data){
            if (!pattern0.test(key0)) {
                const err0 = {
                    instancePath,
                    schemaPath: "#/oneOf/0/additionalProperties",
                    keyword: "additionalProperties",
                    params: {
                        additionalProperty: key0
                    },
                    message: "must NOT have additional properties"
                };
                if (vErrors === null) {
                    vErrors = [
                        err0
                    ];
                } else {
                    vErrors.push(err0);
                }
                errors++;
            }
        }
        for(const key1 in data){
            if (pattern0.test(key1)) {
                if (!validate71(data[key1], {
                    instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),
                    parentData: data,
                    parentDataProperty: key1,
                    rootData
                })) {
                    vErrors = vErrors === null ? validate71.errors : vErrors.concat(validate71.errors);
                    errors = vErrors.length;
                }
            }
        }
    } else {
        const err1 = {
            instancePath,
            schemaPath: "#/oneOf/0/type",
            keyword: "type",
            params: {
                type: "object"
            },
            message: "must be object"
        };
        if (vErrors === null) {
            vErrors = [
                err1
            ];
        } else {
            vErrors.push(err1);
        }
        errors++;
    }
    var _valid0 = _errs1 === errors;
    if (_valid0) {
        valid0 = true;
        passing0 = 0;
    }
    const _errs5 = errors;
    if (Array.isArray(data)) {
        const len0 = data.length;
        for(let i0 = 0; i0 < len0; i0++){
            if (!validate71(data[i0], {
                instancePath: instancePath + "/" + i0,
                parentData: data,
                parentDataProperty: i0,
                rootData
            })) {
                vErrors = vErrors === null ? validate71.errors : vErrors.concat(validate71.errors);
                errors = vErrors.length;
            }
        }
    } else {
        const err2 = {
            instancePath,
            schemaPath: "#/oneOf/1/type",
            keyword: "type",
            params: {
                type: "array"
            },
            message: "must be array"
        };
        if (vErrors === null) {
            vErrors = [
                err2
            ];
        } else {
            vErrors.push(err2);
        }
        errors++;
    }
    var _valid0 = _errs5 === errors;
    if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [
            passing0,
            1
        ];
    } else {
        if (_valid0) {
            valid0 = true;
            passing0 = 1;
        }
    }
    if (!valid0) {
        const err3 = {
            instancePath,
            schemaPath: "#/oneOf",
            keyword: "oneOf",
            params: {
                passingSchemas: passing0
            },
            message: "must match exactly one schema in oneOf"
        };
        if (vErrors === null) {
            vErrors = [
                err3
            ];
        } else {
            vErrors.push(err3);
        }
        errors++;
    } else {
        errors = _errs0;
        if (vErrors !== null) {
            if (_errs0) {
                vErrors.length = _errs0;
            } else {
                vErrors = null;
            }
        }
    }
    validate70.errors = vErrors;
    return errors === 0;
}
function validate79(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (data && typeof data == "object" && !Array.isArray(data)) {
        for(const key0 in data){
            if (!(key0 === "alignment" || key0 === "verticalAlignment" || key0 === "width" || key0 === "wrapWord" || key0 === "truncate" || key0 === "paddingLeft" || key0 === "paddingRight")) {
                const err0 = {
                    instancePath,
                    schemaPath: "#/additionalProperties",
                    keyword: "additionalProperties",
                    params: {
                        additionalProperty: key0
                    },
                    message: "must NOT have additional properties"
                };
                if (vErrors === null) {
                    vErrors = [
                        err0
                    ];
                } else {
                    vErrors.push(err0);
                }
                errors++;
            }
        }
        if (data.alignment !== undefined) {
            if (!validate72(data.alignment, {
                instancePath: instancePath + "/alignment",
                parentData: data,
                parentDataProperty: "alignment",
                rootData
            })) {
                vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
                errors = vErrors.length;
            }
        }
        if (data.verticalAlignment !== undefined) {
            if (!validate74(data.verticalAlignment, {
                instancePath: instancePath + "/verticalAlignment",
                parentData: data,
                parentDataProperty: "verticalAlignment",
                rootData
            })) {
                vErrors = vErrors === null ? validate74.errors : vErrors.concat(validate74.errors);
                errors = vErrors.length;
            }
        }
        if (data.width !== undefined) {
            let data2 = data.width;
            if (!(typeof data2 == "number" && !(data2 % 1) && !isNaN(data2) && isFinite(data2))) {
                const err1 = {
                    instancePath: instancePath + "/width",
                    schemaPath: "#/properties/width/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err1
                    ];
                } else {
                    vErrors.push(err1);
                }
                errors++;
            }
            if (typeof data2 == "number" && isFinite(data2)) {
                if (data2 < 1 || isNaN(data2)) {
                    const err2 = {
                        instancePath: instancePath + "/width",
                        schemaPath: "#/properties/width/minimum",
                        keyword: "minimum",
                        params: {
                            comparison: ">=",
                            limit: 1
                        },
                        message: "must be >= 1"
                    };
                    if (vErrors === null) {
                        vErrors = [
                            err2
                        ];
                    } else {
                        vErrors.push(err2);
                    }
                    errors++;
                }
            }
        }
        if (data.wrapWord !== undefined) {
            if (typeof data.wrapWord !== "boolean") {
                const err3 = {
                    instancePath: instancePath + "/wrapWord",
                    schemaPath: "#/properties/wrapWord/type",
                    keyword: "type",
                    params: {
                        type: "boolean"
                    },
                    message: "must be boolean"
                };
                if (vErrors === null) {
                    vErrors = [
                        err3
                    ];
                } else {
                    vErrors.push(err3);
                }
                errors++;
            }
        }
        if (data.truncate !== undefined) {
            let data4 = data.truncate;
            if (!(typeof data4 == "number" && !(data4 % 1) && !isNaN(data4) && isFinite(data4))) {
                const err4 = {
                    instancePath: instancePath + "/truncate",
                    schemaPath: "#/properties/truncate/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err4
                    ];
                } else {
                    vErrors.push(err4);
                }
                errors++;
            }
        }
        if (data.paddingLeft !== undefined) {
            let data5 = data.paddingLeft;
            if (!(typeof data5 == "number" && !(data5 % 1) && !isNaN(data5) && isFinite(data5))) {
                const err5 = {
                    instancePath: instancePath + "/paddingLeft",
                    schemaPath: "#/properties/paddingLeft/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err5
                    ];
                } else {
                    vErrors.push(err5);
                }
                errors++;
            }
        }
        if (data.paddingRight !== undefined) {
            let data6 = data.paddingRight;
            if (!(typeof data6 == "number" && !(data6 % 1) && !isNaN(data6) && isFinite(data6))) {
                const err6 = {
                    instancePath: instancePath + "/paddingRight",
                    schemaPath: "#/properties/paddingRight/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err6
                    ];
                } else {
                    vErrors.push(err6);
                }
                errors++;
            }
        }
    } else {
        const err7 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {
                type: "object"
            },
            message: "must be object"
        };
        if (vErrors === null) {
            vErrors = [
                err7
            ];
        } else {
            vErrors.push(err7);
        }
        errors++;
    }
    validate79.errors = vErrors;
    return errors === 0;
}
function validate84(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (typeof data !== "string") {
        const err0 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {
                type: "string"
            },
            message: "must be string"
        };
        if (vErrors === null) {
            vErrors = [
                err0
            ];
        } else {
            vErrors.push(err0);
        }
        errors++;
    }
    if (!(data === "top" || data === "middle" || data === "bottom")) {
        const err1 = {
            instancePath,
            schemaPath: "#/enum",
            keyword: "enum",
            params: {
                allowedValues: schema21.enum
            },
            message: "must be equal to one of the allowed values"
        };
        if (vErrors === null) {
            vErrors = [
                err1
            ];
        } else {
            vErrors.push(err1);
        }
        errors++;
    }
    validate84.errors = vErrors;
    return errors === 0;
}
function validate43(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    /*# sourceURL="config.json" */ ;
    let vErrors = null;
    let errors = 0;
    if (data && typeof data == "object" && !Array.isArray(data)) {
        for(const key0 in data){
            if (!(key0 === "border" || key0 === "header" || key0 === "columns" || key0 === "columnDefault" || key0 === "drawVerticalLine" || key0 === "drawHorizontalLine" || key0 === "singleLine" || key0 === "spanningCells")) {
                const err0 = {
                    instancePath,
                    schemaPath: "#/additionalProperties",
                    keyword: "additionalProperties",
                    params: {
                        additionalProperty: key0
                    },
                    message: "must NOT have additional properties"
                };
                if (vErrors === null) {
                    vErrors = [
                        err0
                    ];
                } else {
                    vErrors.push(err0);
                }
                errors++;
            }
        }
        if (data.border !== undefined) {
            if (!validate45(data.border, {
                instancePath: instancePath + "/border",
                parentData: data,
                parentDataProperty: "border",
                rootData
            })) {
                vErrors = vErrors === null ? validate45.errors : vErrors.concat(validate45.errors);
                errors = vErrors.length;
            }
        }
        if (data.header !== undefined) {
            let data1 = data.header;
            if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                if (data1.content === undefined) {
                    const err1 = {
                        instancePath: instancePath + "/header",
                        schemaPath: "#/properties/header/required",
                        keyword: "required",
                        params: {
                            missingProperty: "content"
                        },
                        message: "must have required property '" + "content" + "'"
                    };
                    if (vErrors === null) {
                        vErrors = [
                            err1
                        ];
                    } else {
                        vErrors.push(err1);
                    }
                    errors++;
                }
                for(const key1 in data1){
                    if (!(key1 === "content" || key1 === "alignment" || key1 === "wrapWord" || key1 === "truncate" || key1 === "paddingLeft" || key1 === "paddingRight")) {
                        const err2 = {
                            instancePath: instancePath + "/header",
                            schemaPath: "#/properties/header/additionalProperties",
                            keyword: "additionalProperties",
                            params: {
                                additionalProperty: key1
                            },
                            message: "must NOT have additional properties"
                        };
                        if (vErrors === null) {
                            vErrors = [
                                err2
                            ];
                        } else {
                            vErrors.push(err2);
                        }
                        errors++;
                    }
                }
                if (data1.content !== undefined) {
                    if (typeof data1.content !== "string") {
                        const err3 = {
                            instancePath: instancePath + "/header/content",
                            schemaPath: "#/properties/header/properties/content/type",
                            keyword: "type",
                            params: {
                                type: "string"
                            },
                            message: "must be string"
                        };
                        if (vErrors === null) {
                            vErrors = [
                                err3
                            ];
                        } else {
                            vErrors.push(err3);
                        }
                        errors++;
                    }
                }
                if (data1.alignment !== undefined) {
                    if (!validate68(data1.alignment, {
                        instancePath: instancePath + "/header/alignment",
                        parentData: data1,
                        parentDataProperty: "alignment",
                        rootData
                    })) {
                        vErrors = vErrors === null ? validate68.errors : vErrors.concat(validate68.errors);
                        errors = vErrors.length;
                    }
                }
                if (data1.wrapWord !== undefined) {
                    if (typeof data1.wrapWord !== "boolean") {
                        const err4 = {
                            instancePath: instancePath + "/header/wrapWord",
                            schemaPath: "#/properties/header/properties/wrapWord/type",
                            keyword: "type",
                            params: {
                                type: "boolean"
                            },
                            message: "must be boolean"
                        };
                        if (vErrors === null) {
                            vErrors = [
                                err4
                            ];
                        } else {
                            vErrors.push(err4);
                        }
                        errors++;
                    }
                }
                if (data1.truncate !== undefined) {
                    let data5 = data1.truncate;
                    if (!(typeof data5 == "number" && !(data5 % 1) && !isNaN(data5) && isFinite(data5))) {
                        const err5 = {
                            instancePath: instancePath + "/header/truncate",
                            schemaPath: "#/properties/header/properties/truncate/type",
                            keyword: "type",
                            params: {
                                type: "integer"
                            },
                            message: "must be integer"
                        };
                        if (vErrors === null) {
                            vErrors = [
                                err5
                            ];
                        } else {
                            vErrors.push(err5);
                        }
                        errors++;
                    }
                }
                if (data1.paddingLeft !== undefined) {
                    let data6 = data1.paddingLeft;
                    if (!(typeof data6 == "number" && !(data6 % 1) && !isNaN(data6) && isFinite(data6))) {
                        const err6 = {
                            instancePath: instancePath + "/header/paddingLeft",
                            schemaPath: "#/properties/header/properties/paddingLeft/type",
                            keyword: "type",
                            params: {
                                type: "integer"
                            },
                            message: "must be integer"
                        };
                        if (vErrors === null) {
                            vErrors = [
                                err6
                            ];
                        } else {
                            vErrors.push(err6);
                        }
                        errors++;
                    }
                }
                if (data1.paddingRight !== undefined) {
                    let data7 = data1.paddingRight;
                    if (!(typeof data7 == "number" && !(data7 % 1) && !isNaN(data7) && isFinite(data7))) {
                        const err7 = {
                            instancePath: instancePath + "/header/paddingRight",
                            schemaPath: "#/properties/header/properties/paddingRight/type",
                            keyword: "type",
                            params: {
                                type: "integer"
                            },
                            message: "must be integer"
                        };
                        if (vErrors === null) {
                            vErrors = [
                                err7
                            ];
                        } else {
                            vErrors.push(err7);
                        }
                        errors++;
                    }
                }
            } else {
                const err8 = {
                    instancePath: instancePath + "/header",
                    schemaPath: "#/properties/header/type",
                    keyword: "type",
                    params: {
                        type: "object"
                    },
                    message: "must be object"
                };
                if (vErrors === null) {
                    vErrors = [
                        err8
                    ];
                } else {
                    vErrors.push(err8);
                }
                errors++;
            }
        }
        if (data.columns !== undefined) {
            if (!validate70(data.columns, {
                instancePath: instancePath + "/columns",
                parentData: data,
                parentDataProperty: "columns",
                rootData
            })) {
                vErrors = vErrors === null ? validate70.errors : vErrors.concat(validate70.errors);
                errors = vErrors.length;
            }
        }
        if (data.columnDefault !== undefined) {
            if (!validate79(data.columnDefault, {
                instancePath: instancePath + "/columnDefault",
                parentData: data,
                parentDataProperty: "columnDefault",
                rootData
            })) {
                vErrors = vErrors === null ? validate79.errors : vErrors.concat(validate79.errors);
                errors = vErrors.length;
            }
        }
        if (data.drawVerticalLine !== undefined) {
            if (typeof data.drawVerticalLine != "function") {
                const err9 = {
                    instancePath: instancePath + "/drawVerticalLine",
                    schemaPath: "#/properties/drawVerticalLine/typeof",
                    keyword: "typeof",
                    params: {},
                    message: "must pass \"typeof\" keyword validation"
                };
                if (vErrors === null) {
                    vErrors = [
                        err9
                    ];
                } else {
                    vErrors.push(err9);
                }
                errors++;
            }
        }
        if (data.drawHorizontalLine !== undefined) {
            if (typeof data.drawHorizontalLine != "function") {
                const err10 = {
                    instancePath: instancePath + "/drawHorizontalLine",
                    schemaPath: "#/properties/drawHorizontalLine/typeof",
                    keyword: "typeof",
                    params: {},
                    message: "must pass \"typeof\" keyword validation"
                };
                if (vErrors === null) {
                    vErrors = [
                        err10
                    ];
                } else {
                    vErrors.push(err10);
                }
                errors++;
            }
        }
        if (data.singleLine !== undefined) {
            if (typeof data.singleLine != "boolean") {
                const err11 = {
                    instancePath: instancePath + "/singleLine",
                    schemaPath: "#/properties/singleLine/typeof",
                    keyword: "typeof",
                    params: {},
                    message: "must pass \"typeof\" keyword validation"
                };
                if (vErrors === null) {
                    vErrors = [
                        err11
                    ];
                } else {
                    vErrors.push(err11);
                }
                errors++;
            }
        }
        if (data.spanningCells !== undefined) {
            let data13 = data.spanningCells;
            if (Array.isArray(data13)) {
                const len0 = data13.length;
                for(let i0 = 0; i0 < len0; i0++){
                    let data14 = data13[i0];
                    if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
                        if (data14.row === undefined) {
                            const err12 = {
                                instancePath: instancePath + "/spanningCells/" + i0,
                                schemaPath: "#/properties/spanningCells/items/required",
                                keyword: "required",
                                params: {
                                    missingProperty: "row"
                                },
                                message: "must have required property '" + "row" + "'"
                            };
                            if (vErrors === null) {
                                vErrors = [
                                    err12
                                ];
                            } else {
                                vErrors.push(err12);
                            }
                            errors++;
                        }
                        if (data14.col === undefined) {
                            const err13 = {
                                instancePath: instancePath + "/spanningCells/" + i0,
                                schemaPath: "#/properties/spanningCells/items/required",
                                keyword: "required",
                                params: {
                                    missingProperty: "col"
                                },
                                message: "must have required property '" + "col" + "'"
                            };
                            if (vErrors === null) {
                                vErrors = [
                                    err13
                                ];
                            } else {
                                vErrors.push(err13);
                            }
                            errors++;
                        }
                        for(const key2 in data14){
                            if (!func8.call(schema13.properties.spanningCells.items.properties, key2)) {
                                const err14 = {
                                    instancePath: instancePath + "/spanningCells/" + i0,
                                    schemaPath: "#/properties/spanningCells/items/additionalProperties",
                                    keyword: "additionalProperties",
                                    params: {
                                        additionalProperty: key2
                                    },
                                    message: "must NOT have additional properties"
                                };
                                if (vErrors === null) {
                                    vErrors = [
                                        err14
                                    ];
                                } else {
                                    vErrors.push(err14);
                                }
                                errors++;
                            }
                        }
                        if (data14.col !== undefined) {
                            let data15 = data14.col;
                            if (!(typeof data15 == "number" && !(data15 % 1) && !isNaN(data15) && isFinite(data15))) {
                                const err15 = {
                                    instancePath: instancePath + "/spanningCells/" + i0 + "/col",
                                    schemaPath: "#/properties/spanningCells/items/properties/col/type",
                                    keyword: "type",
                                    params: {
                                        type: "integer"
                                    },
                                    message: "must be integer"
                                };
                                if (vErrors === null) {
                                    vErrors = [
                                        err15
                                    ];
                                } else {
                                    vErrors.push(err15);
                                }
                                errors++;
                            }
                            if (typeof data15 == "number" && isFinite(data15)) {
                                if (data15 < 0 || isNaN(data15)) {
                                    const err16 = {
                                        instancePath: instancePath + "/spanningCells/" + i0 + "/col",
                                        schemaPath: "#/properties/spanningCells/items/properties/col/minimum",
                                        keyword: "minimum",
                                        params: {
                                            comparison: ">=",
                                            limit: 0
                                        },
                                        message: "must be >= 0"
                                    };
                                    if (vErrors === null) {
                                        vErrors = [
                                            err16
                                        ];
                                    } else {
                                        vErrors.push(err16);
                                    }
                                    errors++;
                                }
                            }
                        }
                        if (data14.row !== undefined) {
                            let data16 = data14.row;
                            if (!(typeof data16 == "number" && !(data16 % 1) && !isNaN(data16) && isFinite(data16))) {
                                const err17 = {
                                    instancePath: instancePath + "/spanningCells/" + i0 + "/row",
                                    schemaPath: "#/properties/spanningCells/items/properties/row/type",
                                    keyword: "type",
                                    params: {
                                        type: "integer"
                                    },
                                    message: "must be integer"
                                };
                                if (vErrors === null) {
                                    vErrors = [
                                        err17
                                    ];
                                } else {
                                    vErrors.push(err17);
                                }
                                errors++;
                            }
                            if (typeof data16 == "number" && isFinite(data16)) {
                                if (data16 < 0 || isNaN(data16)) {
                                    const err18 = {
                                        instancePath: instancePath + "/spanningCells/" + i0 + "/row",
                                        schemaPath: "#/properties/spanningCells/items/properties/row/minimum",
                                        keyword: "minimum",
                                        params: {
                                            comparison: ">=",
                                            limit: 0
                                        },
                                        message: "must be >= 0"
                                    };
                                    if (vErrors === null) {
                                        vErrors = [
                                            err18
                                        ];
                                    } else {
                                        vErrors.push(err18);
                                    }
                                    errors++;
                                }
                            }
                        }
                        if (data14.colSpan !== undefined) {
                            let data17 = data14.colSpan;
                            if (!(typeof data17 == "number" && !(data17 % 1) && !isNaN(data17) && isFinite(data17))) {
                                const err19 = {
                                    instancePath: instancePath + "/spanningCells/" + i0 + "/colSpan",
                                    schemaPath: "#/properties/spanningCells/items/properties/colSpan/type",
                                    keyword: "type",
                                    params: {
                                        type: "integer"
                                    },
                                    message: "must be integer"
                                };
                                if (vErrors === null) {
                                    vErrors = [
                                        err19
                                    ];
                                } else {
                                    vErrors.push(err19);
                                }
                                errors++;
                            }
                            if (typeof data17 == "number" && isFinite(data17)) {
                                if (data17 < 1 || isNaN(data17)) {
                                    const err20 = {
                                        instancePath: instancePath + "/spanningCells/" + i0 + "/colSpan",
                                        schemaPath: "#/properties/spanningCells/items/properties/colSpan/minimum",
                                        keyword: "minimum",
                                        params: {
                                            comparison: ">=",
                                            limit: 1
                                        },
                                        message: "must be >= 1"
                                    };
                                    if (vErrors === null) {
                                        vErrors = [
                                            err20
                                        ];
                                    } else {
                                        vErrors.push(err20);
                                    }
                                    errors++;
                                }
                            }
                        }
                        if (data14.rowSpan !== undefined) {
                            let data18 = data14.rowSpan;
                            if (!(typeof data18 == "number" && !(data18 % 1) && !isNaN(data18) && isFinite(data18))) {
                                const err21 = {
                                    instancePath: instancePath + "/spanningCells/" + i0 + "/rowSpan",
                                    schemaPath: "#/properties/spanningCells/items/properties/rowSpan/type",
                                    keyword: "type",
                                    params: {
                                        type: "integer"
                                    },
                                    message: "must be integer"
                                };
                                if (vErrors === null) {
                                    vErrors = [
                                        err21
                                    ];
                                } else {
                                    vErrors.push(err21);
                                }
                                errors++;
                            }
                            if (typeof data18 == "number" && isFinite(data18)) {
                                if (data18 < 1 || isNaN(data18)) {
                                    const err22 = {
                                        instancePath: instancePath + "/spanningCells/" + i0 + "/rowSpan",
                                        schemaPath: "#/properties/spanningCells/items/properties/rowSpan/minimum",
                                        keyword: "minimum",
                                        params: {
                                            comparison: ">=",
                                            limit: 1
                                        },
                                        message: "must be >= 1"
                                    };
                                    if (vErrors === null) {
                                        vErrors = [
                                            err22
                                        ];
                                    } else {
                                        vErrors.push(err22);
                                    }
                                    errors++;
                                }
                            }
                        }
                        if (data14.alignment !== undefined) {
                            if (!validate68(data14.alignment, {
                                instancePath: instancePath + "/spanningCells/" + i0 + "/alignment",
                                parentData: data14,
                                parentDataProperty: "alignment",
                                rootData
                            })) {
                                vErrors = vErrors === null ? validate68.errors : vErrors.concat(validate68.errors);
                                errors = vErrors.length;
                            }
                        }
                        if (data14.verticalAlignment !== undefined) {
                            if (!validate84(data14.verticalAlignment, {
                                instancePath: instancePath + "/spanningCells/" + i0 + "/verticalAlignment",
                                parentData: data14,
                                parentDataProperty: "verticalAlignment",
                                rootData
                            })) {
                                vErrors = vErrors === null ? validate84.errors : vErrors.concat(validate84.errors);
                                errors = vErrors.length;
                            }
                        }
                        if (data14.wrapWord !== undefined) {
                            if (typeof data14.wrapWord !== "boolean") {
                                const err23 = {
                                    instancePath: instancePath + "/spanningCells/" + i0 + "/wrapWord",
                                    schemaPath: "#/properties/spanningCells/items/properties/wrapWord/type",
                                    keyword: "type",
                                    params: {
                                        type: "boolean"
                                    },
                                    message: "must be boolean"
                                };
                                if (vErrors === null) {
                                    vErrors = [
                                        err23
                                    ];
                                } else {
                                    vErrors.push(err23);
                                }
                                errors++;
                            }
                        }
                        if (data14.truncate !== undefined) {
                            let data22 = data14.truncate;
                            if (!(typeof data22 == "number" && !(data22 % 1) && !isNaN(data22) && isFinite(data22))) {
                                const err24 = {
                                    instancePath: instancePath + "/spanningCells/" + i0 + "/truncate",
                                    schemaPath: "#/properties/spanningCells/items/properties/truncate/type",
                                    keyword: "type",
                                    params: {
                                        type: "integer"
                                    },
                                    message: "must be integer"
                                };
                                if (vErrors === null) {
                                    vErrors = [
                                        err24
                                    ];
                                } else {
                                    vErrors.push(err24);
                                }
                                errors++;
                            }
                        }
                        if (data14.paddingLeft !== undefined) {
                            let data23 = data14.paddingLeft;
                            if (!(typeof data23 == "number" && !(data23 % 1) && !isNaN(data23) && isFinite(data23))) {
                                const err25 = {
                                    instancePath: instancePath + "/spanningCells/" + i0 + "/paddingLeft",
                                    schemaPath: "#/properties/spanningCells/items/properties/paddingLeft/type",
                                    keyword: "type",
                                    params: {
                                        type: "integer"
                                    },
                                    message: "must be integer"
                                };
                                if (vErrors === null) {
                                    vErrors = [
                                        err25
                                    ];
                                } else {
                                    vErrors.push(err25);
                                }
                                errors++;
                            }
                        }
                        if (data14.paddingRight !== undefined) {
                            let data24 = data14.paddingRight;
                            if (!(typeof data24 == "number" && !(data24 % 1) && !isNaN(data24) && isFinite(data24))) {
                                const err26 = {
                                    instancePath: instancePath + "/spanningCells/" + i0 + "/paddingRight",
                                    schemaPath: "#/properties/spanningCells/items/properties/paddingRight/type",
                                    keyword: "type",
                                    params: {
                                        type: "integer"
                                    },
                                    message: "must be integer"
                                };
                                if (vErrors === null) {
                                    vErrors = [
                                        err26
                                    ];
                                } else {
                                    vErrors.push(err26);
                                }
                                errors++;
                            }
                        }
                    } else {
                        const err27 = {
                            instancePath: instancePath + "/spanningCells/" + i0,
                            schemaPath: "#/properties/spanningCells/items/type",
                            keyword: "type",
                            params: {
                                type: "object"
                            },
                            message: "must be object"
                        };
                        if (vErrors === null) {
                            vErrors = [
                                err27
                            ];
                        } else {
                            vErrors.push(err27);
                        }
                        errors++;
                    }
                }
            } else {
                const err28 = {
                    instancePath: instancePath + "/spanningCells",
                    schemaPath: "#/properties/spanningCells/type",
                    keyword: "type",
                    params: {
                        type: "array"
                    },
                    message: "must be array"
                };
                if (vErrors === null) {
                    vErrors = [
                        err28
                    ];
                } else {
                    vErrors.push(err28);
                }
                errors++;
            }
        }
    } else {
        const err29 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {
                type: "object"
            },
            message: "must be object"
        };
        if (vErrors === null) {
            vErrors = [
                err29
            ];
        } else {
            vErrors.push(err29);
        }
        errors++;
    }
    validate43.errors = vErrors;
    return errors === 0;
}
exports["streamConfig.json"] = validate86;
const schema24 = {
    "$id": "streamConfig.json",
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "properties": {
        "border": {
            "$ref": "shared.json#/definitions/borders"
        },
        "columns": {
            "$ref": "shared.json#/definitions/columns"
        },
        "columnDefault": {
            "$ref": "shared.json#/definitions/column"
        },
        "columnCount": {
            "type": "integer",
            "minimum": 1
        },
        "drawVerticalLine": {
            "typeof": "function"
        }
    },
    "required": [
        "columnDefault",
        "columnCount"
    ],
    "additionalProperties": false
};
function validate87(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (data && typeof data == "object" && !Array.isArray(data)) {
        for(const key0 in data){
            if (!func8.call(schema15.properties, key0)) {
                const err0 = {
                    instancePath,
                    schemaPath: "#/additionalProperties",
                    keyword: "additionalProperties",
                    params: {
                        additionalProperty: key0
                    },
                    message: "must NOT have additional properties"
                };
                if (vErrors === null) {
                    vErrors = [
                        err0
                    ];
                } else {
                    vErrors.push(err0);
                }
                errors++;
            }
        }
        if (data.topBody !== undefined) {
            if (!validate46(data.topBody, {
                instancePath: instancePath + "/topBody",
                parentData: data,
                parentDataProperty: "topBody",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.topJoin !== undefined) {
            if (!validate46(data.topJoin, {
                instancePath: instancePath + "/topJoin",
                parentData: data,
                parentDataProperty: "topJoin",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.topLeft !== undefined) {
            if (!validate46(data.topLeft, {
                instancePath: instancePath + "/topLeft",
                parentData: data,
                parentDataProperty: "topLeft",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.topRight !== undefined) {
            if (!validate46(data.topRight, {
                instancePath: instancePath + "/topRight",
                parentData: data,
                parentDataProperty: "topRight",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bottomBody !== undefined) {
            if (!validate46(data.bottomBody, {
                instancePath: instancePath + "/bottomBody",
                parentData: data,
                parentDataProperty: "bottomBody",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bottomJoin !== undefined) {
            if (!validate46(data.bottomJoin, {
                instancePath: instancePath + "/bottomJoin",
                parentData: data,
                parentDataProperty: "bottomJoin",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bottomLeft !== undefined) {
            if (!validate46(data.bottomLeft, {
                instancePath: instancePath + "/bottomLeft",
                parentData: data,
                parentDataProperty: "bottomLeft",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bottomRight !== undefined) {
            if (!validate46(data.bottomRight, {
                instancePath: instancePath + "/bottomRight",
                parentData: data,
                parentDataProperty: "bottomRight",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bodyLeft !== undefined) {
            if (!validate46(data.bodyLeft, {
                instancePath: instancePath + "/bodyLeft",
                parentData: data,
                parentDataProperty: "bodyLeft",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bodyRight !== undefined) {
            if (!validate46(data.bodyRight, {
                instancePath: instancePath + "/bodyRight",
                parentData: data,
                parentDataProperty: "bodyRight",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.bodyJoin !== undefined) {
            if (!validate46(data.bodyJoin, {
                instancePath: instancePath + "/bodyJoin",
                parentData: data,
                parentDataProperty: "bodyJoin",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.headerJoin !== undefined) {
            if (!validate46(data.headerJoin, {
                instancePath: instancePath + "/headerJoin",
                parentData: data,
                parentDataProperty: "headerJoin",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinBody !== undefined) {
            if (!validate46(data.joinBody, {
                instancePath: instancePath + "/joinBody",
                parentData: data,
                parentDataProperty: "joinBody",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinLeft !== undefined) {
            if (!validate46(data.joinLeft, {
                instancePath: instancePath + "/joinLeft",
                parentData: data,
                parentDataProperty: "joinLeft",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinRight !== undefined) {
            if (!validate46(data.joinRight, {
                instancePath: instancePath + "/joinRight",
                parentData: data,
                parentDataProperty: "joinRight",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinJoin !== undefined) {
            if (!validate46(data.joinJoin, {
                instancePath: instancePath + "/joinJoin",
                parentData: data,
                parentDataProperty: "joinJoin",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinMiddleUp !== undefined) {
            if (!validate46(data.joinMiddleUp, {
                instancePath: instancePath + "/joinMiddleUp",
                parentData: data,
                parentDataProperty: "joinMiddleUp",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinMiddleDown !== undefined) {
            if (!validate46(data.joinMiddleDown, {
                instancePath: instancePath + "/joinMiddleDown",
                parentData: data,
                parentDataProperty: "joinMiddleDown",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinMiddleLeft !== undefined) {
            if (!validate46(data.joinMiddleLeft, {
                instancePath: instancePath + "/joinMiddleLeft",
                parentData: data,
                parentDataProperty: "joinMiddleLeft",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
        if (data.joinMiddleRight !== undefined) {
            if (!validate46(data.joinMiddleRight, {
                instancePath: instancePath + "/joinMiddleRight",
                parentData: data,
                parentDataProperty: "joinMiddleRight",
                rootData
            })) {
                vErrors = vErrors === null ? validate46.errors : vErrors.concat(validate46.errors);
                errors = vErrors.length;
            }
        }
    } else {
        const err1 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {
                type: "object"
            },
            message: "must be object"
        };
        if (vErrors === null) {
            vErrors = [
                err1
            ];
        } else {
            vErrors.push(err1);
        }
        errors++;
    }
    validate87.errors = vErrors;
    return errors === 0;
}
function validate109(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    const _errs0 = errors;
    let valid0 = false;
    let passing0 = null;
    const _errs1 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
        for(const key0 in data){
            if (!pattern0.test(key0)) {
                const err0 = {
                    instancePath,
                    schemaPath: "#/oneOf/0/additionalProperties",
                    keyword: "additionalProperties",
                    params: {
                        additionalProperty: key0
                    },
                    message: "must NOT have additional properties"
                };
                if (vErrors === null) {
                    vErrors = [
                        err0
                    ];
                } else {
                    vErrors.push(err0);
                }
                errors++;
            }
        }
        for(const key1 in data){
            if (pattern0.test(key1)) {
                if (!validate71(data[key1], {
                    instancePath: instancePath + "/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),
                    parentData: data,
                    parentDataProperty: key1,
                    rootData
                })) {
                    vErrors = vErrors === null ? validate71.errors : vErrors.concat(validate71.errors);
                    errors = vErrors.length;
                }
            }
        }
    } else {
        const err1 = {
            instancePath,
            schemaPath: "#/oneOf/0/type",
            keyword: "type",
            params: {
                type: "object"
            },
            message: "must be object"
        };
        if (vErrors === null) {
            vErrors = [
                err1
            ];
        } else {
            vErrors.push(err1);
        }
        errors++;
    }
    var _valid0 = _errs1 === errors;
    if (_valid0) {
        valid0 = true;
        passing0 = 0;
    }
    const _errs5 = errors;
    if (Array.isArray(data)) {
        const len0 = data.length;
        for(let i0 = 0; i0 < len0; i0++){
            if (!validate71(data[i0], {
                instancePath: instancePath + "/" + i0,
                parentData: data,
                parentDataProperty: i0,
                rootData
            })) {
                vErrors = vErrors === null ? validate71.errors : vErrors.concat(validate71.errors);
                errors = vErrors.length;
            }
        }
    } else {
        const err2 = {
            instancePath,
            schemaPath: "#/oneOf/1/type",
            keyword: "type",
            params: {
                type: "array"
            },
            message: "must be array"
        };
        if (vErrors === null) {
            vErrors = [
                err2
            ];
        } else {
            vErrors.push(err2);
        }
        errors++;
    }
    var _valid0 = _errs5 === errors;
    if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [
            passing0,
            1
        ];
    } else {
        if (_valid0) {
            valid0 = true;
            passing0 = 1;
        }
    }
    if (!valid0) {
        const err3 = {
            instancePath,
            schemaPath: "#/oneOf",
            keyword: "oneOf",
            params: {
                passingSchemas: passing0
            },
            message: "must match exactly one schema in oneOf"
        };
        if (vErrors === null) {
            vErrors = [
                err3
            ];
        } else {
            vErrors.push(err3);
        }
        errors++;
    } else {
        errors = _errs0;
        if (vErrors !== null) {
            if (_errs0) {
                vErrors.length = _errs0;
            } else {
                vErrors = null;
            }
        }
    }
    validate109.errors = vErrors;
    return errors === 0;
}
function validate113(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (data && typeof data == "object" && !Array.isArray(data)) {
        for(const key0 in data){
            if (!(key0 === "alignment" || key0 === "verticalAlignment" || key0 === "width" || key0 === "wrapWord" || key0 === "truncate" || key0 === "paddingLeft" || key0 === "paddingRight")) {
                const err0 = {
                    instancePath,
                    schemaPath: "#/additionalProperties",
                    keyword: "additionalProperties",
                    params: {
                        additionalProperty: key0
                    },
                    message: "must NOT have additional properties"
                };
                if (vErrors === null) {
                    vErrors = [
                        err0
                    ];
                } else {
                    vErrors.push(err0);
                }
                errors++;
            }
        }
        if (data.alignment !== undefined) {
            if (!validate72(data.alignment, {
                instancePath: instancePath + "/alignment",
                parentData: data,
                parentDataProperty: "alignment",
                rootData
            })) {
                vErrors = vErrors === null ? validate72.errors : vErrors.concat(validate72.errors);
                errors = vErrors.length;
            }
        }
        if (data.verticalAlignment !== undefined) {
            if (!validate74(data.verticalAlignment, {
                instancePath: instancePath + "/verticalAlignment",
                parentData: data,
                parentDataProperty: "verticalAlignment",
                rootData
            })) {
                vErrors = vErrors === null ? validate74.errors : vErrors.concat(validate74.errors);
                errors = vErrors.length;
            }
        }
        if (data.width !== undefined) {
            let data2 = data.width;
            if (!(typeof data2 == "number" && !(data2 % 1) && !isNaN(data2) && isFinite(data2))) {
                const err1 = {
                    instancePath: instancePath + "/width",
                    schemaPath: "#/properties/width/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err1
                    ];
                } else {
                    vErrors.push(err1);
                }
                errors++;
            }
            if (typeof data2 == "number" && isFinite(data2)) {
                if (data2 < 1 || isNaN(data2)) {
                    const err2 = {
                        instancePath: instancePath + "/width",
                        schemaPath: "#/properties/width/minimum",
                        keyword: "minimum",
                        params: {
                            comparison: ">=",
                            limit: 1
                        },
                        message: "must be >= 1"
                    };
                    if (vErrors === null) {
                        vErrors = [
                            err2
                        ];
                    } else {
                        vErrors.push(err2);
                    }
                    errors++;
                }
            }
        }
        if (data.wrapWord !== undefined) {
            if (typeof data.wrapWord !== "boolean") {
                const err3 = {
                    instancePath: instancePath + "/wrapWord",
                    schemaPath: "#/properties/wrapWord/type",
                    keyword: "type",
                    params: {
                        type: "boolean"
                    },
                    message: "must be boolean"
                };
                if (vErrors === null) {
                    vErrors = [
                        err3
                    ];
                } else {
                    vErrors.push(err3);
                }
                errors++;
            }
        }
        if (data.truncate !== undefined) {
            let data4 = data.truncate;
            if (!(typeof data4 == "number" && !(data4 % 1) && !isNaN(data4) && isFinite(data4))) {
                const err4 = {
                    instancePath: instancePath + "/truncate",
                    schemaPath: "#/properties/truncate/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err4
                    ];
                } else {
                    vErrors.push(err4);
                }
                errors++;
            }
        }
        if (data.paddingLeft !== undefined) {
            let data5 = data.paddingLeft;
            if (!(typeof data5 == "number" && !(data5 % 1) && !isNaN(data5) && isFinite(data5))) {
                const err5 = {
                    instancePath: instancePath + "/paddingLeft",
                    schemaPath: "#/properties/paddingLeft/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err5
                    ];
                } else {
                    vErrors.push(err5);
                }
                errors++;
            }
        }
        if (data.paddingRight !== undefined) {
            let data6 = data.paddingRight;
            if (!(typeof data6 == "number" && !(data6 % 1) && !isNaN(data6) && isFinite(data6))) {
                const err6 = {
                    instancePath: instancePath + "/paddingRight",
                    schemaPath: "#/properties/paddingRight/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err6
                    ];
                } else {
                    vErrors.push(err6);
                }
                errors++;
            }
        }
    } else {
        const err7 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {
                type: "object"
            },
            message: "must be object"
        };
        if (vErrors === null) {
            vErrors = [
                err7
            ];
        } else {
            vErrors.push(err7);
        }
        errors++;
    }
    validate113.errors = vErrors;
    return errors === 0;
}
function validate86(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    /*# sourceURL="streamConfig.json" */ ;
    let vErrors = null;
    let errors = 0;
    if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.columnDefault === undefined) {
            const err0 = {
                instancePath,
                schemaPath: "#/required",
                keyword: "required",
                params: {
                    missingProperty: "columnDefault"
                },
                message: "must have required property '" + "columnDefault" + "'"
            };
            if (vErrors === null) {
                vErrors = [
                    err0
                ];
            } else {
                vErrors.push(err0);
            }
            errors++;
        }
        if (data.columnCount === undefined) {
            const err1 = {
                instancePath,
                schemaPath: "#/required",
                keyword: "required",
                params: {
                    missingProperty: "columnCount"
                },
                message: "must have required property '" + "columnCount" + "'"
            };
            if (vErrors === null) {
                vErrors = [
                    err1
                ];
            } else {
                vErrors.push(err1);
            }
            errors++;
        }
        for(const key0 in data){
            if (!(key0 === "border" || key0 === "columns" || key0 === "columnDefault" || key0 === "columnCount" || key0 === "drawVerticalLine")) {
                const err2 = {
                    instancePath,
                    schemaPath: "#/additionalProperties",
                    keyword: "additionalProperties",
                    params: {
                        additionalProperty: key0
                    },
                    message: "must NOT have additional properties"
                };
                if (vErrors === null) {
                    vErrors = [
                        err2
                    ];
                } else {
                    vErrors.push(err2);
                }
                errors++;
            }
        }
        if (data.border !== undefined) {
            if (!validate87(data.border, {
                instancePath: instancePath + "/border",
                parentData: data,
                parentDataProperty: "border",
                rootData
            })) {
                vErrors = vErrors === null ? validate87.errors : vErrors.concat(validate87.errors);
                errors = vErrors.length;
            }
        }
        if (data.columns !== undefined) {
            if (!validate109(data.columns, {
                instancePath: instancePath + "/columns",
                parentData: data,
                parentDataProperty: "columns",
                rootData
            })) {
                vErrors = vErrors === null ? validate109.errors : vErrors.concat(validate109.errors);
                errors = vErrors.length;
            }
        }
        if (data.columnDefault !== undefined) {
            if (!validate113(data.columnDefault, {
                instancePath: instancePath + "/columnDefault",
                parentData: data,
                parentDataProperty: "columnDefault",
                rootData
            })) {
                vErrors = vErrors === null ? validate113.errors : vErrors.concat(validate113.errors);
                errors = vErrors.length;
            }
        }
        if (data.columnCount !== undefined) {
            let data3 = data.columnCount;
            if (!(typeof data3 == "number" && !(data3 % 1) && !isNaN(data3) && isFinite(data3))) {
                const err3 = {
                    instancePath: instancePath + "/columnCount",
                    schemaPath: "#/properties/columnCount/type",
                    keyword: "type",
                    params: {
                        type: "integer"
                    },
                    message: "must be integer"
                };
                if (vErrors === null) {
                    vErrors = [
                        err3
                    ];
                } else {
                    vErrors.push(err3);
                }
                errors++;
            }
            if (typeof data3 == "number" && isFinite(data3)) {
                if (data3 < 1 || isNaN(data3)) {
                    const err4 = {
                        instancePath: instancePath + "/columnCount",
                        schemaPath: "#/properties/columnCount/minimum",
                        keyword: "minimum",
                        params: {
                            comparison: ">=",
                            limit: 1
                        },
                        message: "must be >= 1"
                    };
                    if (vErrors === null) {
                        vErrors = [
                            err4
                        ];
                    } else {
                        vErrors.push(err4);
                    }
                    errors++;
                }
            }
        }
        if (data.drawVerticalLine !== undefined) {
            if (typeof data.drawVerticalLine != "function") {
                const err5 = {
                    instancePath: instancePath + "/drawVerticalLine",
                    schemaPath: "#/properties/drawVerticalLine/typeof",
                    keyword: "typeof",
                    params: {},
                    message: "must pass \"typeof\" keyword validation"
                };
                if (vErrors === null) {
                    vErrors = [
                        err5
                    ];
                } else {
                    vErrors.push(err5);
                }
                errors++;
            }
        }
    } else {
        const err6 = {
            instancePath,
            schemaPath: "#/type",
            keyword: "type",
            params: {
                type: "object"
            },
            message: "must be object"
        };
        if (vErrors === null) {
            vErrors = [
                err6
            ];
        } else {
            vErrors.push(err6);
        }
        errors++;
    }
    validate86.errors = vErrors;
    return errors === 0;
} //# sourceMappingURL=validators.js.map
}}),
"[project]/node_modules/table/dist/src/validateConfig.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateConfig = void 0;
const validators_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/table/dist/src/generated/validators.js [app-route] (ecmascript)"));
const validateConfig = (schemaId, config)=>{
    const validate = validators_1.default[schemaId];
    if (!validate(config) && validate.errors) {
        // eslint-disable-next-line promise/prefer-await-to-callbacks
        const errors = validate.errors.map((error)=>{
            return {
                message: error.message,
                params: error.params,
                schemaPath: error.schemaPath
            };
        });
        /* eslint-disable no-console */ console.log('config', config);
        console.log('errors', errors);
        /* eslint-enable no-console */ throw new Error('Invalid config.');
    }
};
exports.validateConfig = validateConfig; //# sourceMappingURL=validateConfig.js.map
}}),
"[project]/node_modules/table/dist/src/makeStreamConfig.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeStreamConfig = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const validateConfig_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/validateConfig.js [app-route] (ecmascript)");
/**
 * Creates a configuration for every column using default
 * values for the missing configuration properties.
 */ const makeColumnsConfig = (columnCount, columns = {}, columnDefault)=>{
    return Array.from({
        length: columnCount
    }).map((_, index)=>{
        return {
            alignment: 'left',
            paddingLeft: 1,
            paddingRight: 1,
            truncate: Number.POSITIVE_INFINITY,
            verticalAlignment: 'top',
            wrapWord: false,
            ...columnDefault,
            ...columns[index]
        };
    });
};
/**
 * Makes a new configuration object out of the userConfig object
 * using default values for the missing configuration properties.
 */ const makeStreamConfig = (config)=>{
    (0, validateConfig_1.validateConfig)('streamConfig.json', config);
    if (config.columnDefault.width === undefined) {
        throw new Error('Must provide config.columnDefault.width when creating a stream.');
    }
    return {
        drawVerticalLine: ()=>{
            return true;
        },
        ...config,
        border: (0, utils_1.makeBorderConfig)(config.border),
        columns: makeColumnsConfig(config.columnCount, config.columns, config.columnDefault)
    };
};
exports.makeStreamConfig = makeStreamConfig; //# sourceMappingURL=makeStreamConfig.js.map
}}),
"[project]/node_modules/table/dist/src/mapDataUsingRowHeights.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mapDataUsingRowHeights = exports.padCellVertically = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const wrapCell_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/wrapCell.js [app-route] (ecmascript)");
const createEmptyStrings = (length)=>{
    return new Array(length).fill('');
};
const padCellVertically = (lines, rowHeight, verticalAlignment)=>{
    const availableLines = rowHeight - lines.length;
    if (verticalAlignment === 'top') {
        return [
            ...lines,
            ...createEmptyStrings(availableLines)
        ];
    }
    if (verticalAlignment === 'bottom') {
        return [
            ...createEmptyStrings(availableLines),
            ...lines
        ];
    }
    return [
        ...createEmptyStrings(Math.floor(availableLines / 2)),
        ...lines,
        ...createEmptyStrings(Math.ceil(availableLines / 2))
    ];
};
exports.padCellVertically = padCellVertically;
const mapDataUsingRowHeights = (unmappedRows, rowHeights, config)=>{
    const nColumns = unmappedRows[0].length;
    const mappedRows = unmappedRows.map((unmappedRow, unmappedRowIndex)=>{
        const outputRowHeight = rowHeights[unmappedRowIndex];
        const outputRow = Array.from({
            length: outputRowHeight
        }, ()=>{
            return new Array(nColumns).fill('');
        });
        unmappedRow.forEach((cell, cellIndex)=>{
            var _a;
            const containingRange = (_a = config.spanningCellManager) === null || _a === void 0 ? void 0 : _a.getContainingRange({
                col: cellIndex,
                row: unmappedRowIndex
            });
            if (containingRange) {
                containingRange.extractCellContent(unmappedRowIndex).forEach((cellLine, cellLineIndex)=>{
                    outputRow[cellLineIndex][cellIndex] = cellLine;
                });
                return;
            }
            const cellLines = (0, wrapCell_1.wrapCell)(cell, config.columns[cellIndex].width, config.columns[cellIndex].wrapWord);
            const paddedCellLines = (0, exports.padCellVertically)(cellLines, outputRowHeight, config.columns[cellIndex].verticalAlignment);
            paddedCellLines.forEach((cellLine, cellLineIndex)=>{
                outputRow[cellLineIndex][cellIndex] = cellLine;
            });
        });
        return outputRow;
    });
    return (0, utils_1.flatten)(mappedRows);
};
exports.mapDataUsingRowHeights = mapDataUsingRowHeights; //# sourceMappingURL=mapDataUsingRowHeights.js.map
}}),
"[project]/node_modules/table/dist/src/padTableData.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.padTableData = exports.padString = void 0;
const padString = (input, paddingLeft, paddingRight)=>{
    return ' '.repeat(paddingLeft) + input + ' '.repeat(paddingRight);
};
exports.padString = padString;
const padTableData = (rows, config)=>{
    return rows.map((cells, rowIndex)=>{
        return cells.map((cell, cellIndex)=>{
            var _a;
            const containingRange = (_a = config.spanningCellManager) === null || _a === void 0 ? void 0 : _a.getContainingRange({
                col: cellIndex,
                row: rowIndex
            }, {
                mapped: true
            });
            if (containingRange) {
                return cell;
            }
            const { paddingLeft, paddingRight } = config.columns[cellIndex];
            return (0, exports.padString)(cell, paddingLeft, paddingRight);
        });
    });
};
exports.padTableData = padTableData; //# sourceMappingURL=padTableData.js.map
}}),
"[project]/node_modules/table/dist/src/stringifyTableData.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringifyTableData = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const stringifyTableData = (rows)=>{
    return rows.map((cells)=>{
        return cells.map((cell)=>{
            return (0, utils_1.normalizeString)(String(cell));
        });
    });
};
exports.stringifyTableData = stringifyTableData; //# sourceMappingURL=stringifyTableData.js.map
}}),
"[project]/node_modules/table/dist/src/truncateTableData.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.truncateTableData = exports.truncateString = void 0;
const lodash_truncate_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/lodash.truncate/index.js [app-route] (ecmascript)"));
const truncateString = (input, length)=>{
    return (0, lodash_truncate_1.default)(input, {
        length,
        omission: '…'
    });
};
exports.truncateString = truncateString;
/**
 * @todo Make it work with ASCII content.
 */ const truncateTableData = (rows, truncates)=>{
    return rows.map((cells)=>{
        return cells.map((cell, cellIndex)=>{
            return (0, exports.truncateString)(cell, truncates[cellIndex]);
        });
    });
};
exports.truncateTableData = truncateTableData; //# sourceMappingURL=truncateTableData.js.map
}}),
"[project]/node_modules/table/dist/src/createStream.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createStream = void 0;
const alignTableData_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/alignTableData.js [app-route] (ecmascript)");
const calculateRowHeights_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/calculateRowHeights.js [app-route] (ecmascript)");
const drawBorder_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/drawBorder.js [app-route] (ecmascript)");
const drawRow_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/drawRow.js [app-route] (ecmascript)");
const makeStreamConfig_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/makeStreamConfig.js [app-route] (ecmascript)");
const mapDataUsingRowHeights_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/mapDataUsingRowHeights.js [app-route] (ecmascript)");
const padTableData_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/padTableData.js [app-route] (ecmascript)");
const stringifyTableData_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/stringifyTableData.js [app-route] (ecmascript)");
const truncateTableData_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/truncateTableData.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const prepareData = (data, config)=>{
    let rows = (0, stringifyTableData_1.stringifyTableData)(data);
    rows = (0, truncateTableData_1.truncateTableData)(rows, (0, utils_1.extractTruncates)(config));
    const rowHeights = (0, calculateRowHeights_1.calculateRowHeights)(rows, config);
    rows = (0, mapDataUsingRowHeights_1.mapDataUsingRowHeights)(rows, rowHeights, config);
    rows = (0, alignTableData_1.alignTableData)(rows, config);
    rows = (0, padTableData_1.padTableData)(rows, config);
    return rows;
};
const create = (row, columnWidths, config)=>{
    const rows = prepareData([
        row
    ], config);
    const body = rows.map((literalRow)=>{
        return (0, drawRow_1.drawRow)(literalRow, config);
    }).join('');
    let output;
    output = '';
    output += (0, drawBorder_1.drawBorderTop)(columnWidths, config);
    output += body;
    output += (0, drawBorder_1.drawBorderBottom)(columnWidths, config);
    output = output.trimEnd();
    process.stdout.write(output);
};
const append = (row, columnWidths, config)=>{
    const rows = prepareData([
        row
    ], config);
    const body = rows.map((literalRow)=>{
        return (0, drawRow_1.drawRow)(literalRow, config);
    }).join('');
    let output = '';
    const bottom = (0, drawBorder_1.drawBorderBottom)(columnWidths, config);
    if (bottom !== '\n') {
        output = '\r\u001B[K';
    }
    output += (0, drawBorder_1.drawBorderJoin)(columnWidths, config);
    output += body;
    output += bottom;
    output = output.trimEnd();
    process.stdout.write(output);
};
const createStream = (userConfig)=>{
    const config = (0, makeStreamConfig_1.makeStreamConfig)(userConfig);
    const columnWidths = Object.values(config.columns).map((column)=>{
        return column.width + column.paddingLeft + column.paddingRight;
    });
    let empty = true;
    return {
        write: (row)=>{
            if (row.length !== config.columnCount) {
                throw new Error('Row cell count does not match the config.columnCount.');
            }
            if (empty) {
                empty = false;
                create(row, columnWidths, config);
            } else {
                append(row, columnWidths, config);
            }
        }
    };
};
exports.createStream = createStream; //# sourceMappingURL=createStream.js.map
}}),
"[project]/node_modules/table/dist/src/calculateOutputColumnWidths.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.calculateOutputColumnWidths = void 0;
const calculateOutputColumnWidths = (config)=>{
    return config.columns.map((col)=>{
        return col.paddingLeft + col.width + col.paddingRight;
    });
};
exports.calculateOutputColumnWidths = calculateOutputColumnWidths; //# sourceMappingURL=calculateOutputColumnWidths.js.map
}}),
"[project]/node_modules/table/dist/src/drawTable.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.drawTable = void 0;
const drawBorder_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/drawBorder.js [app-route] (ecmascript)");
const drawContent_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/drawContent.js [app-route] (ecmascript)");
const drawRow_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/drawRow.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const drawTable = (rows, outputColumnWidths, rowHeights, config)=>{
    const { drawHorizontalLine, singleLine } = config;
    const contents = (0, utils_1.groupBySizes)(rows, rowHeights).map((group, groupIndex)=>{
        return group.map((row)=>{
            return (0, drawRow_1.drawRow)(row, {
                ...config,
                rowIndex: groupIndex
            });
        }).join('');
    });
    return (0, drawContent_1.drawContent)({
        contents,
        drawSeparator: (index, size)=>{
            // Top/bottom border
            if (index === 0 || index === size) {
                return drawHorizontalLine(index, size);
            }
            return !singleLine && drawHorizontalLine(index, size);
        },
        elementType: 'row',
        rowIndex: -1,
        separatorGetter: (0, drawBorder_1.createTableBorderGetter)(outputColumnWidths, {
            ...config,
            rowCount: contents.length
        }),
        spanningCellManager: config.spanningCellManager
    });
};
exports.drawTable = drawTable; //# sourceMappingURL=drawTable.js.map
}}),
"[project]/node_modules/table/dist/src/injectHeaderConfig.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.injectHeaderConfig = void 0;
const injectHeaderConfig = (rows, config)=>{
    var _a;
    let spanningCellConfig = (_a = config.spanningCells) !== null && _a !== void 0 ? _a : [];
    const headerConfig = config.header;
    const adjustedRows = [
        ...rows
    ];
    if (headerConfig) {
        spanningCellConfig = spanningCellConfig.map(({ row, ...rest })=>{
            return {
                ...rest,
                row: row + 1
            };
        });
        const { content, ...headerStyles } = headerConfig;
        spanningCellConfig.unshift({
            alignment: 'center',
            col: 0,
            colSpan: rows[0].length,
            paddingLeft: 1,
            paddingRight: 1,
            row: 0,
            wrapWord: false,
            ...headerStyles
        });
        adjustedRows.unshift([
            content,
            ...Array.from({
                length: rows[0].length - 1
            }).fill('')
        ]);
    }
    return [
        adjustedRows,
        spanningCellConfig
    ];
};
exports.injectHeaderConfig = injectHeaderConfig; //# sourceMappingURL=injectHeaderConfig.js.map
}}),
"[project]/node_modules/table/dist/src/calculateMaximumColumnWidths.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.calculateMaximumColumnWidths = exports.calculateMaximumCellWidth = void 0;
const string_width_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/table/node_modules/string-width/index.js [app-route] (ecmascript)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const calculateMaximumCellWidth = (cell)=>{
    return Math.max(...cell.split('\n').map(string_width_1.default));
};
exports.calculateMaximumCellWidth = calculateMaximumCellWidth;
/**
 * Produces an array of values that describe the largest value length (width) in every column.
 */ const calculateMaximumColumnWidths = (rows, spanningCellConfigs = [])=>{
    const columnWidths = new Array(rows[0].length).fill(0);
    const rangeCoordinates = spanningCellConfigs.map(utils_1.calculateRangeCoordinate);
    const isSpanningCell = (rowIndex, columnIndex)=>{
        return rangeCoordinates.some((rangeCoordinate)=>{
            return (0, utils_1.isCellInRange)({
                col: columnIndex,
                row: rowIndex
            }, rangeCoordinate);
        });
    };
    rows.forEach((row, rowIndex)=>{
        row.forEach((cell, cellIndex)=>{
            if (isSpanningCell(rowIndex, cellIndex)) {
                return;
            }
            columnWidths[cellIndex] = Math.max(columnWidths[cellIndex], (0, exports.calculateMaximumCellWidth)(cell));
        });
    });
    return columnWidths;
};
exports.calculateMaximumColumnWidths = calculateMaximumColumnWidths; //# sourceMappingURL=calculateMaximumColumnWidths.js.map
}}),
"[project]/node_modules/table/dist/src/alignSpanningCell.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.alignVerticalRangeContent = exports.wrapRangeContent = void 0;
const string_width_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/table/node_modules/string-width/index.js [app-route] (ecmascript)"));
const alignString_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/alignString.js [app-route] (ecmascript)");
const mapDataUsingRowHeights_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/mapDataUsingRowHeights.js [app-route] (ecmascript)");
const padTableData_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/padTableData.js [app-route] (ecmascript)");
const truncateTableData_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/truncateTableData.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const wrapCell_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/wrapCell.js [app-route] (ecmascript)");
/**
 * Fill content into all cells in range in order to calculate total height
 */ const wrapRangeContent = (rangeConfig, rangeWidth, context)=>{
    const { topLeft, paddingRight, paddingLeft, truncate, wrapWord, alignment } = rangeConfig;
    const originalContent = context.rows[topLeft.row][topLeft.col];
    const contentWidth = rangeWidth - paddingLeft - paddingRight;
    return (0, wrapCell_1.wrapCell)((0, truncateTableData_1.truncateString)(originalContent, truncate), contentWidth, wrapWord).map((line)=>{
        const alignedLine = (0, alignString_1.alignString)(line, contentWidth, alignment);
        return (0, padTableData_1.padString)(alignedLine, paddingLeft, paddingRight);
    });
};
exports.wrapRangeContent = wrapRangeContent;
const alignVerticalRangeContent = (range, content, context)=>{
    const { rows, drawHorizontalLine, rowHeights } = context;
    const { topLeft, bottomRight, verticalAlignment } = range;
    // They are empty before calculateRowHeights function run
    if (rowHeights.length === 0) {
        return [];
    }
    const totalCellHeight = (0, utils_1.sumArray)(rowHeights.slice(topLeft.row, bottomRight.row + 1));
    const totalBorderHeight = bottomRight.row - topLeft.row;
    const hiddenHorizontalBorderCount = (0, utils_1.sequence)(topLeft.row + 1, bottomRight.row).filter((horizontalBorderIndex)=>{
        return !drawHorizontalLine(horizontalBorderIndex, rows.length);
    }).length;
    const availableRangeHeight = totalCellHeight + totalBorderHeight - hiddenHorizontalBorderCount;
    return (0, mapDataUsingRowHeights_1.padCellVertically)(content, availableRangeHeight, verticalAlignment).map((line)=>{
        if (line.length === 0) {
            return ' '.repeat((0, string_width_1.default)(content[0]));
        }
        return line;
    });
};
exports.alignVerticalRangeContent = alignVerticalRangeContent; //# sourceMappingURL=alignSpanningCell.js.map
}}),
"[project]/node_modules/table/dist/src/calculateSpanningCellWidth.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.calculateSpanningCellWidth = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const calculateSpanningCellWidth = (rangeConfig, dependencies)=>{
    const { columnsConfig, drawVerticalLine } = dependencies;
    const { topLeft, bottomRight } = rangeConfig;
    const totalWidth = (0, utils_1.sumArray)(columnsConfig.slice(topLeft.col, bottomRight.col + 1).map(({ width })=>{
        return width;
    }));
    const totalPadding = topLeft.col === bottomRight.col ? columnsConfig[topLeft.col].paddingRight + columnsConfig[bottomRight.col].paddingLeft : (0, utils_1.sumArray)(columnsConfig.slice(topLeft.col, bottomRight.col + 1).map(({ paddingLeft, paddingRight })=>{
        return paddingLeft + paddingRight;
    }));
    const totalBorderWidths = bottomRight.col - topLeft.col;
    const totalHiddenVerticalBorders = (0, utils_1.sequence)(topLeft.col + 1, bottomRight.col).filter((verticalBorderIndex)=>{
        return !drawVerticalLine(verticalBorderIndex, columnsConfig.length);
    }).length;
    return totalWidth + totalPadding + totalBorderWidths - totalHiddenVerticalBorders;
};
exports.calculateSpanningCellWidth = calculateSpanningCellWidth; //# sourceMappingURL=calculateSpanningCellWidth.js.map
}}),
"[project]/node_modules/table/dist/src/makeRangeConfig.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeRangeConfig = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const makeRangeConfig = (spanningCellConfig, columnsConfig)=>{
    var _a;
    const { topLeft, bottomRight } = (0, utils_1.calculateRangeCoordinate)(spanningCellConfig);
    const cellConfig = {
        ...columnsConfig[topLeft.col],
        ...spanningCellConfig,
        paddingRight: (_a = spanningCellConfig.paddingRight) !== null && _a !== void 0 ? _a : columnsConfig[bottomRight.col].paddingRight
    };
    return {
        ...cellConfig,
        bottomRight,
        topLeft
    };
};
exports.makeRangeConfig = makeRangeConfig; //# sourceMappingURL=makeRangeConfig.js.map
}}),
"[project]/node_modules/table/dist/src/spanningCellManager.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createSpanningCellManager = void 0;
const alignSpanningCell_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/alignSpanningCell.js [app-route] (ecmascript)");
const calculateSpanningCellWidth_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/calculateSpanningCellWidth.js [app-route] (ecmascript)");
const makeRangeConfig_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/makeRangeConfig.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const findRangeConfig = (cell, rangeConfigs)=>{
    return rangeConfigs.find((rangeCoordinate)=>{
        return (0, utils_1.isCellInRange)(cell, rangeCoordinate);
    });
};
const getContainingRange = (rangeConfig, context)=>{
    const width = (0, calculateSpanningCellWidth_1.calculateSpanningCellWidth)(rangeConfig, context);
    const wrappedContent = (0, alignSpanningCell_1.wrapRangeContent)(rangeConfig, width, context);
    const alignedContent = (0, alignSpanningCell_1.alignVerticalRangeContent)(rangeConfig, wrappedContent, context);
    const getCellContent = (rowIndex)=>{
        const { topLeft } = rangeConfig;
        const { drawHorizontalLine, rowHeights } = context;
        const totalWithinHorizontalBorderHeight = rowIndex - topLeft.row;
        const totalHiddenHorizontalBorderHeight = (0, utils_1.sequence)(topLeft.row + 1, rowIndex).filter((index)=>{
            /* istanbul ignore next */ return !(drawHorizontalLine === null || drawHorizontalLine === void 0 ? void 0 : drawHorizontalLine(index, rowHeights.length));
        }).length;
        const offset = (0, utils_1.sumArray)(rowHeights.slice(topLeft.row, rowIndex)) + totalWithinHorizontalBorderHeight - totalHiddenHorizontalBorderHeight;
        return alignedContent.slice(offset, offset + rowHeights[rowIndex]);
    };
    const getBorderContent = (borderIndex)=>{
        const { topLeft } = rangeConfig;
        const offset = (0, utils_1.sumArray)(context.rowHeights.slice(topLeft.row, borderIndex)) + (borderIndex - topLeft.row - 1);
        return alignedContent[offset];
    };
    return {
        ...rangeConfig,
        extractBorderContent: getBorderContent,
        extractCellContent: getCellContent,
        height: wrappedContent.length,
        width
    };
};
const inSameRange = (cell1, cell2, ranges)=>{
    const range1 = findRangeConfig(cell1, ranges);
    const range2 = findRangeConfig(cell2, ranges);
    if (range1 && range2) {
        return (0, utils_1.areCellEqual)(range1.topLeft, range2.topLeft);
    }
    return false;
};
const hashRange = (range)=>{
    const { row, col } = range.topLeft;
    return `${row}/${col}`;
};
const createSpanningCellManager = (parameters)=>{
    const { spanningCellConfigs, columnsConfig } = parameters;
    const ranges = spanningCellConfigs.map((config)=>{
        return (0, makeRangeConfig_1.makeRangeConfig)(config, columnsConfig);
    });
    const rangeCache = {};
    let rowHeights = [];
    let rowIndexMapping = [];
    return {
        getContainingRange: (cell, options)=>{
            var _a;
            const originalRow = (options === null || options === void 0 ? void 0 : options.mapped) ? rowIndexMapping[cell.row] : cell.row;
            const range = findRangeConfig({
                ...cell,
                row: originalRow
            }, ranges);
            if (!range) {
                return undefined;
            }
            if (rowHeights.length === 0) {
                return getContainingRange(range, {
                    ...parameters,
                    rowHeights
                });
            }
            const hash = hashRange(range);
            (_a = rangeCache[hash]) !== null && _a !== void 0 ? _a : rangeCache[hash] = getContainingRange(range, {
                ...parameters,
                rowHeights
            });
            return rangeCache[hash];
        },
        inSameRange: (cell1, cell2)=>{
            return inSameRange(cell1, cell2, ranges);
        },
        rowHeights,
        rowIndexMapping,
        setRowHeights: (_rowHeights)=>{
            rowHeights = _rowHeights;
        },
        setRowIndexMapping: (mappedRowHeights)=>{
            rowIndexMapping = (0, utils_1.flatten)(mappedRowHeights.map((height, index)=>{
                return Array.from({
                    length: height
                }, ()=>{
                    return index;
                });
            }));
        }
    };
};
exports.createSpanningCellManager = createSpanningCellManager; //# sourceMappingURL=spanningCellManager.js.map
}}),
"[project]/node_modules/table/dist/src/validateSpanningCellConfig.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateSpanningCellConfig = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const inRange = (start, end, value)=>{
    return start <= value && value <= end;
};
const validateSpanningCellConfig = (rows, configs)=>{
    const [nRow, nCol] = [
        rows.length,
        rows[0].length
    ];
    configs.forEach((config, configIndex)=>{
        const { colSpan, rowSpan } = config;
        if (colSpan === undefined && rowSpan === undefined) {
            throw new Error(`Expect at least colSpan or rowSpan is provided in config.spanningCells[${configIndex}]`);
        }
        if (colSpan !== undefined && colSpan < 1) {
            throw new Error(`Expect colSpan is not equal zero, instead got: ${colSpan} in config.spanningCells[${configIndex}]`);
        }
        if (rowSpan !== undefined && rowSpan < 1) {
            throw new Error(`Expect rowSpan is not equal zero, instead got: ${rowSpan} in config.spanningCells[${configIndex}]`);
        }
    });
    const rangeCoordinates = configs.map(utils_1.calculateRangeCoordinate);
    rangeCoordinates.forEach(({ topLeft, bottomRight }, rangeIndex)=>{
        if (!inRange(0, nCol - 1, topLeft.col) || !inRange(0, nRow - 1, topLeft.row) || !inRange(0, nCol - 1, bottomRight.col) || !inRange(0, nRow - 1, bottomRight.row)) {
            throw new Error(`Some cells in config.spanningCells[${rangeIndex}] are out of the table`);
        }
    });
    const configOccupy = Array.from({
        length: nRow
    }, ()=>{
        return Array.from({
            length: nCol
        });
    });
    rangeCoordinates.forEach(({ topLeft, bottomRight }, rangeIndex)=>{
        (0, utils_1.sequence)(topLeft.row, bottomRight.row).forEach((row)=>{
            (0, utils_1.sequence)(topLeft.col, bottomRight.col).forEach((col)=>{
                if (configOccupy[row][col] !== undefined) {
                    throw new Error(`Spanning cells in config.spanningCells[${configOccupy[row][col]}] and config.spanningCells[${rangeIndex}] are overlap each other`);
                }
                configOccupy[row][col] = rangeIndex;
            });
        });
    });
};
exports.validateSpanningCellConfig = validateSpanningCellConfig; //# sourceMappingURL=validateSpanningCellConfig.js.map
}}),
"[project]/node_modules/table/dist/src/makeTableConfig.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeTableConfig = void 0;
const calculateMaximumColumnWidths_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/calculateMaximumColumnWidths.js [app-route] (ecmascript)");
const spanningCellManager_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/spanningCellManager.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const validateConfig_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/validateConfig.js [app-route] (ecmascript)");
const validateSpanningCellConfig_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/validateSpanningCellConfig.js [app-route] (ecmascript)");
/**
 * Creates a configuration for every column using default
 * values for the missing configuration properties.
 */ const makeColumnsConfig = (rows, columns, columnDefault, spanningCellConfigs)=>{
    const columnWidths = (0, calculateMaximumColumnWidths_1.calculateMaximumColumnWidths)(rows, spanningCellConfigs);
    return rows[0].map((_, columnIndex)=>{
        return {
            alignment: 'left',
            paddingLeft: 1,
            paddingRight: 1,
            truncate: Number.POSITIVE_INFINITY,
            verticalAlignment: 'top',
            width: columnWidths[columnIndex],
            wrapWord: false,
            ...columnDefault,
            ...columns === null || columns === void 0 ? void 0 : columns[columnIndex]
        };
    });
};
/**
 * Makes a new configuration object out of the userConfig object
 * using default values for the missing configuration properties.
 */ const makeTableConfig = (rows, config = {}, injectedSpanningCellConfig)=>{
    var _a, _b, _c, _d, _e;
    (0, validateConfig_1.validateConfig)('config.json', config);
    (0, validateSpanningCellConfig_1.validateSpanningCellConfig)(rows, (_a = config.spanningCells) !== null && _a !== void 0 ? _a : []);
    const spanningCellConfigs = (_b = injectedSpanningCellConfig !== null && injectedSpanningCellConfig !== void 0 ? injectedSpanningCellConfig : config.spanningCells) !== null && _b !== void 0 ? _b : [];
    const columnsConfig = makeColumnsConfig(rows, config.columns, config.columnDefault, spanningCellConfigs);
    const drawVerticalLine = (_c = config.drawVerticalLine) !== null && _c !== void 0 ? _c : ()=>{
        return true;
    };
    const drawHorizontalLine = (_d = config.drawHorizontalLine) !== null && _d !== void 0 ? _d : ()=>{
        return true;
    };
    return {
        ...config,
        border: (0, utils_1.makeBorderConfig)(config.border),
        columns: columnsConfig,
        drawHorizontalLine,
        drawVerticalLine,
        singleLine: (_e = config.singleLine) !== null && _e !== void 0 ? _e : false,
        spanningCellManager: (0, spanningCellManager_1.createSpanningCellManager)({
            columnsConfig,
            drawHorizontalLine,
            drawVerticalLine,
            rows,
            spanningCellConfigs
        })
    };
};
exports.makeTableConfig = makeTableConfig; //# sourceMappingURL=makeTableConfig.js.map
}}),
"[project]/node_modules/table/dist/src/validateTableData.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateTableData = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const validateTableData = (rows)=>{
    if (!Array.isArray(rows)) {
        throw new TypeError('Table data must be an array.');
    }
    if (rows.length === 0) {
        throw new Error('Table must define at least one row.');
    }
    if (rows[0].length === 0) {
        throw new Error('Table must define at least one column.');
    }
    const columnNumber = rows[0].length;
    for (const row of rows){
        if (!Array.isArray(row)) {
            throw new TypeError('Table row data must be an array.');
        }
        if (row.length !== columnNumber) {
            throw new Error('Table must have a consistent number of cells.');
        }
        for (const cell of row){
            // eslint-disable-next-line no-control-regex
            if (/[\u0001-\u0006\u0008\u0009\u000B-\u001A]/.test((0, utils_1.normalizeString)(String(cell)))) {
                throw new Error('Table data must not contain control characters.');
            }
        }
    }
};
exports.validateTableData = validateTableData; //# sourceMappingURL=validateTableData.js.map
}}),
"[project]/node_modules/table/dist/src/table.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.table = void 0;
const alignTableData_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/alignTableData.js [app-route] (ecmascript)");
const calculateOutputColumnWidths_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/calculateOutputColumnWidths.js [app-route] (ecmascript)");
const calculateRowHeights_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/calculateRowHeights.js [app-route] (ecmascript)");
const drawTable_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/drawTable.js [app-route] (ecmascript)");
const injectHeaderConfig_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/injectHeaderConfig.js [app-route] (ecmascript)");
const makeTableConfig_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/makeTableConfig.js [app-route] (ecmascript)");
const mapDataUsingRowHeights_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/mapDataUsingRowHeights.js [app-route] (ecmascript)");
const padTableData_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/padTableData.js [app-route] (ecmascript)");
const stringifyTableData_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/stringifyTableData.js [app-route] (ecmascript)");
const truncateTableData_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/truncateTableData.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/utils.js [app-route] (ecmascript)");
const validateTableData_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/validateTableData.js [app-route] (ecmascript)");
const table = (data, userConfig = {})=>{
    (0, validateTableData_1.validateTableData)(data);
    let rows = (0, stringifyTableData_1.stringifyTableData)(data);
    const [injectedRows, injectedSpanningCellConfig] = (0, injectHeaderConfig_1.injectHeaderConfig)(rows, userConfig);
    const config = (0, makeTableConfig_1.makeTableConfig)(injectedRows, userConfig, injectedSpanningCellConfig);
    rows = (0, truncateTableData_1.truncateTableData)(injectedRows, (0, utils_1.extractTruncates)(config));
    const rowHeights = (0, calculateRowHeights_1.calculateRowHeights)(rows, config);
    config.spanningCellManager.setRowHeights(rowHeights);
    config.spanningCellManager.setRowIndexMapping(rowHeights);
    rows = (0, mapDataUsingRowHeights_1.mapDataUsingRowHeights)(rows, rowHeights, config);
    rows = (0, alignTableData_1.alignTableData)(rows, config);
    rows = (0, padTableData_1.padTableData)(rows, config);
    const outputColumnWidths = (0, calculateOutputColumnWidths_1.calculateOutputColumnWidths)(config);
    return (0, drawTable_1.drawTable)(rows, outputColumnWidths, rowHeights, config);
};
exports.table = table; //# sourceMappingURL=table.js.map
}}),
"[project]/node_modules/table/dist/src/types/api.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=api.js.map
}}),
"[project]/node_modules/table/dist/src/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getBorderCharacters = exports.createStream = exports.table = void 0;
const createStream_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/createStream.js [app-route] (ecmascript)");
Object.defineProperty(exports, "createStream", {
    enumerable: true,
    get: function() {
        return createStream_1.createStream;
    }
});
const getBorderCharacters_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/getBorderCharacters.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getBorderCharacters", {
    enumerable: true,
    get: function() {
        return getBorderCharacters_1.getBorderCharacters;
    }
});
const table_1 = __turbopack_context__.r("[project]/node_modules/table/dist/src/table.js [app-route] (ecmascript)");
Object.defineProperty(exports, "table", {
    enumerable: true,
    get: function() {
        return table_1.table;
    }
});
__exportStar(__turbopack_context__.r("[project]/node_modules/table/dist/src/types/api.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),

};

//# sourceMappingURL=node_modules_table_dist_src_79fe5e50._.js.map