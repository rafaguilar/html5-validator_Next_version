module.exports = {

"[project]/node_modules/postcss-value-parser/lib/unit.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);
// Check if three code points would start a number
// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
function likeNumber(value) {
    var code = value.charCodeAt(0);
    var nextCode;
    if (code === plus || code === minus) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
            return true;
        }
        var nextNextCode = value.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
        }
        return false;
    }
    if (code === dot) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
            return true;
        }
        return false;
    }
    if (code >= 48 && code <= 57) {
        return true;
    }
    return false;
}
// Consume a number
// https://www.w3.org/TR/css-syntax-3/#consume-number
module.exports = function(value) {
    var pos = 0;
    var length = value.length;
    var code;
    var nextCode;
    var nextNextCode;
    if (length === 0 || !likeNumber(value)) {
        return false;
    }
    code = value.charCodeAt(pos);
    if (code === plus || code === minus) {
        pos++;
    }
    while(pos < length){
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
            break;
        }
        pos += 1;
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while(pos < length){
            code = value.charCodeAt(pos);
            if (code < 48 || code > 57) {
                break;
            }
            pos += 1;
        }
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    nextNextCode = value.charCodeAt(pos + 2);
    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while(pos < length){
            code = value.charCodeAt(pos);
            if (code < 48 || code > 57) {
                break;
            }
            pos += 1;
        }
    }
    return {
        number: value.slice(0, pos),
        unit: value.slice(pos)
    };
};
}}),
"[project]/node_modules/postcss-value-parser/lib/parse.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);
var uLower = "u".charCodeAt(0);
var uUpper = "U".charCodeAt(0);
var plus = "+".charCodeAt(0);
var isUnicodeRange = /^[a-f0-9?-]+$/i;
module.exports = function(input) {
    var tokens = [];
    var value = input;
    var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;
    var pos = 0;
    var code = value.charCodeAt(pos);
    var max = value.length;
    var stack = [
        {
            nodes: tokens
        }
    ];
    var balanced = 0;
    var parent;
    var name = "";
    var before = "";
    var after = "";
    while(pos < max){
        // Whitespaces
        if (code <= 32) {
            next = pos;
            do {
                next += 1;
                code = value.charCodeAt(next);
            }while (code <= 32)
            token = value.slice(pos, next);
            prev = tokens[tokens.length - 1];
            if (code === closeParentheses && balanced) {
                after = token;
            } else if (prev && prev.type === "div") {
                prev.after = token;
                prev.sourceEndIndex += token.length;
            } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
                before = token;
            } else {
                tokens.push({
                    type: "space",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            }
            pos = next;
        // Quotes
        } else if (code === singleQuote || code === doubleQuote) {
            next = pos;
            quote = code === singleQuote ? "'" : '"';
            token = {
                type: "string",
                sourceIndex: pos,
                quote: quote
            };
            do {
                escape = false;
                next = value.indexOf(quote, next + 1);
                if (~next) {
                    escapePos = next;
                    while(value.charCodeAt(escapePos - 1) === backslash){
                        escapePos -= 1;
                        escape = !escape;
                    }
                } else {
                    value += quote;
                    next = value.length - 1;
                    token.unclosed = true;
                }
            }while (escape)
            token.value = value.slice(pos + 1, next);
            token.sourceEndIndex = token.unclosed ? next : next + 1;
            tokens.push(token);
            pos = next + 1;
            code = value.charCodeAt(pos);
        // Comments
        } else if (code === slash && value.charCodeAt(pos + 1) === star) {
            next = value.indexOf("*/", pos);
            token = {
                type: "comment",
                sourceIndex: pos,
                sourceEndIndex: next + 2
            };
            if (next === -1) {
                token.unclosed = true;
                next = value.length;
                token.sourceEndIndex = next;
            }
            token.value = value.slice(pos + 2, next);
            tokens.push(token);
            pos = next + 2;
            code = value.charCodeAt(pos);
        // Operation within calc
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
            token = value[pos];
            tokens.push({
                type: "word",
                sourceIndex: pos - before.length,
                sourceEndIndex: pos + token.length,
                value: token
            });
            pos += 1;
            code = value.charCodeAt(pos);
        // Dividers
        } else if (code === slash || code === comma || code === colon) {
            token = value[pos];
            tokens.push({
                type: "div",
                sourceIndex: pos - before.length,
                sourceEndIndex: pos + token.length,
                value: token,
                before: before,
                after: ""
            });
            before = "";
            pos += 1;
            code = value.charCodeAt(pos);
        // Open parentheses
        } else if (openParentheses === code) {
            // Whitespaces after open parentheses
            next = pos;
            do {
                next += 1;
                code = value.charCodeAt(next);
            }while (code <= 32)
            parenthesesOpenPos = pos;
            token = {
                type: "function",
                sourceIndex: pos - name.length,
                value: name,
                before: value.slice(parenthesesOpenPos + 1, next)
            };
            pos = next;
            if (name === "url" && code !== singleQuote && code !== doubleQuote) {
                next -= 1;
                do {
                    escape = false;
                    next = value.indexOf(")", next + 1);
                    if (~next) {
                        escapePos = next;
                        while(value.charCodeAt(escapePos - 1) === backslash){
                            escapePos -= 1;
                            escape = !escape;
                        }
                    } else {
                        value += ")";
                        next = value.length - 1;
                        token.unclosed = true;
                    }
                }while (escape)
                // Whitespaces before closed
                whitespacePos = next;
                do {
                    whitespacePos -= 1;
                    code = value.charCodeAt(whitespacePos);
                }while (code <= 32)
                if (parenthesesOpenPos < whitespacePos) {
                    if (pos !== whitespacePos + 1) {
                        token.nodes = [
                            {
                                type: "word",
                                sourceIndex: pos,
                                sourceEndIndex: whitespacePos + 1,
                                value: value.slice(pos, whitespacePos + 1)
                            }
                        ];
                    } else {
                        token.nodes = [];
                    }
                    if (token.unclosed && whitespacePos + 1 !== next) {
                        token.after = "";
                        token.nodes.push({
                            type: "space",
                            sourceIndex: whitespacePos + 1,
                            sourceEndIndex: next,
                            value: value.slice(whitespacePos + 1, next)
                        });
                    } else {
                        token.after = value.slice(whitespacePos + 1, next);
                        token.sourceEndIndex = next;
                    }
                } else {
                    token.after = "";
                    token.nodes = [];
                }
                pos = next + 1;
                token.sourceEndIndex = token.unclosed ? next : pos;
                code = value.charCodeAt(pos);
                tokens.push(token);
            } else {
                balanced += 1;
                token.after = "";
                token.sourceEndIndex = pos + 1;
                tokens.push(token);
                stack.push(token);
                tokens = token.nodes = [];
                parent = token;
            }
            name = "";
        // Close parentheses
        } else if (closeParentheses === code && balanced) {
            pos += 1;
            code = value.charCodeAt(pos);
            parent.after = after;
            parent.sourceEndIndex += after.length;
            after = "";
            balanced -= 1;
            stack[stack.length - 1].sourceEndIndex = pos;
            stack.pop();
            parent = stack[balanced];
            tokens = parent.nodes;
        // Words
        } else {
            next = pos;
            do {
                if (code === backslash) {
                    next += 1;
                }
                next += 1;
                code = value.charCodeAt(next);
            }while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced))
            token = value.slice(pos, next);
            if (openParentheses === code) {
                name = token;
            } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
                tokens.push({
                    type: "unicode-range",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            } else {
                tokens.push({
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            }
            pos = next;
        }
    }
    for(pos = stack.length - 1; pos; pos -= 1){
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value.length;
    }
    return stack[0].nodes;
};
}}),
"[project]/node_modules/postcss-value-parser/lib/walk.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = function walk(nodes, cb, bubble) {
    var i, max, node, result;
    for(i = 0, max = nodes.length; i < max; i += 1){
        node = nodes[i];
        if (!bubble) {
            result = cb(node, i, nodes);
        }
        if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
            walk(node.nodes, cb, bubble);
        }
        if (bubble) {
            cb(node, i, nodes);
        }
    }
};
}}),
"[project]/node_modules/postcss-value-parser/lib/stringify.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
function stringifyNode(node, custom) {
    var type = node.type;
    var value = node.value;
    var buf;
    var customResult;
    if (custom && (customResult = custom(node)) !== undefined) {
        return customResult;
    } else if (type === "word" || type === "space") {
        return value;
    } else if (type === "string") {
        buf = node.quote || "";
        return buf + value + (node.unclosed ? "" : buf);
    } else if (type === "comment") {
        return "/*" + value + (node.unclosed ? "" : "*/");
    } else if (type === "div") {
        return (node.before || "") + value + (node.after || "");
    } else if (Array.isArray(node.nodes)) {
        buf = stringify(node.nodes, custom);
        if (type !== "function") {
            return buf;
        }
        return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
    }
    return value;
}
function stringify(nodes, custom) {
    var result, i;
    if (Array.isArray(nodes)) {
        result = "";
        for(i = nodes.length - 1; ~i; i -= 1){
            result = stringifyNode(nodes[i], custom) + result;
        }
        return result;
    }
    return stringifyNode(nodes, custom);
}
module.exports = stringify;
}}),
"[project]/node_modules/postcss-value-parser/lib/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var parse = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/parse.js [app-route] (ecmascript)");
var walk = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/walk.js [app-route] (ecmascript)");
var stringify = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/stringify.js [app-route] (ecmascript)");
function ValueParser(value) {
    if (this instanceof ValueParser) {
        this.nodes = parse(value);
        return this;
    }
    return new ValueParser(value);
}
ValueParser.prototype.toString = function() {
    return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};
ValueParser.prototype.walk = function(cb, bubble) {
    walk(this.nodes, cb, bubble);
    return this;
};
ValueParser.unit = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/unit.js [app-route] (ecmascript)");
ValueParser.walk = walk;
ValueParser.stringify = stringify;
module.exports = ValueParser;
}}),
"[project]/node_modules/stylelint/lib/utils/getAtRuleParams.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @param {import('postcss').AtRule} atRule
 * @returns {string}
 */ __turbopack_context__.s({
    "default": (()=>getAtRuleParams)
});
function getAtRuleParams(atRule) {
    return atRule.raws.params?.raw ?? atRule.params;
}
}}),
"[project]/node_modules/stylelint/lib/utils/getRuleSelector.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @param {import('postcss').Rule} ruleNode
 * @returns {string}
 */ __turbopack_context__.s({
    "default": (()=>getRuleSelector)
});
function getRuleSelector(ruleNode) {
    const raws = ruleNode.raws;
    return raws.selector && raws.selector.raw || ruleNode.selector;
}
}}),
"[project]/node_modules/stylelint/lib/utils/nodeFieldIndices.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "atRuleAfterIndex": (()=>atRuleAfterIndex),
    "atRuleAfterNameIndex": (()=>atRuleAfterNameIndex),
    "atRuleBetweenIndex": (()=>atRuleBetweenIndex),
    "atRuleParamIndex": (()=>atRuleParamIndex),
    "declarationBetweenIndex": (()=>declarationBetweenIndex),
    "declarationValueIndex": (()=>declarationValueIndex),
    "ruleAfterIndex": (()=>ruleAfterIndex),
    "ruleBetweenIndex": (()=>ruleBetweenIndex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getAtRuleParams$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/getAtRuleParams.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getRuleSelector$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/getRuleSelector.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/validateTypes.mjs [app-route] (ecmascript)");
;
;
;
function atRuleParamIndex(atRule) {
    const index = atRuleAfterNameIndex(atRule);
    return index + (atRule.raws.afterName?.length ?? 0);
}
function atRuleAfterIndex(atRule) {
    // subtract 1 for `}`
    const endOffset = atRule.source?.end?.offset;
    if (!endOffset) return atRule.toString().length - 1;
    const afterLength = atRule.raws?.after?.length;
    if (!afterLength) return endOffset - 1;
    return endOffset - (afterLength + 1);
}
function atRuleAfterNameIndex(atRule) {
    // Initial 1 is for the `@`
    return 1 + atRule.name.length;
}
function atRuleBetweenIndex(atRule) {
    return atRuleParamIndex(atRule) + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getAtRuleParams$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule).length;
}
function declarationBetweenIndex(decl) {
    const { prop } = decl.raws;
    const propIsObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isObject"])(prop);
    return countChars([
        propIsObject && 'prefix' in prop && prop.prefix,
        propIsObject && 'raw' in prop && prop.raw || decl.prop,
        propIsObject && 'suffix' in prop && prop.suffix
    ]);
}
function declarationValueIndex(decl) {
    const { between, value } = decl.raws;
    return declarationBetweenIndex(decl) + countChars([
        between || ':',
        value && 'prefix' in value && value.prefix
    ]);
}
function ruleBetweenIndex(rule) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getRuleSelector$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(rule).length;
}
function ruleAfterIndex(rule) {
    // subtract 1 for `}`
    const endOffset = rule.source?.end?.offset;
    if (!endOffset) return rule.toString().length - 1;
    const afterLength = rule.raws?.after?.length;
    if (!afterLength) return endOffset - 1;
    return endOffset - (afterLength + 1);
}
/**
 * @param {unknown[]} values
 * @returns {number}
 */ function countChars(values) {
    return values.reduce((/** @type {number} */ count, value)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isString"])(value)) return count + value.length;
        return count;
    }, 0);
}
}}),
"[project]/node_modules/stylelint/lib/rules/named-grid-areas-no-invalid/utils/findNotContiguousOrRectangular.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>findNotContiguousOrRectangular)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$arrayEqual$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/arrayEqual.mjs [app-route] (ecmascript)");
;
/**
 * @param {string[][]} areas
 * @param {string} name
 * @returns {boolean}
 */ function isContiguousAndRectangular(areas, name) {
    const indicesByRow = areas.map((row)=>{
        const indices = [];
        let idx = row.indexOf(name);
        while(idx !== -1){
            indices.push(idx);
            idx = row.indexOf(name, idx + 1);
        }
        return indices;
    });
    for(let i = 0; i < indicesByRow.length; i++){
        for(let j = i + 1; j < indicesByRow.length; j++){
            const x = indicesByRow[i];
            const y = indicesByRow[j];
            if (x && x.length === 0 || y && y.length === 0) {
                continue;
            }
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$arrayEqual$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(x, y)) {
                return false;
            }
        }
    }
    return true;
}
/**
 * @param {string[][]} areas
 * @returns {string[]}
 */ function namedAreas(areas) {
    const names = new Set(areas.flat());
    names.delete('.');
    return [
        ...names
    ];
}
function findNotContiguousOrRectangular(areas) {
    return namedAreas(areas).filter((name)=>!isContiguousAndRectangular(areas, name));
}
}}),
"[project]/node_modules/stylelint/lib/rules/named-grid-areas-no-invalid/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2d$value$2d$parser$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/postcss-value-parser/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/validateTypes.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$nodeFieldIndices$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/nodeFieldIndices.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$rules$2f$named$2d$grid$2d$areas$2d$no$2d$invalid$2f$utils$2f$findNotContiguousOrRectangular$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/rules/named-grid-areas-no-invalid/utils/findNotContiguousOrRectangular.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$report$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/report.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$ruleMessages$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/ruleMessages.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateOptions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/validateOptions.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
const ruleName = 'named-grid-areas-no-invalid';
const messages = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$ruleMessages$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(ruleName, {
    expectedToken: ()=>'Expected cell token within string',
    expectedSameNumber: ()=>'Expected same number of cell tokens in each string',
    expectedRectangle: (name)=>`Expected single filled-in rectangle for "${name}"`
});
const meta = {
    url: 'https://stylelint.io/user-guide/rules/named-grid-areas-no-invalid'
};
/** @type {import('stylelint').CoreRules[ruleName]} */ const rule = (primary)=>{
    return (root, result)=>{
        const validOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateOptions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(result, ruleName, {
            actual: primary
        });
        if (!validOptions) {
            return;
        }
        root.walkDecls(/^(?:grid|grid-template|grid-template-areas)$/i, (decl)=>{
            const { value } = decl;
            if (value.toLowerCase().trim() === 'none') return;
            /** @type {Array<{ values: string[], index: number, endIndex: number }>} */ const areas = [];
            let reportSent = false;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2d$value$2d$parser$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value).walk(({ sourceIndex, sourceEndIndex, type, value: tokenValue })=>{
                if (type !== 'string') return;
                if (tokenValue === '') {
                    complain(messages.expectedToken(), sourceIndex, sourceEndIndex);
                    reportSent = true;
                    return;
                }
                areas.push({
                    values: tokenValue.trim().split(' ').filter(Boolean),
                    index: sourceIndex,
                    endIndex: sourceEndIndex
                });
            });
            if (reportSent) return;
            const [firstArea] = areas;
            if (firstArea === undefined) return;
            const notSameNumberArea = areas.find((area)=>area.values.length !== firstArea.values.length);
            if (notSameNumberArea !== undefined) {
                complain(messages.expectedSameNumber(), notSameNumberArea.index, notSameNumberArea.endIndex);
                return;
            }
            const notContiguousOrRectangular = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$rules$2f$named$2d$grid$2d$areas$2d$no$2d$invalid$2f$utils$2f$findNotContiguousOrRectangular$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(areas.map((a)=>a.values));
            for (const name of notContiguousOrRectangular.sort()){
                const area = areas.find((a)=>a.values.includes(name));
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(area);
                complain(messages.expectedRectangle(name), area.index, area.endIndex);
            }
            /**
			 * @param {string} message
			 * @param {number} index
			 * @param {number} endIndex
			 */ function complain(message, index, endIndex) {
                const start = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$nodeFieldIndices$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["declarationValueIndex"])(decl);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$report$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
                    message,
                    node: decl,
                    index: start + index,
                    endIndex: start + endIndex,
                    result,
                    ruleName
                });
            }
        });
    };
};
rule.ruleName = ruleName;
rule.messages = messages;
rule.meta = meta;
const __TURBOPACK__default__export__ = rule;
}}),

};

//# sourceMappingURL=node_modules_410c4386._.js.map