module.exports = {

"[project]/node_modules/stylelint/lib/utils/addEmptyLineBefore.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Add one or two empty line(s) before a node. Mutates the node.
 *
 * @template {import('postcss').Node} T
 * @param {T} node
 * @param {string} newline
 * @returns {T}
 */ __turbopack_context__.s({
    "default": (()=>addEmptyLineBefore)
});
function addEmptyLineBefore(node, newline) {
    const { raws } = node;
    if (typeof raws.before !== 'string') {
        return node;
    }
    raws.before = !/\r?\n/.test(raws.before) ? newline.repeat(2) + raws.before : raws.before.replace(/(\r?\n)/, `${newline}$1`);
    return node;
}
}}),
"[project]/node_modules/stylelint/lib/utils/removeEmptyLinesBefore.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Remove empty lines before a node. Mutates the node.
 *
 * @template {import('postcss').Node} T
 * @param {T} node
 * @param {string} newline
 * @returns {T}
 */ __turbopack_context__.s({
    "default": (()=>removeEmptyLinesBefore)
});
function removeEmptyLinesBefore(node, newline) {
    node.raws.before = node.raws.before ? node.raws.before.replace(/(\r?\n\s*\n)+/g, newline) : '';
    return node;
}
}}),
"[project]/node_modules/stylelint/lib/utils/fixEmptyLinesBefore.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>fixEmptyLinesBefore)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$addEmptyLineBefore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/addEmptyLineBefore.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/validateTypes.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$removeEmptyLinesBefore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/removeEmptyLinesBefore.mjs [app-route] (ecmascript)");
;
;
;
function fixEmptyLinesBefore({ node, newline, action }) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(newline);
    switch(action){
        case 'add':
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$addEmptyLineBefore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(node, newline);
            break;
        case 'remove':
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$removeEmptyLinesBefore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(node, newline);
            break;
        default:
            throw new TypeError(`Unknown action ${action}`);
    }
}
}}),
"[project]/node_modules/stylelint/lib/utils/getPreviousNonSharedLineCommentNode.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/** @typedef {import('postcss').Node} Node */ /**
 * @param {Node} node
 */ __turbopack_context__.s({
    "default": (()=>getPreviousNonSharedLineCommentNode)
});
function getNodeLine(node) {
    return node.source && node.source.start && node.source.start.line;
}
function getPreviousNonSharedLineCommentNode(node) {
    if (node === undefined) {
        return undefined;
    }
    const previousNode = node.prev();
    if (!previousNode || previousNode.type !== 'comment') {
        return previousNode;
    }
    if (getNodeLine(node) === getNodeLine(previousNode)) {
        return getPreviousNonSharedLineCommentNode(previousNode);
    }
    const previousNode2 = previousNode.prev();
    if (previousNode2 && getNodeLine(previousNode) === getNodeLine(previousNode2)) {
        return getPreviousNonSharedLineCommentNode(previousNode);
    }
    return previousNode;
}
}}),
"[project]/node_modules/stylelint/lib/utils/hasEmptyLine.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>hasEmptyLine)
});
const HAS_EMPTY_LINE = /\n[\r\t ]*\n/;
function hasEmptyLine(string) {
    if (string === '' || string === undefined) return false;
    return HAS_EMPTY_LINE.test(string);
}
}}),
"[project]/node_modules/stylelint/lib/utils/getNextNonSharedLineCommentNode.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/** @typedef {import('postcss').Node} Node */ /**
 * @param {Node | void} node
 */ __turbopack_context__.s({
    "default": (()=>getNextNonSharedLineCommentNode)
});
function getNodeLine(node) {
    return node && node.source && node.source.start && node.source.start.line;
}
function getNextNonSharedLineCommentNode(node) {
    if (node === undefined) {
        return undefined;
    }
    /** @type {Node | void} */ const nextNode = node.next();
    if (!nextNode || nextNode.type !== 'comment') {
        return nextNode;
    }
    if (getNodeLine(node) === getNodeLine(nextNode) || getNodeLine(nextNode) === getNodeLine(nextNode.next())) {
        return getNextNonSharedLineCommentNode(nextNode);
    }
    return nextNode;
}
}}),
"[project]/node_modules/stylelint/lib/utils/isSharedLineComment.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>isSharedLineComment)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/typeGuards.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getNextNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/getNextNonSharedLineCommentNode.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getPreviousNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/getPreviousNonSharedLineCommentNode.mjs [app-route] (ecmascript)");
;
;
;
/** @typedef {import('postcss').Node} PostcssNode */ /**
 * @param {PostcssNode | void} a
 * @param {PostcssNode | void} b
 */ function nodesShareLines(a, b) {
    const endLine = a && a.source && a.source.end && a.source.end.line;
    const startLine = b && b.source && b.source.start && b.source.start.line;
    return endLine === startLine;
}
function isSharedLineComment(node) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isComment"])(node)) {
        return false;
    }
    const previousNonSharedLineCommentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getPreviousNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(node);
    if (nodesShareLines(previousNonSharedLineCommentNode, node)) {
        return true;
    }
    const nextNonSharedLineCommentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getNextNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(node);
    if (nextNonSharedLineCommentNode && nodesShareLines(node, nextNonSharedLineCommentNode)) {
        return true;
    }
    const parentNode = node.parent;
    // It's a first child and located on the same line as block start
    if (parentNode !== undefined && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRoot"])(parentNode) && parentNode.index(node) === 0 && node.raws.before !== undefined && !node.raws.before.includes('\n')) {
        return true;
    }
    return false;
}
}}),
"[project]/node_modules/stylelint/lib/utils/isAfterComment.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>isAfterComment)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isSharedLineComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isSharedLineComment.mjs [app-route] (ecmascript)");
;
function isAfterComment(node) {
    const previousNode = node.prev();
    if (!previousNode || previousNode.type !== 'comment') {
        return false;
    }
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isSharedLineComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(previousNode);
}
}}),
"[project]/node_modules/stylelint/lib/utils/hasBlock.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Check if a statement has an block (empty or otherwise).
 *
 * @param {import('postcss').Container} statement
 * @returns {boolean} True if `statement` has a block (empty or otherwise)
 */ __turbopack_context__.s({
    "default": (()=>hasBlock)
});
function hasBlock(statement) {
    return statement.nodes !== undefined;
}
}}),
"[project]/node_modules/stylelint/lib/utils/isBlocklessAtRuleAfterBlocklessAtRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>isBlocklessAtRuleAfterBlocklessAtRule)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getPreviousNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/getPreviousNonSharedLineCommentNode.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$hasBlock$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/hasBlock.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/typeGuards.mjs [app-route] (ecmascript)");
;
;
;
function isBlocklessAtRuleAfterBlocklessAtRule(atRule) {
    if (atRule.type !== 'atrule') {
        return false;
    }
    const previousNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getPreviousNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule);
    if (previousNode === undefined) {
        return false;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isAtRule"])(previousNode) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$hasBlock$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(previousNode) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$hasBlock$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule);
}
}}),
"[project]/node_modules/stylelint/lib/utils/isBlocklessAtRuleAfterSameNameBlocklessAtRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>isBlocklessAtRuleAfterSameNameBlocklessAtRule)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getPreviousNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/getPreviousNonSharedLineCommentNode.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/typeGuards.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isBlocklessAtRuleAfterBlocklessAtRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isBlocklessAtRuleAfterBlocklessAtRule.mjs [app-route] (ecmascript)");
;
;
;
function isBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isBlocklessAtRuleAfterBlocklessAtRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule)) {
        return false;
    }
    const previousNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getPreviousNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule);
    if (previousNode && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isAtRule"])(previousNode)) {
        return previousNode.name === atRule.name;
    }
    return false;
}
}}),
"[project]/node_modules/stylelint/lib/utils/isFirstNested.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>isFirstNested)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/typeGuards.mjs [app-route] (ecmascript)");
;
function isFirstNested(statement) {
    const parentNode = statement.parent;
    if (parentNode === undefined) {
        return false;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRoot"])(parentNode) && !isInDocument(parentNode)) {
        return false;
    }
    if (statement === parentNode.first) {
        return true;
    }
    /*
	 * Search for the statement in the parent's nodes, ignoring comment
	 * nodes on the same line as the parent's opening brace.
	 */ const parentNodes = parentNode.nodes;
    if (!parentNodes) {
        return false;
    }
    const firstNode = parentNodes[0];
    if (!firstNode) {
        return false;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isComment"])(firstNode) || typeof firstNode.raws.before === 'string' && firstNode.raws.before.includes('\n')) {
        return false;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hasSource"])(firstNode) || !firstNode.source.start) {
        return false;
    }
    const openingBraceLine = firstNode.source.start.line;
    if (!firstNode.source.end || openingBraceLine !== firstNode.source.end.line) {
        return false;
    }
    for (const [index, node] of parentNodes.entries()){
        if (index === 0) {
            continue;
        }
        if (node === statement) {
            return true;
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isComment"])(node) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hasSource"])(node) && node.source.end && node.source.end.line !== openingBraceLine) {
            return false;
        }
    }
    /* istanbul ignore next: Should always return in the loop */ return false;
}
/**
 * @param {import('postcss').Node} node
 * @returns {boolean}
 */ function isInDocument({ parent }) {
    return Boolean(parent && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isDocument"])(parent));
}
}}),
"[project]/node_modules/stylelint/lib/utils/isFirstNodeOfRoot.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>isFirstNodeOfRoot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/typeGuards.mjs [app-route] (ecmascript)");
;
function isFirstNodeOfRoot(node) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRoot"])(node)) return false;
    const parentNode = node.parent;
    if (!parentNode) {
        return false;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRoot"])(parentNode) && node === parentNode.first;
}
}}),
"[project]/node_modules/stylelint/lib/utils/isStandardSyntaxAtRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Check whether a at-rule is standard
 *
 * @param {import('postcss').AtRule | import('postcss-less').AtRule} atRule postcss at-rule node
 * @returns {boolean} If `true`, the declaration is standard
 */ __turbopack_context__.s({
    "default": (()=>isStandardSyntaxAtRule)
});
function isStandardSyntaxAtRule(atRule) {
    // Ignore `@charset` css rule (is parsed as at-rule)
    if (atRule.name.toLowerCase() === 'charset') {
        return false;
    }
    // Ignore scss `@content` inside mixins
    if (!atRule.nodes && atRule.params === '') {
        return false;
    }
    // Ignore Less mixins
    if ('mixin' in atRule && atRule.mixin) {
        return false;
    }
    // Ignore Less detached ruleset `@detached-ruleset: { background: red; }; .top { @detached-ruleset(); }`
    if ('variable' in atRule && atRule.variable || !atRule.nodes && atRule.raws.afterName === '' && atRule.params[0] === '(') {
        return false;
    }
    return true;
}
}}),
"[project]/node_modules/stylelint/lib/rules/at-rule-empty-line-before/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/validateTypes.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$fixEmptyLinesBefore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/fixEmptyLinesBefore.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getPreviousNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/getPreviousNonSharedLineCommentNode.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$hasEmptyLine$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/hasEmptyLine.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isAfterComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isAfterComment.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/typeGuards.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isBlocklessAtRuleAfterBlocklessAtRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isBlocklessAtRuleAfterBlocklessAtRule.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isBlocklessAtRuleAfterSameNameBlocklessAtRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isBlocklessAtRuleAfterSameNameBlocklessAtRule.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isFirstNested$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isFirstNested.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isFirstNodeOfRoot$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isFirstNodeOfRoot.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isStandardSyntaxAtRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/isStandardSyntaxAtRule.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/optionsMatches.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$report$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/report.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$ruleMessages$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/ruleMessages.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateOptions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/validateOptions.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const ruleName = 'at-rule-empty-line-before';
const messages = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$ruleMessages$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(ruleName, {
    expected: 'Expected empty line before at-rule',
    rejected: 'Unexpected empty line before at-rule'
});
const meta = {
    url: 'https://stylelint.io/user-guide/rules/at-rule-empty-line-before',
    fixable: true
};
/** @type {import('stylelint').CoreRules[ruleName]} */ const rule = (primary, secondaryOptions, context)=>{
    return (root, result)=>{
        const validOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateOptions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(result, ruleName, {
            actual: primary,
            possible: [
                'always',
                'never'
            ]
        }, {
            actual: secondaryOptions,
            possible: {
                except: [
                    'after-same-name',
                    'inside-block',
                    'blockless-after-same-name-blockless',
                    'blockless-after-blockless',
                    'first-nested'
                ],
                ignore: [
                    'after-comment',
                    'first-nested',
                    'inside-block',
                    'blockless-after-same-name-blockless',
                    'blockless-after-blockless'
                ],
                ignoreAtRules: [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isString"],
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRegExp"]
                ]
            },
            optional: true
        });
        if (!validOptions) {
            return;
        }
        /** @type {'always' | 'never'} */ const expectation = primary;
        root.walkAtRules((atRule)=>{
            const isNested = atRule.parent && atRule.parent.type !== 'root';
            // Ignore the first node
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isFirstNodeOfRoot$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule)) {
                return;
            }
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isStandardSyntaxAtRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule)) {
                return;
            }
            // Return early if at-rule is to be ignored
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'ignoreAtRules', atRule.name)) {
                return;
            }
            // Optionally ignore the expectation if the node is blockless
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'ignore', 'blockless-after-blockless') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isBlocklessAtRuleAfterBlocklessAtRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule)) {
                return;
            }
            // Optionally ignore the node if it is the first nested
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'ignore', 'first-nested') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isFirstNested$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule)) {
                return;
            }
            // Optionally ignore the expectation if the node is blockless
            // and following another blockless at-rule with the same name
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'ignore', 'blockless-after-same-name-blockless') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isBlocklessAtRuleAfterSameNameBlocklessAtRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule)) {
                return;
            }
            // Optionally ignore the expectation if the node is inside a block
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'ignore', 'inside-block') && isNested) {
                return;
            }
            // Optionally ignore the expectation if a comment precedes this node
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'ignore', 'after-comment') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isAfterComment$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule)) {
                return;
            }
            const hasEmptyLineBefore = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$hasEmptyLine$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule.raws.before);
            let expectEmptyLineBefore = expectation === 'always';
            // Optionally reverse the expectation if any exceptions apply
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'except', 'after-same-name') && isAtRuleAfterSameNameAtRule(atRule) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'except', 'inside-block') && isNested || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'except', 'first-nested') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isFirstNested$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'except', 'blockless-after-blockless') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isBlocklessAtRuleAfterBlocklessAtRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$optionsMatches$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(secondaryOptions, 'except', 'blockless-after-same-name-blockless') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$isBlocklessAtRuleAfterSameNameBlocklessAtRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule)) {
                expectEmptyLineBefore = !expectEmptyLineBefore;
            }
            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
                return;
            }
            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;
            const action = expectEmptyLineBefore ? 'add' : 'remove';
            // Fix
            const fix = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$fixEmptyLinesBefore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
                    node: atRule,
                    newline: context.newline,
                    action
                });
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$report$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
                message,
                node: atRule,
                result,
                ruleName,
                fix: {
                    apply: fix,
                    node: atRule.parent
                }
            });
        });
    };
};
/**
 * @param {import('postcss').AtRule} atRule
 */ function isAtRuleAfterSameNameAtRule(atRule) {
    const previousNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getPreviousNonSharedLineCommentNode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule);
    return previousNode && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$typeGuards$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isAtRule"])(previousNode) && previousNode.name === atRule.name;
}
rule.ruleName = ruleName;
rule.messages = messages;
rule.meta = meta;
const __TURBOPACK__default__export__ = rule;
}}),

};

//# sourceMappingURL=node_modules_stylelint_lib_b3bf6c64._.js.map