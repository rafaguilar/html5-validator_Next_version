module.exports = {

"[project]/node_modules/@csstools/css-parser-algorithms/dist/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "CommentNode": (()=>CommentNode),
    "ComponentValueType": (()=>f),
    "ContainerNodeBaseClass": (()=>ContainerNodeBaseClass),
    "FunctionNode": (()=>FunctionNode),
    "SimpleBlockNode": (()=>SimpleBlockNode),
    "TokenNode": (()=>TokenNode),
    "WhitespaceNode": (()=>WhitespaceNode),
    "forEach": (()=>forEach),
    "gatherNodeAncestry": (()=>gatherNodeAncestry),
    "isCommentNode": (()=>isCommentNode),
    "isFunctionNode": (()=>isFunctionNode),
    "isSimpleBlockNode": (()=>isSimpleBlockNode),
    "isTokenNode": (()=>isTokenNode),
    "isWhiteSpaceOrCommentNode": (()=>isWhiteSpaceOrCommentNode),
    "isWhitespaceNode": (()=>isWhitespaceNode),
    "parseCommaSeparatedListOfComponentValues": (()=>parseCommaSeparatedListOfComponentValues),
    "parseComponentValue": (()=>parseComponentValue),
    "parseListOfComponentValues": (()=>parseListOfComponentValues),
    "replaceComponentValues": (()=>replaceComponentValues),
    "sourceIndices": (()=>sourceIndices),
    "stringify": (()=>stringify),
    "walk": (()=>walk),
    "walkerIndexGenerator": (()=>walkerIndexGenerator)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@csstools/css-tokenizer/dist/index.mjs [app-route] (ecmascript)");
;
var f;
function walkerIndexGenerator(e) {
    let n = e.slice();
    return (e, t, o)=>{
        let s = -1;
        for(let i = n.indexOf(t); i < n.length && (s = e.indexOf(n[i]), -1 === s || s < o); i++);
        return -1 === s || s === o && t === e[o] && (s++, s >= e.length) ? -1 : (n = e.slice(), s);
    };
}
function consumeComponentValue(e, n) {
    const t = n[0];
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenOpenParen"])(t) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenOpenCurly"])(t) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenOpenSquare"])(t)) {
        const t = consumeSimpleBlock(e, n);
        return {
            advance: t.advance,
            node: t.node
        };
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenFunction"])(t)) {
        const t = consumeFunction(e, n);
        return {
            advance: t.advance,
            node: t.node
        };
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenWhitespace"])(t)) {
        const t = consumeWhitespace(e, n);
        return {
            advance: t.advance,
            node: t.node
        };
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenComment"])(t)) {
        const t = consumeComment(e, n);
        return {
            advance: t.advance,
            node: t.node
        };
    }
    return {
        advance: 1,
        node: new TokenNode(t)
    };
}
!function(e) {
    e.Function = "function", e.SimpleBlock = "simple-block", e.Whitespace = "whitespace", e.Comment = "comment", e.Token = "token";
}(f || (f = {}));
class ContainerNodeBaseClass {
    value = [];
    indexOf(e) {
        return this.value.indexOf(e);
    }
    at(e) {
        if ("number" == typeof e) return e < 0 && (e = this.value.length + e), this.value[e];
    }
    forEach(e, n) {
        if (0 === this.value.length) return;
        const t = walkerIndexGenerator(this.value);
        let o = 0;
        for(; o < this.value.length;){
            const s = this.value[o];
            let i;
            if (n && (i = {
                ...n
            }), !1 === e({
                node: s,
                parent: this,
                state: i
            }, o)) return !1;
            if (o = t(this.value, s, o), -1 === o) break;
        }
    }
    walk(e, n) {
        0 !== this.value.length && this.forEach((n, t)=>!1 !== e(n, t) && (!("walk" in n.node) || !this.value.includes(n.node) || !1 !== n.node.walk(e, n.state)) && void 0, n);
    }
}
class FunctionNode extends ContainerNodeBaseClass {
    type = f.Function;
    name;
    endToken;
    constructor(e, n, t){
        super(), this.name = e, this.endToken = n, this.value = t;
    }
    getName() {
        return this.name[4].value;
    }
    normalize() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenEOF"])(this.endToken) && (this.endToken = [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TokenType"].CloseParen,
            ")",
            -1,
            -1,
            void 0
        ]);
    }
    tokens() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenEOF"])(this.endToken) ? [
            this.name,
            ...this.value.flatMap((e)=>e.tokens())
        ] : [
            this.name,
            ...this.value.flatMap((e)=>e.tokens()),
            this.endToken
        ];
    }
    toString() {
        const e = this.value.map((e)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isToken"])(e) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(e) : e.toString()).join("");
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(this.name) + e + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(this.endToken);
    }
    toJSON() {
        return {
            type: this.type,
            name: this.getName(),
            tokens: this.tokens(),
            value: this.value.map((e)=>e.toJSON())
        };
    }
    isFunctionNode() {
        return FunctionNode.isFunctionNode(this);
    }
    static isFunctionNode(e) {
        return !!e && e instanceof FunctionNode && e.type === f.Function;
    }
}
function consumeFunction(n, t) {
    const o = [];
    let s = 1;
    for(;;){
        const i = t[s];
        if (!i || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenEOF"])(i)) return n.onParseError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ParseError"]("Unexpected EOF while consuming a function.", t[0][2], t[t.length - 1][3], [
            "5.4.9. Consume a function",
            "Unexpected EOF"
        ])), {
            advance: t.length,
            node: new FunctionNode(t[0], i, o)
        };
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenCloseParen"])(i)) return {
            advance: s + 1,
            node: new FunctionNode(t[0], i, o)
        };
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenWhiteSpaceOrComment"])(i)) {
            const e = consumeAllCommentsAndWhitespace(n, t.slice(s));
            s += e.advance, o.push(...e.nodes);
            continue;
        }
        const r = consumeComponentValue(n, t.slice(s));
        s += r.advance, o.push(r.node);
    }
}
class SimpleBlockNode extends ContainerNodeBaseClass {
    type = f.SimpleBlock;
    startToken;
    endToken;
    constructor(e, n, t){
        super(), this.startToken = e, this.endToken = n, this.value = t;
    }
    normalize() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenEOF"])(this.endToken)) {
            const e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mirrorVariant"])(this.startToken);
            e && (this.endToken = e);
        }
    }
    tokens() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenEOF"])(this.endToken) ? [
            this.startToken,
            ...this.value.flatMap((e)=>e.tokens())
        ] : [
            this.startToken,
            ...this.value.flatMap((e)=>e.tokens()),
            this.endToken
        ];
    }
    toString() {
        const e = this.value.map((e)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isToken"])(e) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(e) : e.toString()).join("");
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(this.startToken) + e + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(this.endToken);
    }
    toJSON() {
        return {
            type: this.type,
            startToken: this.startToken,
            tokens: this.tokens(),
            value: this.value.map((e)=>e.toJSON())
        };
    }
    isSimpleBlockNode() {
        return SimpleBlockNode.isSimpleBlockNode(this);
    }
    static isSimpleBlockNode(e) {
        return !!e && e instanceof SimpleBlockNode && e.type === f.SimpleBlock;
    }
}
function consumeSimpleBlock(n, t) {
    const o = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mirrorVariantType"])(t[0][0]);
    if (!o) throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");
    const s = [];
    let i = 1;
    for(;;){
        const r = t[i];
        if (!r || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenEOF"])(r)) return n.onParseError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ParseError"]("Unexpected EOF while consuming a simple block.", t[0][2], t[t.length - 1][3], [
            "5.4.8. Consume a simple block",
            "Unexpected EOF"
        ])), {
            advance: t.length,
            node: new SimpleBlockNode(t[0], r, s)
        };
        if (r[0] === o) return {
            advance: i + 1,
            node: new SimpleBlockNode(t[0], r, s)
        };
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenWhiteSpaceOrComment"])(r)) {
            const e = consumeAllCommentsAndWhitespace(n, t.slice(i));
            i += e.advance, s.push(...e.nodes);
            continue;
        }
        const a = consumeComponentValue(n, t.slice(i));
        i += a.advance, s.push(a.node);
    }
}
class WhitespaceNode {
    type = f.Whitespace;
    value;
    constructor(e){
        this.value = e;
    }
    tokens() {
        return this.value;
    }
    toString() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(...this.value);
    }
    toJSON() {
        return {
            type: this.type,
            tokens: this.tokens()
        };
    }
    isWhitespaceNode() {
        return WhitespaceNode.isWhitespaceNode(this);
    }
    static isWhitespaceNode(e) {
        return !!e && e instanceof WhitespaceNode && e.type === f.Whitespace;
    }
}
function consumeWhitespace(e, n) {
    let t = 0;
    for(;;){
        const e = n[t];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenWhitespace"])(e)) return {
            advance: t,
            node: new WhitespaceNode(n.slice(0, t))
        };
        t++;
    }
}
class CommentNode {
    type = f.Comment;
    value;
    constructor(e){
        this.value = e;
    }
    tokens() {
        return [
            this.value
        ];
    }
    toString() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(this.value);
    }
    toJSON() {
        return {
            type: this.type,
            tokens: this.tokens()
        };
    }
    isCommentNode() {
        return CommentNode.isCommentNode(this);
    }
    static isCommentNode(e) {
        return !!e && e instanceof CommentNode && e.type === f.Comment;
    }
}
function consumeComment(e, n) {
    return {
        advance: 1,
        node: new CommentNode(n[0])
    };
}
function consumeAllCommentsAndWhitespace(e, n) {
    const t = [];
    let o = 0;
    for(;;)if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenWhitespace"])(n[o])) {
        const e = consumeWhitespace(0, n.slice(o));
        o += e.advance, t.push(e.node);
    } else {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenComment"])(n[o])) return {
            advance: o,
            nodes: t
        };
        t.push(new CommentNode(n[o])), o++;
    }
}
class TokenNode {
    type = f.Token;
    value;
    constructor(e){
        this.value = e;
    }
    tokens() {
        return [
            this.value
        ];
    }
    toString() {
        return this.value[1];
    }
    toJSON() {
        return {
            type: this.type,
            tokens: this.tokens()
        };
    }
    isTokenNode() {
        return TokenNode.isTokenNode(this);
    }
    static isTokenNode(e) {
        return !!e && e instanceof TokenNode && e.type === f.Token;
    }
}
function parseComponentValue(t, o) {
    const s = {
        onParseError: o?.onParseError ?? (()=>{})
    }, i = [
        ...t
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenEOF"])(i[i.length - 1]) && i.push([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TokenType"].EOF,
        "",
        i[i.length - 1][2],
        i[i.length - 1][3],
        void 0
    ]);
    const r = consumeComponentValue(s, i);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenEOF"])(i[Math.min(r.advance, i.length - 1)])) return r.node;
    s.onParseError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ParseError"]("Expected EOF after parsing a component value.", t[0][2], t[t.length - 1][3], [
        "5.3.9. Parse a component value",
        "Expected EOF"
    ]));
}
function parseListOfComponentValues(t, o) {
    const s = {
        onParseError: o?.onParseError ?? (()=>{})
    }, i = [
        ...t
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenEOF"])(i[i.length - 1]) && i.push([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TokenType"].EOF,
        "",
        i[i.length - 1][2],
        i[i.length - 1][3],
        void 0
    ]);
    const r = [];
    let a = 0;
    for(;;){
        if (!i[a] || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenEOF"])(i[a])) return r;
        const n = consumeComponentValue(s, i.slice(a));
        r.push(n.node), a += n.advance;
    }
}
function parseCommaSeparatedListOfComponentValues(t, o) {
    const s = {
        onParseError: o?.onParseError ?? (()=>{})
    }, i = [
        ...t
    ];
    if (0 === t.length) return [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenEOF"])(i[i.length - 1]) && i.push([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TokenType"].EOF,
        "",
        i[i.length - 1][2],
        i[i.length - 1][3],
        void 0
    ]);
    const r = [];
    let a = [], c = 0;
    for(;;){
        if (!i[c] || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenEOF"])(i[c])) return a.length && r.push(a), r;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenComma"])(i[c])) {
            r.push(a), a = [], c++;
            continue;
        }
        const n = consumeComponentValue(s, t.slice(c));
        a.push(n.node), c += n.advance;
    }
}
function gatherNodeAncestry(e) {
    const n = new Map;
    return e.walk((e)=>{
        Array.isArray(e.node) ? e.node.forEach((t)=>{
            n.set(t, e.parent);
        }) : n.set(e.node, e.parent);
    }), n;
}
function forEach(e, n, t) {
    if (0 === e.length) return;
    const o = walkerIndexGenerator(e);
    let s = 0;
    for(; s < e.length;){
        const i = e[s];
        let r;
        if (t && (r = {
            ...t
        }), !1 === n({
            node: i,
            parent: {
                value: e
            },
            state: r
        }, s)) return !1;
        if (s = o(e, i, s), -1 === s) break;
    }
}
function walk(e, n, t) {
    0 !== e.length && forEach(e, (t, o)=>!1 !== n(t, o) && (!("walk" in t.node) || !e.includes(t.node) || !1 !== t.node.walk(n, t.state)) && void 0, t);
}
function replaceComponentValues(e, n) {
    for(let t = 0; t < e.length; t++){
        walk(e[t], (e, t)=>{
            if ("number" != typeof t) return;
            const o = n(e.node);
            o && (Array.isArray(o) ? e.parent.value.splice(t, 1, ...o) : e.parent.value.splice(t, 1, o));
        });
    }
    return e;
}
function stringify(e) {
    return e.map((e)=>e.map((e)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(...e.tokens())).join("")).join(",");
}
function isSimpleBlockNode(e) {
    return SimpleBlockNode.isSimpleBlockNode(e);
}
function isFunctionNode(e) {
    return FunctionNode.isFunctionNode(e);
}
function isWhitespaceNode(e) {
    return WhitespaceNode.isWhitespaceNode(e);
}
function isCommentNode(e) {
    return CommentNode.isCommentNode(e);
}
function isWhiteSpaceOrCommentNode(e) {
    return isWhitespaceNode(e) || isCommentNode(e);
}
function isTokenNode(e) {
    return TokenNode.isTokenNode(e);
}
function sourceIndices(e) {
    if (Array.isArray(e)) {
        const n = e[0];
        if (!n) return [
            0,
            0
        ];
        const t = e[e.length - 1] || n;
        return [
            sourceIndices(n)[0],
            sourceIndices(t)[1]
        ];
    }
    const n = e.tokens(), t = n[0], o = n[n.length - 1];
    return t && o ? [
        t[2],
        o[3]
    ] : [
        0,
        0
    ];
}
;
}}),
"[project]/node_modules/stylelint/lib/utils/getAtRuleParams.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @param {import('postcss').AtRule} atRule
 * @returns {string}
 */ __turbopack_context__.s({
    "default": (()=>getAtRuleParams)
});
function getAtRuleParams(atRule) {
    return atRule.raws.params?.raw ?? atRule.params;
}
}}),
"[project]/node_modules/stylelint/lib/utils/getRuleSelector.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @param {import('postcss').Rule} ruleNode
 * @returns {string}
 */ __turbopack_context__.s({
    "default": (()=>getRuleSelector)
});
function getRuleSelector(ruleNode) {
    const raws = ruleNode.raws;
    return raws.selector && raws.selector.raw || ruleNode.selector;
}
}}),
"[project]/node_modules/stylelint/lib/utils/nodeFieldIndices.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "atRuleAfterIndex": (()=>atRuleAfterIndex),
    "atRuleAfterNameIndex": (()=>atRuleAfterNameIndex),
    "atRuleBetweenIndex": (()=>atRuleBetweenIndex),
    "atRuleParamIndex": (()=>atRuleParamIndex),
    "declarationBetweenIndex": (()=>declarationBetweenIndex),
    "declarationValueIndex": (()=>declarationValueIndex),
    "ruleAfterIndex": (()=>ruleAfterIndex),
    "ruleBetweenIndex": (()=>ruleBetweenIndex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getAtRuleParams$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/getAtRuleParams.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getRuleSelector$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/getRuleSelector.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/validateTypes.mjs [app-route] (ecmascript)");
;
;
;
function atRuleParamIndex(atRule) {
    const index = atRuleAfterNameIndex(atRule);
    return index + (atRule.raws.afterName?.length ?? 0);
}
function atRuleAfterIndex(atRule) {
    // subtract 1 for `}`
    const endOffset = atRule.source?.end?.offset;
    if (!endOffset) return atRule.toString().length - 1;
    const afterLength = atRule.raws?.after?.length;
    if (!afterLength) return endOffset - 1;
    return endOffset - (afterLength + 1);
}
function atRuleAfterNameIndex(atRule) {
    // Initial 1 is for the `@`
    return 1 + atRule.name.length;
}
function atRuleBetweenIndex(atRule) {
    return atRuleParamIndex(atRule) + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getAtRuleParams$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(atRule).length;
}
function declarationBetweenIndex(decl) {
    const { prop } = decl.raws;
    const propIsObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isObject"])(prop);
    return countChars([
        propIsObject && 'prefix' in prop && prop.prefix,
        propIsObject && 'raw' in prop && prop.raw || decl.prop,
        propIsObject && 'suffix' in prop && prop.suffix
    ]);
}
function declarationValueIndex(decl) {
    const { between, value } = decl.raws;
    return declarationBetweenIndex(decl) + countChars([
        between || ':',
        value && 'prefix' in value && value.prefix
    ]);
}
function ruleBetweenIndex(rule) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getRuleSelector$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(rule).length;
}
function ruleAfterIndex(rule) {
    // subtract 1 for `}`
    const endOffset = rule.source?.end?.offset;
    if (!endOffset) return rule.toString().length - 1;
    const afterLength = rule.raws?.after?.length;
    if (!afterLength) return endOffset - 1;
    return endOffset - (afterLength + 1);
}
/**
 * @param {unknown[]} values
 * @returns {number}
 */ function countChars(values) {
    return values.reduce((/** @type {number} */ count, value)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isString"])(value)) return count + value.length;
        return count;
    }, 0);
}
}}),
"[project]/node_modules/stylelint/lib/utils/getDeclarationValue.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @param {import('postcss').Declaration} decl
 * @returns {string}
 */ __turbopack_context__.s({
    "default": (()=>getDeclarationValue)
});
function getDeclarationValue(decl) {
    const raws = decl.raws;
    return raws.value && raws.value.raw || decl.value;
}
}}),
"[project]/node_modules/stylelint/lib/reference/functions.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/** @type {ReadonlySet<string>} */ __turbopack_context__.s({
    "camelCaseFunctions": (()=>camelCaseFunctions),
    "colorFunctions": (()=>colorFunctions),
    "mathFunctions": (()=>mathFunctions)
});
const camelCaseFunctions = new Set([
    'translateX',
    'translateY',
    'translateZ',
    'scaleX',
    'scaleY',
    'scaleZ',
    'rotateX',
    'rotateY',
    'rotateZ',
    'skewX',
    'skewY'
]);
const colorFunctions = new Set([
    'color',
    'color-mix',
    'hsl',
    'hsla',
    'hwb',
    'lab',
    'lch',
    'oklab',
    'oklch',
    'rgb',
    'rgba'
]);
/** @type {ReadonlySet<string>} */ const singleArgumentMathFunctions = new Set([
    'abs',
    'acos',
    'asin',
    'atan',
    'calc',
    'cos',
    'exp',
    'sign',
    'sin',
    'sqrt',
    'tan'
]);
const mathFunctions = new Set([
    ...singleArgumentMathFunctions,
    'atan2',
    'calc-size',
    'clamp',
    'hypot',
    'log',
    'max',
    'min',
    'mod',
    'pow',
    'rem',
    'round'
]);
}}),
"[project]/node_modules/stylelint/lib/utils/setDeclarationValue.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/** @typedef {import('postcss').Declaration} Declaration */ /**
 * @param {Declaration} decl
 * @param {string} value
 * @returns {Declaration} The declaration that was passed in.
 */ __turbopack_context__.s({
    "default": (()=>setDeclarationValue)
});
function setDeclarationValue(decl, value) {
    const raws = decl.raws;
    if (raws.value) {
        raws.value.raw = value;
    } else {
        decl.value = value;
    }
    return decl;
}
}}),
"[project]/node_modules/stylelint/lib/rules/function-calc-no-unspaced-operator/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@csstools/css-tokenizer/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$nodeFieldIndices$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/nodeFieldIndices.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getDeclarationValue$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/getDeclarationValue.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$reference$2f$functions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/reference/functions.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$report$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/report.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$ruleMessages$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/ruleMessages.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$setDeclarationValue$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/setDeclarationValue.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateOptions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/validateOptions.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stylelint/lib/utils/validateTypes.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
const ruleName = 'function-calc-no-unspaced-operator';
const messages = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$ruleMessages$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(ruleName, {
    expectedBefore: (operator)=>`Expected single space before "${operator}" operator`,
    expectedAfter: (operator)=>`Expected single space after "${operator}" operator`
});
const meta = {
    url: 'https://stylelint.io/user-guide/rules/function-calc-no-unspaced-operator',
    fixable: true
};
const OPERATORS = new Set([
    '+',
    '-'
]);
const OPERATOR_REGEX = /[+-]/;
const MATH_FUNCS_REGEX_SOURCE = [
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$reference$2f$functions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mathFunctions"]
].join('|');
const FUNC_NAMES_REGEX = new RegExp(`^(?:${MATH_FUNCS_REGEX_SOURCE})$`, 'i');
const FUNC_CALLS_REGEX = new RegExp(`(?:${MATH_FUNCS_REGEX_SOURCE})\\(`, 'i');
const NEWLINE_REGEX = /\n|\r\n/;
/** @import { CommentNode, ComponentValue, ContainerNode } from '@csstools/css-parser-algorithms' */ /** @type {import('stylelint').CoreRules[ruleName]} */ const rule = (primary)=>{
    return (root, result)=>{
        const validOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateOptions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(result, ruleName, {
            actual: primary
        });
        if (!validOptions) return;
        /**
		 * @param {messages[keyof messages]} message
		 * @param {import('postcss').Node} node
		 * @param {number} index
		 * @param {string} operator
		 * @param {() => void} fix
		 */ function complain(message, node, index, operator, fix) {
            const endIndex = index + operator.length;
            const messageArgs = [
                operator
            ];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$report$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
                message,
                messageArgs,
                node,
                index,
                endIndex,
                result,
                ruleName,
                fix: {
                    apply: fix,
                    node
                }
            });
        }
        root.walkDecls((decl)=>{
            const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$getDeclarationValue$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(decl);
            if (!OPERATOR_REGEX.test(value)) return;
            if (!FUNC_CALLS_REGEX.test(value)) return;
            const nodes = tokenizeDeclarationValue(value);
            if (nodes.length === 0) return;
            const valueIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$nodeFieldIndices$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["declarationValueIndex"])(decl);
            const fixDeclarationValue = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$setDeclarationValue$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(decl, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])([
                    nodes
                ]));
            /**
			 * @param {ContainerNode} node
			 * @param {Operation} operation
			 * @param {'before' | 'after'} position
			 */ function checkCompleteOperation(node, operation, position) {
                if (operation[position].some(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isWhitespaceNode"])) return;
                const messageKey = position === 'before' ? 'expectedBefore' : 'expectedAfter';
                complain(messages[messageKey], decl, valueIndex + operation.operatorCharPosition, operation.operatorChar, ()=>{
                    operation.insertWhitespace(node, position);
                    fixDeclarationValue();
                });
            }
            /**
			 * @param {ContainerNode} node
			 * @param {Operation} operation
			 */ function checkOperationWithoutOperator(node, operation) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenNode"])(operation.firstOperand)) {
                    const token = operation.firstOperand.value;
                    /**
					 * @param {string | undefined} operatorChar
					 * @param {() => void} mutator
					 * @returns {boolean}
					 */ const complainToFirstOperand = (operatorChar, mutator)=>{
                        if (!(operatorChar && OPERATOR_REGEX.test(operatorChar))) return false;
                        const [, , , endPos] = token;
                        operation.completeMissingOperator(operatorChar, endPos, 'append');
                        complain(messages.expectedBefore, decl, valueIndex + operation.operatorCharPosition, operation.operatorChar, ()=>{
                            operation.insertOperatorAfterFirstOperand(node);
                            mutator();
                            fixDeclarationValue();
                        });
                        return true;
                    };
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenDimension"])(token)) {
                        // E.g. '2px+' → ['2px', '+']
                        const [, , , , { unit }] = token;
                        const operatorChar = unit.at(-1);
                        const newUnit = unit.slice(0, -1);
                        if (complainToFirstOperand(operatorChar, ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mutateUnit"])(token, newUnit))) {
                            return;
                        }
                    }
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenIdent"])(token)) {
                        // E.g. 'id+' → ['id', '+']
                        const [, , , , { value: tokenValue }] = token;
                        const operatorChar = tokenValue.at(-1);
                        const newTokenValue = tokenValue.slice(0, -1);
                        if (complainToFirstOperand(operatorChar, ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mutateIdent"])(token, newTokenValue))) {
                            return;
                        }
                    }
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenNode"])(operation.secondOperand) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenNumeric"])(operation.secondOperand.value)) {
                    const token = operation.secondOperand.value;
                    const [, , startPos, , { signCharacter: operatorChar }] = token;
                    if (operatorChar && OPERATOR_REGEX.test(operatorChar)) {
                        operation.completeMissingOperator(operatorChar, startPos, 'prepend');
                        complain(messages.expectedAfter, decl, valueIndex + operation.operatorCharPosition, operation.operatorChar, ()=>{
                            operation.insertOperatorBeforeSecondOperand(node);
                            // Remove an operator character from the second operand token
                            token[4].signCharacter = undefined;
                            token[1] = token[1].slice(1);
                            fixDeclarationValue();
                        });
                    }
                }
            }
            /**
			 * @param {Operation} operation
			 * @param {'before' | 'after'} position
			 */ function checkOperandWhitespace(operation, position) {
                operation[position].forEach((whitespaceNode)=>{
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isWhitespaceNode"])(whitespaceNode)) return;
                    const whitespace = whitespaceNode.toString();
                    if (whitespace === ' ') return;
                    const indexOfFirstNewLine = whitespace.search(NEWLINE_REGEX);
                    if (indexOfFirstNewLine === 0) return;
                    const message = position === 'before' ? messages.expectedBefore : messages.expectedAfter;
                    complain(message, decl, valueIndex + operation.operatorCharPosition, operation.operatorChar, ()=>{
                        whitespaceNode.value = newWhitespaceNode(indexOfFirstNewLine === -1 ? ' ' : whitespace.slice(indexOfFirstNewLine)).value;
                        fixDeclarationValue();
                    });
                });
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["walk"])(nodes, ({ node, state })=>{
                if (!state) return;
                // Step 2
                // Make sure that we are in a math context.
                // Once in a math context we remain in one until we encounter a non-math function.
                // Simple blocks with parentheses are the same as `calc()`
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isFunctionNode"])(node)) {
                    state.inMathFunction = FUNC_NAMES_REGEX.test(node.getName().toLowerCase());
                } else if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isSimpleBlockNode"])(node) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenOpenParen"])(node.startToken)) {
                    state.inMathFunction = false;
                    return;
                }
                if (!state.inMathFunction) return;
                let cursor = 0;
                /** @type {Operation | undefined} */ let operation = undefined;
                while(cursor !== -1 && cursor < node.value.length){
                    // Step 3
                    // Parse into operations
                    // Each operation consumes as much whitespace before and after
                    // Each parse call tries to consume as much as possible up to the next comma or semicolon
                    // Operations consist of
                    // - first operand
                    // - operator
                    // - second operand
                    // - whitespace before and after
                    [operation, cursor] = parseOperation(node, cursor);
                    if (!operation) {
                        cursor++;
                        continue;
                    }
                    // Step 4
                    // If there is no operator, try to find one
                    if (!operation.operator) {
                        checkOperationWithoutOperator(node, operation);
                    }
                    // Step 5
                    // If the operation is complete, ensure there is whitespace around the operator
                    // The operation might have started without an operator and might have been repaired by Step 4
                    if (operation.operator) {
                        checkCompleteOperation(node, operation, 'before');
                        checkCompleteOperation(node, operation, 'after');
                        // Step 6
                        // Normalize the whitespace around the operands
                        checkOperandWhitespace(operation, 'before');
                        checkOperandWhitespace(operation, 'after');
                    }
                    cursor = node.value.indexOf(operation.secondOperand);
                }
            }, {
                inMathFunction: false
            });
        });
    };
};
/**
 * @param {string} value
 * @returns {Array<ComponentValue>}
 */ function tokenizeDeclarationValue(value) {
    const tokens = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tokenize"])({
        css: value
    });
    // Step 1
    // Step 1.1
    // Re-tokenize dimensions with units containing dashes.
    // These might be typo's.
    // For example: `10px-20px` has a unit of `px-20px`
    tokens.forEach((token, i)=>{
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenDimension"])(token)) return;
        const { unit } = token[4];
        if (unit.startsWith('--')) return;
        const indexOfDash = unit.indexOf('-');
        if (indexOfDash === -1) return;
        const remainder = unit.slice(indexOfDash);
        if (remainder.length === 1) return;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mutateUnit"])(token, unit.slice(0, indexOfDash));
        token[3] = token[2] + token[1].length;
        const remainderTokens = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tokenize"])({
            css: remainder
        }).slice(0, -1); // Trim EOF token
        remainderTokens.forEach((remainderToken)=>{
            remainderToken[2] += token[3];
            remainderToken[3] += token[3];
        });
        tokens.splice(i + 1, 0, ...remainderTokens);
    });
    // Step 1.2
    // Re-tokenize scss interpolation blocks
    // Grouping `#` and `{` into a single token allows us to parse these as simple blocks with curly braces.
    // For example: `#{$foo}`
    tokens.forEach((currentToken, i)=>{
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenDelim"])(currentToken) || currentToken[4].value !== '#') return;
        const nextToken = tokens[i + 1];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenOpenCurly"])(nextToken)) return;
        const nextNextToken = tokens[i + 2];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenDelim"])(nextNextToken) || nextNextToken[4].value !== '$') return;
        // Set the string representation of the open curly to `#{`
        nextToken[1] = '#{';
        // Remove the `#` token
        tokens.splice(i, 1);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseListOfComponentValues"])(tokens);
}
/** @see https://drafts.csswg.org/css-values/#typedef-calc-value */ const OPERAND_TOKEN_TYPES = new Set([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TokenType"].Number,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TokenType"].Dimension,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TokenType"].Percentage,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TokenType"].Ident
]);
/**
 * @param {ComponentValue | undefined} node
 * @returns {boolean}
 */ function isOperandNode(node) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isSimpleBlockNode"])(node)) return true;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isFunctionNode"])(node)) {
        const name = node.getName().toLowerCase();
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$reference$2f$functions$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mathFunctions"].has(name) || name === 'var') return true;
        return false;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenNode"])(node)) return false;
    return OPERAND_TOKEN_TYPES.has(node.value[0]);
}
/**
 * @param {string} whitespace
 */ function newWhitespaceNode(whitespace = ' ') {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WhitespaceNode"]([
        [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TokenType"].Whitespace,
            whitespace,
            -1,
            -1,
            undefined
        ]
    ]);
}
class Operation {
    /**
	 * @param {ComponentValue} firstOperand
	 * @param {Array<WhitespaceNode | CommentNode>} before
	 * @param {ComponentValue} secondOperand
	 * @param {Array<WhitespaceNode | CommentNode>} after
	 * @param {TokenNode | undefined} operator
	 */ constructor(firstOperand, before, secondOperand, after, operator){
        /** @type {typeof firstOperand} */ this.firstOperand = firstOperand;
        /** @type {typeof before} */ this.before = before;
        /** @type {typeof secondOperand} */ this.secondOperand = secondOperand;
        /** @type {typeof after} */ this.after = after;
        /** @type {typeof operator} */ this.operator = operator;
    }
    get #operatorToken() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenDelim"])(this.operator?.value));
        return this.operator.value;
    }
    /** @returns {string} */ get operatorChar() {
        return this.#operatorToken[4].value;
    }
    /** @returns {number} */ get operatorCharPosition() {
        return this.#operatorToken[2];
    }
    /**
	 * @param {ContainerNode} node
	 * @param {'before' | 'after'} position
	 */ insertWhitespace(node, position) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.operator);
        node.value.splice(node.value.indexOf(this.operator) + (position === 'before' ? 0 : 1), 0, newWhitespaceNode());
    }
    /**
	 * @param {ContainerNode} node
	 */ insertOperatorAfterFirstOperand(node) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.operator);
        node.value.splice(node.value.indexOf(this.firstOperand) + 1, 0, ...this.before, this.operator);
    }
    /**
	 * @param {ContainerNode} node
	 */ insertOperatorBeforeSecondOperand(node) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stylelint$2f$lib$2f$utils$2f$validateTypes$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assert"])(this.operator);
        node.value.splice(node.value.indexOf(this.secondOperand), 0, this.operator, ...this.after);
    }
    /**
	 * @param {string} operatorChar
	 * @param {number} operatorCharPosition
	 * @param {'append' | 'prepend'} type
	 */ completeMissingOperator(operatorChar, operatorCharPosition, type) {
        this.operator = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TokenNode"]([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TokenType"].Delim,
            operatorChar,
            operatorCharPosition,
            operatorCharPosition + operatorChar.length,
            {
                value: operatorChar
            }
        ]);
        if (type === 'append') {
            this.after = this.before;
            this.before = [
                newWhitespaceNode()
            ];
        } else {
            this.after = [
                newWhitespaceNode()
            ];
        }
    }
}
/**
 * @param {ContainerNode} container
 * @param {number} cursor
 * @returns {[Operation | undefined, number]}
 */ function parseOperation(container, cursor) {
    let firstOperand = undefined;
    let secondOperand = undefined;
    const before = [];
    const after = [];
    let operator = undefined;
    let currentNode = container.value[cursor];
    // Consume as much whitespace and comments as possible
    while((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isWhiteSpaceOrCommentNode"])(currentNode)){
        currentNode = container.value[++cursor];
    }
    // If the current node is an operand, consume it
    if (isOperandNode(currentNode)) {
        firstOperand = currentNode;
        currentNode = container.value[++cursor];
    }
    // Consume as much whitespace and comments as possible
    // Assign to `before`
    while((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isWhiteSpaceOrCommentNode"])(currentNode)){
        before.push(currentNode);
        currentNode = container.value[++cursor];
    }
    // If the current node is an operator, consume it
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenNode"])(currentNode) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenDelim"])(currentNode.value) && OPERATORS.has(currentNode.value[4].value)) {
        operator = currentNode;
        currentNode = container.value[++cursor];
    }
    // Consume as much whitespace and comments as possible
    // Assign to `after`
    while((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isWhiteSpaceOrCommentNode"])(currentNode)){
        after.push(currentNode);
        currentNode = container.value[++cursor];
    }
    // If the current node is an operand, consume it
    if (isOperandNode(currentNode)) {
        secondOperand = currentNode;
        currentNode = container.value[++cursor];
    }
    // Consume as much whitespace and comments as possible
    while((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isWhiteSpaceOrCommentNode"])(currentNode)){
        currentNode = container.value[++cursor];
    }
    // If we have not consumed any operands, we are not in an operation
    // Do error recovery by consuming until the next comma or semicolon
    // If no comma or semicolon is found, consume until the end of the container
    if (!firstOperand || !secondOperand) {
        while(currentNode){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$parser$2d$algorithms$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenNode"])(currentNode) && ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenComma"])(currentNode.value) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$csstools$2f$css$2d$tokenizer$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenSemicolon"])(currentNode.value))) {
                return [
                    undefined,
                    cursor
                ];
            }
            currentNode = container.value[++cursor];
        }
        return [
            undefined,
            container.value.length
        ];
    }
    return [
        new Operation(firstOperand, before, secondOperand, after, operator),
        cursor
    ];
}
rule.ruleName = ruleName;
rule.messages = messages;
rule.meta = meta;
const __TURBOPACK__default__export__ = rule;
}}),

};

//# sourceMappingURL=node_modules_313bbe53._.js.map